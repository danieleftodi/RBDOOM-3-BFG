DEBUG :: MAIN :: STARTING DOOM3 BFG
DEBUG :: MAIN :: Posix_EarlyInit()
DEBUG :: Posix_EarlyInit()
DEBUG :: Posix_InitSigs()
QA Timing INIT: 000434ms
RBDOOM 3 BFG 1.3.0.1401 osx-x86_64 Dec  2 2020 22:55:47
loopback
192.168.1.4/255.255.255.0
192.168.1.5/255.255.255.0
169.254.101.64/255.255.0.0
10.211.55.2/255.255.255.0
10.37.129.2/255.255.255.0
no 'base' directory in exe path /Users/seludeft/gits/RBDOOM-3-BFG/./build-opengl, skipping
------ Initializing File System ------
Loaded resource file _common.resources
Loaded resource file _ordered.resources
Loaded resource file _sound_pc.resources
Loaded resource file _sound_pc_en.resources
Loaded resource file maps/admin.resources
Loaded resource file maps/alphalabs1.resources
Loaded resource file maps/alphalabs2.resources
Loaded resource file maps/alphalabs3.resources
Loaded resource file maps/alphalabs4.resources
Loaded resource file maps/caverns1.resources
Loaded resource file maps/caverns2.resources
Loaded resource file maps/comm1.resources
Loaded resource file maps/commoutside.resources
Loaded resource file maps/cpu.resources
Loaded resource file maps/cpuboss.resources
Loaded resource file maps/d3ctf1.resources
Loaded resource file maps/d3ctf2.resources
Loaded resource file maps/d3ctf3.resources
Loaded resource file maps/d3ctf4.resources
Loaded resource file maps/d3dm1.resources
Loaded resource file maps/d3dm2.resources
Loaded resource file maps/d3dm3.resources
Loaded resource file maps/d3dm4.resources
Loaded resource file maps/d3dm5.resources
Loaded resource file maps/d3xpdm1.resources
Loaded resource file maps/d3xpdm2.resources
Loaded resource file maps/d3xpdm3.resources
Loaded resource file maps/d3xpdm4.resources
Loaded resource file maps/delta1.resources
Loaded resource file maps/delta2a.resources
Loaded resource file maps/delta2b.resources
Loaded resource file maps/delta3.resources
Loaded resource file maps/delta4.resources
Loaded resource file maps/delta5.resources
Loaded resource file maps/deltax.resources
Loaded resource file maps/enpro.resources
Loaded resource file maps/erebus1.resources
Loaded resource file maps/erebus2.resources
Loaded resource file maps/erebus3.resources
Loaded resource file maps/erebus4.resources
Loaded resource file maps/erebus5.resources
Loaded resource file maps/erebus6.resources
Loaded resource file maps/hell.resources
Loaded resource file maps/hell1.resources
Loaded resource file maps/hellhole.resources
Loaded resource file maps/le_enpro1.resources
Loaded resource file maps/le_enpro2.resources
Loaded resource file maps/le_exis1.resources
Loaded resource file maps/le_exis2.resources
Loaded resource file maps/le_hell.resources
Loaded resource file maps/le_hell_post.resources
Loaded resource file maps/le_underground.resources
Loaded resource file maps/le_underground2.resources
Loaded resource file maps/mars_city1.resources
Loaded resource file maps/mars_city2.resources
Loaded resource file maps/mc_underground.resources
Loaded resource file maps/monorail.resources
Loaded resource file maps/phobos1.resources
Loaded resource file maps/phobos2.resources
Loaded resource file maps/phobos3.resources
Loaded resource file maps/phobos4.resources
Loaded resource file maps/recycling1.resources
Loaded resource file maps/recycling2.resources
Loaded resource file maps/site3.resources
Current search path:
/Users/seludeft/Library/Application Support/RBDOOM-3-BFG//base
/Users/seludeft/gits/RBDOOM-3-BFG/base
_common.resources
_ordered.resources
_sound_pc.resources
_sound_pc_en.resources
maps/admin.resources
maps/alphalabs1.resources
maps/alphalabs2.resources
maps/alphalabs3.resources
maps/alphalabs4.resources
maps/caverns1.resources
maps/caverns2.resources
maps/comm1.resources
maps/commoutside.resources
maps/cpu.resources
maps/cpuboss.resources
maps/d3ctf1.resources
maps/d3ctf2.resources
maps/d3ctf3.resources
maps/d3ctf4.resources
maps/d3dm1.resources
maps/d3dm2.resources
maps/d3dm3.resources
maps/d3dm4.resources
maps/d3dm5.resources
maps/d3xpdm1.resources
maps/d3xpdm2.resources
maps/d3xpdm3.resources
maps/d3xpdm4.resources
maps/delta1.resources
maps/delta2a.resources
maps/delta2b.resources
maps/delta3.resources
maps/delta4.resources
maps/delta5.resources
maps/deltax.resources
maps/enpro.resources
maps/erebus1.resources
maps/erebus2.resources
maps/erebus3.resources
maps/erebus4.resources
maps/erebus5.resources
maps/erebus6.resources
maps/hell.resources
maps/hell1.resources
maps/hellhole.resources
maps/le_enpro1.resources
maps/le_enpro2.resources
maps/le_exis1.resources
maps/le_exis2.resources
maps/le_hell.resources
maps/le_hell_post.resources
maps/le_underground.resources
maps/le_underground2.resources
maps/mars_city1.resources
maps/mars_city2.resources
maps/mc_underground.resources
maps/monorail.resources
maps/phobos1.resources
maps/phobos2.resources
maps/phobos3.resources
maps/phobos4.resources
maps/recycling1.resources
maps/recycling2.resources
maps/site3.resources
file system initialized.
--------------------------------------
WARNING: Unable to open resource file maps/_startup.resources
----- Initializing Decls -----
------------------------------
Couldn't open journal files
CPU processors: 4
CPU logical cores: 8
execing default.cfg
execing D3BFGConfig.cfg
couldn't exec autoexec.cfg
----- R_InitOpenGL -----
----- Initializing OpenGL subsystem -----
DEBUG :: SLD<2 :: r_useOpenGL32.GetInteger() > 0
DEBUG :: SLD<2 :: r_useOpenGL32.GetInteger() > 1
DEBUG :: SLD<2 :: window = SDL_CreateWindow()
Using 8 color bits, 24 depth, 8 stencil display
Using GLEW 2.1.0
OpenGL Version   : 4.1
OpenGL Vendor    : ATI Technologies Inc.
OpenGL Renderer  : AMD Radeon R9 M370X OpenGL Engine
OpenGL GLSL      : 4.1
OpenGL Extensions: GL_ARB_blend_func_extended GL_ARB_draw_buffers_blend GL_ARB_draw_indirect GL_ARB_ES2_compatibility GL_ARB_explicit_attrib_location GL_ARB_gpu_shader_fp64 GL_ARB_gpu_shader5 GL_ARB_instanced_arrays GL_ARB_internalformat_query GL_ARB_occlusion_query2 GL_ARB_sample_shading GL_ARB_sampler_objects GL_ARB_separate_shader_objects GL_ARB_shader_bit_encoding GL_ARB_shader_subroutine GL_ARB_shading_language_include GL_ARB_tessellation_shader GL_ARB_texture_buffer_object_rgb32 GL_ARB_texture_cube_map_array GL_ARB_texture_gather GL_ARB_texture_query_lod GL_ARB_texture_rgb10_a2ui GL_ARB_texture_storage GL_ARB_texture_swizzle GL_ARB_timer_query GL_ARB_transform_feedback2 GL_ARB_transform_feedback3 GL_ARB_vertex_attrib_64bit GL_ARB_vertex_type_2_10_10_10_rev GL_ARB_viewport_array GL_EXT_debug_label GL_EXT_debug_marker GL_EXT_depth_bounds_test GL_EXT_texture_compression_s3tc GL_EXT_texture_filter_anisotropic GL_EXT_texture_mirror_clamp GL_EXT_texture_sRGB_decode GL_APPLE_client_storage GL_APPLE_container_object_shareable GL_APPLE_flush_render GL_APPLE_object_purgeable GL_APPLE_rgb_422 GL_APPLE_row_bytes GL_APPLE_texture_range GL_ATI_texture_mirror_once GL_NV_texture_barrier
   maxTextureAnisotropy: 16.000000
...using GL_EXT_texture_lod_bias
X..GL_GREMEDY_string_marker not found
X..GLEW_KHR_debug not found
...using GL_ARB_framebuffer_object
...using GL_EXT_framebuffer_blit
----- Initializing Render Shaders -----
While compiling vertex program renderprogs/gui.vs.hlsl
-----------------
  1: // filename renderprogs/gui.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: vec4 swizzleColor (vec4 c ) {
 12: 	return c ;
 13: }
 14: 
 15: in vec4 in_Position;
 16: in vec2 in_TexCoord;
 17: in vec4 in_Normal;
 18: in vec4 in_Tangent;
 19: in vec4 in_Color;
 20: in vec4 in_Color2;
 21: 
 22: out vec2 vofi_TexCoord0;
 23: out vec4 vofi_TexCoord1;
 24: out vec4 vofi_Color;
 25: 
 26: void main() {
 27: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 28: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 29: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 30: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 31: 	vofi_TexCoord0 . xy = in_TexCoord . xy ;
 32: 	vofi_TexCoord1 = ( ( in_Color2 ) * 2.0 ) - 1.0 ;
 33: 	vofi_Color = swizzleColor ( in_Color ) ;
 34: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/gui.ps.hlsl
-----------------
  1: // filename renderprogs/gui.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: uniform sampler2D samp0;
 17: 
 18: in vec2 vofi_TexCoord0;
 19: in vec4 vofi_TexCoord1;
 20: in vec4 vofi_Color;
 21: 
 22: out vec4 fo_FragColor;
 23: 
 24: void main() {
 25: 	vec4 color = ( texture ( samp0 , vofi_TexCoord0 ) * vofi_Color ) + vofi_TexCoord1 ;
 26: 	fo_FragColor . xyz = color. xyz * color. w ;
 27: 	fo_FragColor . w = color. w ;
 28: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 0 with vertexShader gui and fragmentShader gui
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/color.vs.hlsl
-----------------
  1: // filename renderprogs/color.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: in vec2 in_TexCoord;
 14: in vec4 in_Normal;
 15: in vec4 in_Tangent;
 16: in vec4 in_Color;
 17: in vec4 in_Color2;
 18: 
 19: 
 20: void main() {
 21: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 22: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 23: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 24: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 25: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/color.ps.hlsl
-----------------
  1: // filename renderprogs/color.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: out vec4 fo_FragColor;
 20: 
 21: void main() {
 22: 	fo_FragColor = _fa_[0 /* rpColor */] ;
 23: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 1 with vertexShader color and fragmentShader color
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/color.vs.hlsl
-----------------
  1: // filename renderprogs/color.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 12: 
 13: in vec4 in_Position;
 14: in vec2 in_TexCoord;
 15: in vec4 in_Normal;
 16: in vec4 in_Tangent;
 17: in vec4 in_Color;
 18: in vec4 in_Color2;
 19: 
 20: 
 21: void main() {
 22: 	float w0 = in_Color2 . x ;
 23: 	float w1 = in_Color2 . y ;
 24: 	float w2 = in_Color2 . z ;
 25: 	float w3 = in_Color2 . w ;
 26: 	vec4 matX , matY , matZ ;
 27: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 28: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 29: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 30: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 31: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 32: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 33: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 34: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 35: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 36: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 37: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 38: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 39: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 40: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 41: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 42: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 43: 	vec4 modelPosition ;
 44: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 45: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 46: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 47: 	modelPosition. w = 1.0 ;
 48: 	gl_Position . x = dot4 ( modelPosition , _va_[0 /* rpMVPmatrixX */] ) ;
 49: 	gl_Position . y = dot4 ( modelPosition , _va_[1 /* rpMVPmatrixY */] ) ;
 50: 	gl_Position . z = dot4 ( modelPosition , _va_[2 /* rpMVPmatrixZ */] ) ;
 51: 	gl_Position . w = dot4 ( modelPosition , _va_[3 /* rpMVPmatrixW */] ) ;
 52: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/color.ps.hlsl
-----------------
  1: // filename renderprogs/color.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: out vec4 fo_FragColor;
 20: 
 21: void main() {
 22: 	fo_FragColor = _fa_[0 /* rpColor */] ;
 23: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 2 with vertexShader color and fragmentShader color
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/vertex_color.vs.hlsl
-----------------
  1: // filename renderprogs/vertex_color.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: vec4 swizzleColor (vec4 c ) {
 12: 	return c ;
 13: }
 14: 
 15: in vec4 in_Position;
 16: in vec2 in_TexCoord;
 17: in vec4 in_Normal;
 18: in vec4 in_Tangent;
 19: in vec4 in_Color;
 20: 
 21: out vec4 vofi_Color;
 22: 
 23: void main() {
 24: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 25: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 26: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 27: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 28: 	vofi_Color = swizzleColor ( in_Color ) ;
 29: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/vertex_color.ps.hlsl
-----------------
  1: // filename renderprogs/vertex_color.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: float Linear1 (float c ) {
 17: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 18: }
 19: vec4 sRGBAToLinearRGBA (vec4 c ) {
 20: 	c = clamp ( c , 0.0 , 1.0 ) ;
 21: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 22: }
 23: 
 24: in vec4 vofi_Color;
 25: 
 26: out vec4 fo_FragColor;
 27: 
 28: void main() {
 29: 	fo_FragColor = sRGBAToLinearRGBA ( vofi_Color ) ;
 30: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 3 with vertexShader vertex_color and fragmentShader vertex_color
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/ambient_lighting.vs.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[13];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_Color;
 32: 
 33: void main() {
 34: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 35: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 36: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 37: 	vec4 modelPosition = in_Position ;
 38: 	vec3 normal = vNormal. xyz ;
 39: 	vec3 tangent = vTangent. xyz ;
 40: 	vec3 bitangent = vBitangent. xyz ;
 41: 	gl_Position . x = dot4 ( modelPosition , _va_[9 /* rpMVPmatrixX */] ) ;
 42: 	gl_Position . y = dot4 ( modelPosition , _va_[10 /* rpMVPmatrixY */] ) ;
 43: 	gl_Position . z = dot4 ( modelPosition , _va_[11 /* rpMVPmatrixZ */] ) ;
 44: 	gl_Position . w = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixW */] ) ;
 45: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 46: 	vec4 toLight = normalize ( vec4 ( 0.0 , 0.5 , 1.0 , 1.0 ) ) ;
 47: 	vofi_TexCoord0 . x = dot3 ( tangent , toLight ) ;
 48: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLight ) ;
 49: 	vofi_TexCoord0 . z = dot3 ( normal , toLight ) ;
 50: 	vofi_TexCoord0 . w = 1.0 ;
 51: 	vofi_TexCoord1 = defaultTexCoord ;
 52: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[1 /* rpBumpMatrixS */] ) ;
 53: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[2 /* rpBumpMatrixT */] ) ;
 54: 	vofi_TexCoord4 = defaultTexCoord ;
 55: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[3 /* rpDiffuseMatrixS */] ) ;
 56: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[4 /* rpDiffuseMatrixT */] ) ;
 57: 	vofi_TexCoord5 = defaultTexCoord ;
 58: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[5 /* rpSpecularMatrixS */] ) ;
 59: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[6 /* rpSpecularMatrixT */] ) ;
 60: 	toLight = normalize ( toLight ) ;
 61: 	vec4 toView = normalize ( _va_[0 /* rpLocalViewOrigin */] - modelPosition ) ;
 62: 	vec4 halfAngleVector = toLight + toView ;
 63: 	vofi_TexCoord6 . x = dot3 ( tangent , halfAngleVector ) ;
 64: 	vofi_TexCoord6 . y = dot3 ( bitangent , halfAngleVector ) ;
 65: 	vofi_TexCoord6 . z = dot3 ( normal , halfAngleVector ) ;
 66: 	vofi_TexCoord6 . w = 1.0 ;
 67: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[7 /* rpVertexColorModulate */] ) + _va_[8 /* rpVertexColorAdd */] ;
 68: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/ambient_lighting.ps.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[3];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: uniform sampler2D samp0;
 53: uniform sampler2D samp1;
 54: uniform sampler2D samp2;
 55: 
 56: in vec4 vofi_TexCoord0;
 57: in vec4 vofi_TexCoord1;
 58: in vec4 vofi_TexCoord4;
 59: in vec4 vofi_TexCoord5;
 60: in vec4 vofi_TexCoord6;
 61: in vec4 vofi_Color;
 62: 
 63: out vec4 fo_FragColor;
 64: 
 65: void main() {
 66: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 67: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 68: 	vec4 specMap = sRGBAToLinearRGBA ( texture ( samp1 , vofi_TexCoord5 . xy ) ) ;
 69: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
 70: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 71: 	vec3 localNormal ;
 72: 	localNormal. xy = bumpMap. wy - 0.5 ;
 73: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
 74: 	localNormal = normalize ( localNormal ) ;
 75: 	float specularPower = 10.0 ;
 76: 	float hDotN = dot3 ( normalize ( vofi_TexCoord6 . xyz ) , localNormal ) ;
 77: 	vec3 specularContribution = vec3 ( pow ( abs ( hDotN ) , specularPower ) ) ;
 78: 	vec3 diffuseColor = diffuseMap * ( _fa_[0 /* rpDiffuseModifier */] . xyz ) * 1.5 ;
 79: 	vec3 specularColor = specMap. xyz * specularContribution * ( _fa_[1 /* rpSpecularModifier */] . xyz ) ;
 80: 	float halfLdotN = dot3 ( localNormal , lightVector ) * 0.5 + 0.5 ;
 81: 	halfLdotN *= halfLdotN ;
 82: 	float ldotN = dot3 ( localNormal , lightVector ) ;
 83: 	vec3 lightColor = sRGBToLinearRGB ( _fa_[2 /* rpAmbientColor */] . rgb ) ;
 84: 	float rim = 1.0 - saturate ( hDotN ) ;
 85: 	float rimPower = 8.0 ;
 86: 	vec3 rimColor = sRGBToLinearRGB ( vec3 ( 0.125 ) * 1.2 ) * lightColor * pow ( rim , rimPower ) ;
 87: 	fo_FragColor . xyz = ( ( diffuseColor + specularColor ) * halfLdotN * lightColor + rimColor ) * vofi_Color . rgb ;
 88: 	fo_FragColor . w = vofi_Color . a ;
 89: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 4 with vertexShader ambient_lighting and fragmentShader ambient_lighting
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/ambient_lighting.vs.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[11];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord4;
 27: out vec4 vofi_TexCoord5;
 28: out vec4 vofi_TexCoord6;
 29: out vec4 vofi_Color;
 30: 
 31: void main() {
 32: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 33: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 34: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 35: 	float w0 = in_Color2 . x ;
 36: 	float w1 = in_Color2 . y ;
 37: 	float w2 = in_Color2 . z ;
 38: 	float w3 = in_Color2 . w ;
 39: 	vec4 matX , matY , matZ ;
 40: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 41: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 42: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 43: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 44: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 45: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 46: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 47: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 48: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 49: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 50: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 51: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 52: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 53: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 54: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 55: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 56: 	vec3 normal ;
 57: 	normal. x = dot3 ( matX , vNormal ) ;
 58: 	normal. y = dot3 ( matY , vNormal ) ;
 59: 	normal. z = dot3 ( matZ , vNormal ) ;
 60: 	normal = normalize ( normal ) ;
 61: 	vec3 tangent ;
 62: 	tangent. x = dot3 ( matX , vTangent ) ;
 63: 	tangent. y = dot3 ( matY , vTangent ) ;
 64: 	tangent. z = dot3 ( matZ , vTangent ) ;
 65: 	tangent = normalize ( tangent ) ;
 66: 	vec3 bitangent ;
 67: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 68: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 69: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 70: 	bitangent = normalize ( bitangent ) ;
 71: 	vec4 modelPosition ;
 72: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 73: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 74: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 75: 	modelPosition. w = 1.0 ;
 76: 	gl_Position . x = dot4 ( modelPosition , _va_[7 /* rpMVPmatrixX */] ) ;
 77: 	gl_Position . y = dot4 ( modelPosition , _va_[8 /* rpMVPmatrixY */] ) ;
 78: 	gl_Position . z = dot4 ( modelPosition , _va_[9 /* rpMVPmatrixZ */] ) ;
 79: 	gl_Position . w = dot4 ( modelPosition , _va_[10 /* rpMVPmatrixW */] ) ;
 80: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 81: 	vec4 toLight = normalize ( vec4 ( 0.0 , 0.5 , 1.0 , 1.0 ) ) ;
 82: 	vofi_TexCoord0 . x = dot3 ( tangent , toLight ) ;
 83: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLight ) ;
 84: 	vofi_TexCoord0 . z = dot3 ( normal , toLight ) ;
 85: 	vofi_TexCoord0 . w = 1.0 ;
 86: 	vofi_TexCoord1 = defaultTexCoord ;
 87: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[1 /* rpBumpMatrixS */] ) ;
 88: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[2 /* rpBumpMatrixT */] ) ;
 89: 	vofi_TexCoord4 = defaultTexCoord ;
 90: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[3 /* rpDiffuseMatrixS */] ) ;
 91: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[4 /* rpDiffuseMatrixT */] ) ;
 92: 	vofi_TexCoord5 = defaultTexCoord ;
 93: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[5 /* rpSpecularMatrixS */] ) ;
 94: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[6 /* rpSpecularMatrixT */] ) ;
 95: 	toLight = normalize ( toLight ) ;
 96: 	vec4 toView = normalize ( _va_[0 /* rpLocalViewOrigin */] - modelPosition ) ;
 97: 	vec4 halfAngleVector = toLight + toView ;
 98: 	vofi_TexCoord6 . x = dot3 ( tangent , halfAngleVector ) ;
 99: 	vofi_TexCoord6 . y = dot3 ( bitangent , halfAngleVector ) ;
100: 	vofi_TexCoord6 . z = dot3 ( normal , halfAngleVector ) ;
101: 	vofi_TexCoord6 . w = 1.0 ;
102: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
103: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/ambient_lighting.ps.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[3];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: uniform sampler2D samp0;
 53: uniform sampler2D samp1;
 54: uniform sampler2D samp2;
 55: 
 56: in vec4 vofi_TexCoord0;
 57: in vec4 vofi_TexCoord1;
 58: in vec4 vofi_TexCoord4;
 59: in vec4 vofi_TexCoord5;
 60: in vec4 vofi_TexCoord6;
 61: in vec4 vofi_Color;
 62: 
 63: out vec4 fo_FragColor;
 64: 
 65: void main() {
 66: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 67: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 68: 	vec4 specMap = sRGBAToLinearRGBA ( texture ( samp1 , vofi_TexCoord5 . xy ) ) ;
 69: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
 70: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 71: 	vec3 localNormal ;
 72: 	localNormal. xy = bumpMap. wy - 0.5 ;
 73: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
 74: 	localNormal = normalize ( localNormal ) ;
 75: 	float specularPower = 10.0 ;
 76: 	float hDotN = dot3 ( normalize ( vofi_TexCoord6 . xyz ) , localNormal ) ;
 77: 	vec3 specularContribution = vec3 ( pow ( abs ( hDotN ) , specularPower ) ) ;
 78: 	vec3 diffuseColor = diffuseMap * ( _fa_[0 /* rpDiffuseModifier */] . xyz ) * 1.5 ;
 79: 	vec3 specularColor = specMap. xyz * specularContribution * ( _fa_[1 /* rpSpecularModifier */] . xyz ) ;
 80: 	float halfLdotN = dot3 ( localNormal , lightVector ) * 0.5 + 0.5 ;
 81: 	halfLdotN *= halfLdotN ;
 82: 	float ldotN = dot3 ( localNormal , lightVector ) ;
 83: 	vec3 lightColor = sRGBToLinearRGB ( _fa_[2 /* rpAmbientColor */] . rgb ) ;
 84: 	float rim = 1.0 - saturate ( hDotN ) ;
 85: 	float rimPower = 8.0 ;
 86: 	vec3 rimColor = sRGBToLinearRGB ( vec3 ( 0.125 ) * 1.2 ) * lightColor * pow ( rim , rimPower ) ;
 87: 	fo_FragColor . xyz = ( ( diffuseColor + specularColor ) * halfLdotN * lightColor + rimColor ) * vofi_Color . rgb ;
 88: 	fo_FragColor . w = vofi_Color . a ;
 89: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 5 with vertexShader ambient_lighting and fragmentShader ambient_lighting
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/ambient_lighting_IBL.vs.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting_IBL.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[16];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_Color;
 34: 
 35: void main() {
 36: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 37: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 38: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 39: 	vec4 modelPosition = in_Position ;
 40: 	vec3 normal = vNormal. xyz ;
 41: 	vec3 tangent = vTangent. xyz ;
 42: 	vec3 bitangent = vBitangent. xyz ;
 43: 	gl_Position . x = dot4 ( modelPosition , _va_[9 /* rpMVPmatrixX */] ) ;
 44: 	gl_Position . y = dot4 ( modelPosition , _va_[10 /* rpMVPmatrixY */] ) ;
 45: 	gl_Position . z = dot4 ( modelPosition , _va_[11 /* rpMVPmatrixZ */] ) ;
 46: 	gl_Position . w = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixW */] ) ;
 47: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 48: 	vec4 toLight = normalize ( vec4 ( 0.0 , 0.5 , 1.0 , 1.0 ) ) ;
 49: 	vofi_TexCoord0 = defaultTexCoord ;
 50: 	vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[1 /* rpBumpMatrixS */] ) ;
 51: 	vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[2 /* rpBumpMatrixT */] ) ;
 52: 	vofi_TexCoord1 = defaultTexCoord ;
 53: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[3 /* rpDiffuseMatrixS */] ) ;
 54: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[4 /* rpDiffuseMatrixT */] ) ;
 55: 	vofi_TexCoord2 = defaultTexCoord ;
 56: 	vofi_TexCoord2 . x = dot4 ( in_TexCoord . xy , _va_[5 /* rpSpecularMatrixS */] ) ;
 57: 	vofi_TexCoord2 . y = dot4 ( in_TexCoord . xy , _va_[6 /* rpSpecularMatrixT */] ) ;
 58: 	vec4 toEye = normalize ( _va_[0 /* rpLocalViewOrigin */] - modelPosition ) ;
 59: 	vofi_TexCoord3 . x = dot3 ( toEye , _va_[13 /* rpModelMatrixX */] ) ;
 60: 	vofi_TexCoord3 . y = dot3 ( toEye , _va_[14 /* rpModelMatrixY */] ) ;
 61: 	vofi_TexCoord3 . z = dot3 ( toEye , _va_[15 /* rpModelMatrixZ */] ) ;
 62: 	vofi_TexCoord4 . x = dot3 ( tangent , _va_[13 /* rpModelMatrixX */] ) ;
 63: 	vofi_TexCoord5 . x = dot3 ( tangent , _va_[14 /* rpModelMatrixY */] ) ;
 64: 	vofi_TexCoord6 . x = dot3 ( tangent , _va_[15 /* rpModelMatrixZ */] ) ;
 65: 	vofi_TexCoord4 . y = dot3 ( bitangent , _va_[13 /* rpModelMatrixX */] ) ;
 66: 	vofi_TexCoord5 . y = dot3 ( bitangent , _va_[14 /* rpModelMatrixY */] ) ;
 67: 	vofi_TexCoord6 . y = dot3 ( bitangent , _va_[15 /* rpModelMatrixZ */] ) ;
 68: 	vofi_TexCoord4 . z = dot3 ( normal , _va_[13 /* rpModelMatrixX */] ) ;
 69: 	vofi_TexCoord5 . z = dot3 ( normal , _va_[14 /* rpModelMatrixY */] ) ;
 70: 	vofi_TexCoord6 . z = dot3 ( normal , _va_[15 /* rpModelMatrixZ */] ) ;
 71: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[7 /* rpVertexColorModulate */] ) + _va_[8 /* rpVertexColorAdd */] ;
 72: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/ambient_lighting_IBL.ps.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting_IBL.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[4];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 53: vec3 Fresnel_SchlickRoughness (vec3 specularColor , float vDotN , float roughness ) {
 54: 	return specularColor + ( max ( vec3 ( 1.0 - roughness ) , specularColor ) - specularColor ) * pow ( 1.0 - vDotN , 5.0 ) ;
 55: }
 56: float ComputeSpecularAO (float vDotN , float ao , float roughness ) {
 57: 	return clamp ( pow ( vDotN + ao , exp2 ( - 16.0 * roughness - 1.0 ) ) - 1.0 + ao , 0.0 , 1.0 ) ;
 58: }
 59: uniform sampler2D samp0;
 60: uniform sampler2D samp1;
 61: uniform sampler2D samp2;
 62: uniform sampler2D samp3;
 63: uniform sampler2D samp4;
 64: uniform sampler2D samp7;
 65: uniform sampler2D samp8;
 66: 
 67: in vec4 vofi_TexCoord0;
 68: in vec4 vofi_TexCoord1;
 69: in vec4 vofi_TexCoord2;
 70: in vec4 vofi_TexCoord3;
 71: in vec4 vofi_TexCoord4;
 72: in vec4 vofi_TexCoord5;
 73: in vec4 vofi_TexCoord6;
 74: in vec4 vofi_Color;
 75: 
 76: out vec4 fo_FragColor;
 77: 
 78: float signNotZeroFloat (float k ) {
 79: 	return ( k >= 0.0 ) ? 1.0 : - 1.0 ;
 80: }
 81: vec2 signNotZero (vec2 v ) {
 82: 	return vec2 ( signNotZeroFloat ( v. x ) , signNotZeroFloat ( v. y ) ) ;
 83: }
 84: vec2 octEncode (vec3 v ) {
 85: 	float l1norm = abs ( v. x ) + abs ( v. y ) + abs ( v. z ) ;
 86: 	vec2 oct = v. xy * ( 1.0 / l1norm ) ;
 87: 	if ( v. z < 0.0 )
 88: 	{
 89: 		oct = ( 1.0 - abs ( oct. yx ) ) * signNotZero ( oct. xy ) ;
 90: 	}
 91: 	return oct ;
 92: }
 93: void main() {
 94: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord0 . xy ) ;
 95: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord1 . xy ) ;
 96: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord2 . xy ) ;
 97: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 98: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 99: 	vec3 localNormal ;
100: 	localNormal. xy = bumpMap. wy - 0.5 ;
101: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
102: 	localNormal = normalize ( localNormal ) ;
103: 	vec3 globalNormal ;
104: 	globalNormal. x = dot3 ( localNormal , vofi_TexCoord4 ) ;
105: 	globalNormal. y = dot3 ( localNormal , vofi_TexCoord5 ) ;
106: 	globalNormal. z = dot3 ( localNormal , vofi_TexCoord6 ) ;
107: 	globalNormal = normalize ( globalNormal ) ;
108: 	vec3 globalEye = normalize ( vofi_TexCoord3 . xyz ) ;
109: 	vec3 reflectionVector = globalNormal * dot3 ( globalEye , globalNormal ) ;
110: 	reflectionVector = normalize ( ( reflectionVector * 2.0 ) - globalEye ) ;
111: 	float vDotN = saturate ( dot3 ( globalEye , globalNormal ) ) ;
112: 	float Y = dot ( LUMINANCE_SRGB. rgb , specMapSRGB. rgb ) ;
113: 	float glossiness = clamp ( pow ( Y , 1.0 / 2.0 ) , 0.0 , 0.98 ) ;
114: 	float roughness = 1.0 - glossiness ;
115: 	vec3 diffuseColor = diffuseMap ;
116: 	vec3 specularColor = specMap. rgb ;
117: 	vec3 kS = Fresnel_SchlickRoughness ( specularColor , vDotN , roughness ) ;
118: 	vec3 kD = ( vec3 ( 1.0 , 1.0 , 1.0 ) - kS ) ;
119: 	vec2 screenTexCoord = gl_FragCoord . xy * _fa_[0 /* rpWindowCoord */] . xy ;
120: 	float ao = texture ( samp4 , screenTexCoord ). r ;
121: 	vec2 normalizedOctCoord = octEncode ( globalNormal ) ;
122: 	vec2 normalizedOctCoordZeroOne = ( normalizedOctCoord + vec2 ( 1.0 ) ) * 0.5 ;
123: 	vec3 irradiance = texture ( samp7 , normalizedOctCoordZeroOne ). rgb ;
124: 	vec3 diffuseLight = ( kD * irradiance * diffuseColor ) * ao * ( _fa_[1 /* rpDiffuseModifier */] . xyz * 1.0 ) ;
125: 	float MAX_REFLECTION_LOD = 10.0 ;
126: 	float mip = clamp ( ( roughness * MAX_REFLECTION_LOD ) , 0.0 , MAX_REFLECTION_LOD ) ;
127: 	normalizedOctCoord = octEncode ( reflectionVector ) ;
128: 	normalizedOctCoordZeroOne = ( normalizedOctCoord + vec2 ( 1.0 ) ) * 0.5 ;
129: 	vec3 radiance = textureLod ( samp8 , normalizedOctCoordZeroOne , mip ). rgb ;
130: 	vec2 envBRDF = texture ( samp3 , vec2 ( max ( vDotN , 0.0 ) , roughness ) ). rg ;
131: 	float specAO = ComputeSpecularAO ( vDotN , ao , roughness ) ;
132: 	vec3 specularLight = radiance * ( kS * envBRDF. x + vec3 ( envBRDF. y ) ) * specAO * ( _fa_[2 /* rpSpecularModifier */] . xyz * 0.5 ) ;
133: 	vec3 lightColor = sRGBToLinearRGB ( _fa_[3 /* rpAmbientColor */] . rgb ) ;
134: 	fo_FragColor . rgb = ( diffuseLight + specularLight ) * lightColor * vofi_Color . rgb ;
135: 	fo_FragColor . w = vofi_Color . a ;
136: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 6 with vertexShader ambient_lighting_IBL and fragmentShader ambient_lighting_IBL
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/ambient_lighting_IBL.vs.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting_IBL.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[14];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_Color;
 32: 
 33: void main() {
 34: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 35: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 36: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 37: 	float w0 = in_Color2 . x ;
 38: 	float w1 = in_Color2 . y ;
 39: 	float w2 = in_Color2 . z ;
 40: 	float w3 = in_Color2 . w ;
 41: 	vec4 matX , matY , matZ ;
 42: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 43: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 44: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 45: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 46: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 47: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 48: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 49: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 50: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 51: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 52: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 53: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 54: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 55: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 56: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 57: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 58: 	vec3 normal ;
 59: 	normal. x = dot3 ( matX , vNormal ) ;
 60: 	normal. y = dot3 ( matY , vNormal ) ;
 61: 	normal. z = dot3 ( matZ , vNormal ) ;
 62: 	normal = normalize ( normal ) ;
 63: 	vec3 tangent ;
 64: 	tangent. x = dot3 ( matX , vTangent ) ;
 65: 	tangent. y = dot3 ( matY , vTangent ) ;
 66: 	tangent. z = dot3 ( matZ , vTangent ) ;
 67: 	tangent = normalize ( tangent ) ;
 68: 	vec3 bitangent ;
 69: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 70: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 71: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 72: 	bitangent = normalize ( bitangent ) ;
 73: 	vec4 modelPosition ;
 74: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 75: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 76: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 77: 	modelPosition. w = 1.0 ;
 78: 	gl_Position . x = dot4 ( modelPosition , _va_[7 /* rpMVPmatrixX */] ) ;
 79: 	gl_Position . y = dot4 ( modelPosition , _va_[8 /* rpMVPmatrixY */] ) ;
 80: 	gl_Position . z = dot4 ( modelPosition , _va_[9 /* rpMVPmatrixZ */] ) ;
 81: 	gl_Position . w = dot4 ( modelPosition , _va_[10 /* rpMVPmatrixW */] ) ;
 82: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 83: 	vec4 toLight = normalize ( vec4 ( 0.0 , 0.5 , 1.0 , 1.0 ) ) ;
 84: 	vofi_TexCoord0 = defaultTexCoord ;
 85: 	vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[1 /* rpBumpMatrixS */] ) ;
 86: 	vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[2 /* rpBumpMatrixT */] ) ;
 87: 	vofi_TexCoord1 = defaultTexCoord ;
 88: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[3 /* rpDiffuseMatrixS */] ) ;
 89: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[4 /* rpDiffuseMatrixT */] ) ;
 90: 	vofi_TexCoord2 = defaultTexCoord ;
 91: 	vofi_TexCoord2 . x = dot4 ( in_TexCoord . xy , _va_[5 /* rpSpecularMatrixS */] ) ;
 92: 	vofi_TexCoord2 . y = dot4 ( in_TexCoord . xy , _va_[6 /* rpSpecularMatrixT */] ) ;
 93: 	vec4 toEye = normalize ( _va_[0 /* rpLocalViewOrigin */] - modelPosition ) ;
 94: 	vofi_TexCoord3 . x = dot3 ( toEye , _va_[11 /* rpModelMatrixX */] ) ;
 95: 	vofi_TexCoord3 . y = dot3 ( toEye , _va_[12 /* rpModelMatrixY */] ) ;
 96: 	vofi_TexCoord3 . z = dot3 ( toEye , _va_[13 /* rpModelMatrixZ */] ) ;
 97: 	vofi_TexCoord4 . x = dot3 ( tangent , _va_[11 /* rpModelMatrixX */] ) ;
 98: 	vofi_TexCoord5 . x = dot3 ( tangent , _va_[12 /* rpModelMatrixY */] ) ;
 99: 	vofi_TexCoord6 . x = dot3 ( tangent , _va_[13 /* rpModelMatrixZ */] ) ;
100: 	vofi_TexCoord4 . y = dot3 ( bitangent , _va_[11 /* rpModelMatrixX */] ) ;
101: 	vofi_TexCoord5 . y = dot3 ( bitangent , _va_[12 /* rpModelMatrixY */] ) ;
102: 	vofi_TexCoord6 . y = dot3 ( bitangent , _va_[13 /* rpModelMatrixZ */] ) ;
103: 	vofi_TexCoord4 . z = dot3 ( normal , _va_[11 /* rpModelMatrixX */] ) ;
104: 	vofi_TexCoord5 . z = dot3 ( normal , _va_[12 /* rpModelMatrixY */] ) ;
105: 	vofi_TexCoord6 . z = dot3 ( normal , _va_[13 /* rpModelMatrixZ */] ) ;
106: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
107: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/ambient_lighting_IBL.ps.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting_IBL.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[4];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 53: vec3 Fresnel_SchlickRoughness (vec3 specularColor , float vDotN , float roughness ) {
 54: 	return specularColor + ( max ( vec3 ( 1.0 - roughness ) , specularColor ) - specularColor ) * pow ( 1.0 - vDotN , 5.0 ) ;
 55: }
 56: float ComputeSpecularAO (float vDotN , float ao , float roughness ) {
 57: 	return clamp ( pow ( vDotN + ao , exp2 ( - 16.0 * roughness - 1.0 ) ) - 1.0 + ao , 0.0 , 1.0 ) ;
 58: }
 59: uniform sampler2D samp0;
 60: uniform sampler2D samp1;
 61: uniform sampler2D samp2;
 62: uniform sampler2D samp3;
 63: uniform sampler2D samp4;
 64: uniform sampler2D samp7;
 65: uniform sampler2D samp8;
 66: 
 67: in vec4 vofi_TexCoord0;
 68: in vec4 vofi_TexCoord1;
 69: in vec4 vofi_TexCoord2;
 70: in vec4 vofi_TexCoord3;
 71: in vec4 vofi_TexCoord4;
 72: in vec4 vofi_TexCoord5;
 73: in vec4 vofi_TexCoord6;
 74: in vec4 vofi_Color;
 75: 
 76: out vec4 fo_FragColor;
 77: 
 78: float signNotZeroFloat (float k ) {
 79: 	return ( k >= 0.0 ) ? 1.0 : - 1.0 ;
 80: }
 81: vec2 signNotZero (vec2 v ) {
 82: 	return vec2 ( signNotZeroFloat ( v. x ) , signNotZeroFloat ( v. y ) ) ;
 83: }
 84: vec2 octEncode (vec3 v ) {
 85: 	float l1norm = abs ( v. x ) + abs ( v. y ) + abs ( v. z ) ;
 86: 	vec2 oct = v. xy * ( 1.0 / l1norm ) ;
 87: 	if ( v. z < 0.0 )
 88: 	{
 89: 		oct = ( 1.0 - abs ( oct. yx ) ) * signNotZero ( oct. xy ) ;
 90: 	}
 91: 	return oct ;
 92: }
 93: void main() {
 94: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord0 . xy ) ;
 95: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord1 . xy ) ;
 96: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord2 . xy ) ;
 97: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 98: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 99: 	vec3 localNormal ;
100: 	localNormal. xy = bumpMap. wy - 0.5 ;
101: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
102: 	localNormal = normalize ( localNormal ) ;
103: 	vec3 globalNormal ;
104: 	globalNormal. x = dot3 ( localNormal , vofi_TexCoord4 ) ;
105: 	globalNormal. y = dot3 ( localNormal , vofi_TexCoord5 ) ;
106: 	globalNormal. z = dot3 ( localNormal , vofi_TexCoord6 ) ;
107: 	globalNormal = normalize ( globalNormal ) ;
108: 	vec3 globalEye = normalize ( vofi_TexCoord3 . xyz ) ;
109: 	vec3 reflectionVector = globalNormal * dot3 ( globalEye , globalNormal ) ;
110: 	reflectionVector = normalize ( ( reflectionVector * 2.0 ) - globalEye ) ;
111: 	float vDotN = saturate ( dot3 ( globalEye , globalNormal ) ) ;
112: 	float Y = dot ( LUMINANCE_SRGB. rgb , specMapSRGB. rgb ) ;
113: 	float glossiness = clamp ( pow ( Y , 1.0 / 2.0 ) , 0.0 , 0.98 ) ;
114: 	float roughness = 1.0 - glossiness ;
115: 	vec3 diffuseColor = diffuseMap ;
116: 	vec3 specularColor = specMap. rgb ;
117: 	vec3 kS = Fresnel_SchlickRoughness ( specularColor , vDotN , roughness ) ;
118: 	vec3 kD = ( vec3 ( 1.0 , 1.0 , 1.0 ) - kS ) ;
119: 	vec2 screenTexCoord = gl_FragCoord . xy * _fa_[0 /* rpWindowCoord */] . xy ;
120: 	float ao = texture ( samp4 , screenTexCoord ). r ;
121: 	vec2 normalizedOctCoord = octEncode ( globalNormal ) ;
122: 	vec2 normalizedOctCoordZeroOne = ( normalizedOctCoord + vec2 ( 1.0 ) ) * 0.5 ;
123: 	vec3 irradiance = texture ( samp7 , normalizedOctCoordZeroOne ). rgb ;
124: 	vec3 diffuseLight = ( kD * irradiance * diffuseColor ) * ao * ( _fa_[1 /* rpDiffuseModifier */] . xyz * 1.0 ) ;
125: 	float MAX_REFLECTION_LOD = 10.0 ;
126: 	float mip = clamp ( ( roughness * MAX_REFLECTION_LOD ) , 0.0 , MAX_REFLECTION_LOD ) ;
127: 	normalizedOctCoord = octEncode ( reflectionVector ) ;
128: 	normalizedOctCoordZeroOne = ( normalizedOctCoord + vec2 ( 1.0 ) ) * 0.5 ;
129: 	vec3 radiance = textureLod ( samp8 , normalizedOctCoordZeroOne , mip ). rgb ;
130: 	vec2 envBRDF = texture ( samp3 , vec2 ( max ( vDotN , 0.0 ) , roughness ) ). rg ;
131: 	float specAO = ComputeSpecularAO ( vDotN , ao , roughness ) ;
132: 	vec3 specularLight = radiance * ( kS * envBRDF. x + vec3 ( envBRDF. y ) ) * specAO * ( _fa_[2 /* rpSpecularModifier */] . xyz * 0.5 ) ;
133: 	vec3 lightColor = sRGBToLinearRGB ( _fa_[3 /* rpAmbientColor */] . rgb ) ;
134: 	fo_FragColor . rgb = ( diffuseLight + specularLight ) * lightColor * vofi_Color . rgb ;
135: 	fo_FragColor . w = vofi_Color . a ;
136: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 7 with vertexShader ambient_lighting_IBL and fragmentShader ambient_lighting_IBL
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/ambient_lighting_IBL.vs.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting_IBL.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[16];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_Color;
 34: 
 35: void main() {
 36: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 37: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 38: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 39: 	vec4 modelPosition = in_Position ;
 40: 	vec3 normal = vNormal. xyz ;
 41: 	vec3 tangent = vTangent. xyz ;
 42: 	vec3 bitangent = vBitangent. xyz ;
 43: 	gl_Position . x = dot4 ( modelPosition , _va_[9 /* rpMVPmatrixX */] ) ;
 44: 	gl_Position . y = dot4 ( modelPosition , _va_[10 /* rpMVPmatrixY */] ) ;
 45: 	gl_Position . z = dot4 ( modelPosition , _va_[11 /* rpMVPmatrixZ */] ) ;
 46: 	gl_Position . w = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixW */] ) ;
 47: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 48: 	vec4 toLight = normalize ( vec4 ( 0.0 , 0.5 , 1.0 , 1.0 ) ) ;
 49: 	vofi_TexCoord0 = defaultTexCoord ;
 50: 	vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[1 /* rpBumpMatrixS */] ) ;
 51: 	vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[2 /* rpBumpMatrixT */] ) ;
 52: 	vofi_TexCoord1 = defaultTexCoord ;
 53: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[3 /* rpDiffuseMatrixS */] ) ;
 54: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[4 /* rpDiffuseMatrixT */] ) ;
 55: 	vofi_TexCoord2 = defaultTexCoord ;
 56: 	vofi_TexCoord2 . x = dot4 ( in_TexCoord . xy , _va_[5 /* rpSpecularMatrixS */] ) ;
 57: 	vofi_TexCoord2 . y = dot4 ( in_TexCoord . xy , _va_[6 /* rpSpecularMatrixT */] ) ;
 58: 	vec4 toEye = normalize ( _va_[0 /* rpLocalViewOrigin */] - modelPosition ) ;
 59: 	vofi_TexCoord3 . x = dot3 ( toEye , _va_[13 /* rpModelMatrixX */] ) ;
 60: 	vofi_TexCoord3 . y = dot3 ( toEye , _va_[14 /* rpModelMatrixY */] ) ;
 61: 	vofi_TexCoord3 . z = dot3 ( toEye , _va_[15 /* rpModelMatrixZ */] ) ;
 62: 	vofi_TexCoord4 . x = dot3 ( tangent , _va_[13 /* rpModelMatrixX */] ) ;
 63: 	vofi_TexCoord5 . x = dot3 ( tangent , _va_[14 /* rpModelMatrixY */] ) ;
 64: 	vofi_TexCoord6 . x = dot3 ( tangent , _va_[15 /* rpModelMatrixZ */] ) ;
 65: 	vofi_TexCoord4 . y = dot3 ( bitangent , _va_[13 /* rpModelMatrixX */] ) ;
 66: 	vofi_TexCoord5 . y = dot3 ( bitangent , _va_[14 /* rpModelMatrixY */] ) ;
 67: 	vofi_TexCoord6 . y = dot3 ( bitangent , _va_[15 /* rpModelMatrixZ */] ) ;
 68: 	vofi_TexCoord4 . z = dot3 ( normal , _va_[13 /* rpModelMatrixX */] ) ;
 69: 	vofi_TexCoord5 . z = dot3 ( normal , _va_[14 /* rpModelMatrixY */] ) ;
 70: 	vofi_TexCoord6 . z = dot3 ( normal , _va_[15 /* rpModelMatrixZ */] ) ;
 71: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[7 /* rpVertexColorModulate */] ) + _va_[8 /* rpVertexColorAdd */] ;
 72: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/ambient_lighting_IBL.ps.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting_IBL.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[4];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec3 Fresnel_SchlickRoughness (vec3 specularColor , float vDotN , float roughness ) {
 53: 	return specularColor + ( max ( vec3 ( 1.0 - roughness ) , specularColor ) - specularColor ) * pow ( 1.0 - vDotN , 5.0 ) ;
 54: }
 55: float ComputeSpecularAO (float vDotN , float ao , float roughness ) {
 56: 	return clamp ( pow ( vDotN + ao , exp2 ( - 16.0 * roughness - 1.0 ) ) - 1.0 + ao , 0.0 , 1.0 ) ;
 57: }
 58: uniform sampler2D samp0;
 59: uniform sampler2D samp1;
 60: uniform sampler2D samp2;
 61: uniform sampler2D samp3;
 62: uniform sampler2D samp4;
 63: uniform sampler2D samp7;
 64: uniform sampler2D samp8;
 65: 
 66: in vec4 vofi_TexCoord0;
 67: in vec4 vofi_TexCoord1;
 68: in vec4 vofi_TexCoord2;
 69: in vec4 vofi_TexCoord3;
 70: in vec4 vofi_TexCoord4;
 71: in vec4 vofi_TexCoord5;
 72: in vec4 vofi_TexCoord6;
 73: in vec4 vofi_Color;
 74: 
 75: out vec4 fo_FragColor;
 76: 
 77: float signNotZeroFloat (float k ) {
 78: 	return ( k >= 0.0 ) ? 1.0 : - 1.0 ;
 79: }
 80: vec2 signNotZero (vec2 v ) {
 81: 	return vec2 ( signNotZeroFloat ( v. x ) , signNotZeroFloat ( v. y ) ) ;
 82: }
 83: vec2 octEncode (vec3 v ) {
 84: 	float l1norm = abs ( v. x ) + abs ( v. y ) + abs ( v. z ) ;
 85: 	vec2 oct = v. xy * ( 1.0 / l1norm ) ;
 86: 	if ( v. z < 0.0 )
 87: 	{
 88: 		oct = ( 1.0 - abs ( oct. yx ) ) * signNotZero ( oct. xy ) ;
 89: 	}
 90: 	return oct ;
 91: }
 92: void main() {
 93: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord0 . xy ) ;
 94: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord1 . xy ) ;
 95: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord2 . xy ) ;
 96: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 97: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 98: 	vec3 localNormal ;
 99: 	localNormal. xy = bumpMap. wy - 0.5 ;
100: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
101: 	localNormal = normalize ( localNormal ) ;
102: 	vec3 globalNormal ;
103: 	globalNormal. x = dot3 ( localNormal , vofi_TexCoord4 ) ;
104: 	globalNormal. y = dot3 ( localNormal , vofi_TexCoord5 ) ;
105: 	globalNormal. z = dot3 ( localNormal , vofi_TexCoord6 ) ;
106: 	globalNormal = normalize ( globalNormal ) ;
107: 	vec3 globalEye = normalize ( vofi_TexCoord3 . xyz ) ;
108: 	vec3 reflectionVector = globalNormal * dot3 ( globalEye , globalNormal ) ;
109: 	reflectionVector = normalize ( ( reflectionVector * 2.0 ) - globalEye ) ;
110: 	float vDotN = saturate ( dot3 ( globalEye , globalNormal ) ) ;
111: 	float metallic = specMapSRGB. g ;
112: 	float roughness = specMapSRGB. r ;
113: 	float glossiness = 1.0 - roughness ;
114: 	vec3 dielectricColor = vec3 ( 0.04 ) ;
115: 	vec3 baseColor = diffuseMap ;
116: 	vec3 diffuseColor = baseColor * ( 1.0 - metallic ) ;
117: 	vec3 specularColor = mix ( dielectricColor , baseColor , metallic ) ;
118: 	vec3 kS = Fresnel_SchlickRoughness ( specularColor , vDotN , roughness ) ;
119: 	vec3 kD = ( vec3 ( 1.0 , 1.0 , 1.0 ) - kS ) * ( 1.0 - metallic ) ;
120: 	vec2 screenTexCoord = gl_FragCoord . xy * _fa_[0 /* rpWindowCoord */] . xy ;
121: 	float ao = texture ( samp4 , screenTexCoord ). r ;
122: 	vec2 normalizedOctCoord = octEncode ( globalNormal ) ;
123: 	vec2 normalizedOctCoordZeroOne = ( normalizedOctCoord + vec2 ( 1.0 ) ) * 0.5 ;
124: 	vec3 irradiance = texture ( samp7 , normalizedOctCoordZeroOne ). rgb ;
125: 	vec3 diffuseLight = ( kD * irradiance * diffuseColor ) * ao * ( _fa_[1 /* rpDiffuseModifier */] . xyz * 1.0 ) ;
126: 	float MAX_REFLECTION_LOD = 10.0 ;
127: 	float mip = clamp ( ( roughness * MAX_REFLECTION_LOD ) , 0.0 , MAX_REFLECTION_LOD ) ;
128: 	normalizedOctCoord = octEncode ( reflectionVector ) ;
129: 	normalizedOctCoordZeroOne = ( normalizedOctCoord + vec2 ( 1.0 ) ) * 0.5 ;
130: 	vec3 radiance = textureLod ( samp8 , normalizedOctCoordZeroOne , mip ). rgb ;
131: 	vec2 envBRDF = texture ( samp3 , vec2 ( max ( vDotN , 0.0 ) , roughness ) ). rg ;
132: 	float specAO = ComputeSpecularAO ( vDotN , ao , roughness ) ;
133: 	vec3 specularLight = radiance * ( kS * envBRDF. x + vec3 ( envBRDF. y ) ) * specAO * ( _fa_[2 /* rpSpecularModifier */] . xyz * 0.5 ) ;
134: 	vec3 lightColor = sRGBToLinearRGB ( _fa_[3 /* rpAmbientColor */] . rgb ) ;
135: 	fo_FragColor . rgb = ( diffuseLight + specularLight ) * lightColor * vofi_Color . rgb ;
136: 	fo_FragColor . w = vofi_Color . a ;
137: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 8 with vertexShader ambient_lighting_IBL and fragmentShader ambient_lighting_IBL
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/ambient_lighting_IBL.vs.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting_IBL.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[14];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_Color;
 32: 
 33: void main() {
 34: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 35: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 36: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 37: 	float w0 = in_Color2 . x ;
 38: 	float w1 = in_Color2 . y ;
 39: 	float w2 = in_Color2 . z ;
 40: 	float w3 = in_Color2 . w ;
 41: 	vec4 matX , matY , matZ ;
 42: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 43: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 44: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 45: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 46: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 47: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 48: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 49: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 50: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 51: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 52: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 53: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 54: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 55: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 56: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 57: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 58: 	vec3 normal ;
 59: 	normal. x = dot3 ( matX , vNormal ) ;
 60: 	normal. y = dot3 ( matY , vNormal ) ;
 61: 	normal. z = dot3 ( matZ , vNormal ) ;
 62: 	normal = normalize ( normal ) ;
 63: 	vec3 tangent ;
 64: 	tangent. x = dot3 ( matX , vTangent ) ;
 65: 	tangent. y = dot3 ( matY , vTangent ) ;
 66: 	tangent. z = dot3 ( matZ , vTangent ) ;
 67: 	tangent = normalize ( tangent ) ;
 68: 	vec3 bitangent ;
 69: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 70: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 71: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 72: 	bitangent = normalize ( bitangent ) ;
 73: 	vec4 modelPosition ;
 74: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 75: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 76: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 77: 	modelPosition. w = 1.0 ;
 78: 	gl_Position . x = dot4 ( modelPosition , _va_[7 /* rpMVPmatrixX */] ) ;
 79: 	gl_Position . y = dot4 ( modelPosition , _va_[8 /* rpMVPmatrixY */] ) ;
 80: 	gl_Position . z = dot4 ( modelPosition , _va_[9 /* rpMVPmatrixZ */] ) ;
 81: 	gl_Position . w = dot4 ( modelPosition , _va_[10 /* rpMVPmatrixW */] ) ;
 82: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 83: 	vec4 toLight = normalize ( vec4 ( 0.0 , 0.5 , 1.0 , 1.0 ) ) ;
 84: 	vofi_TexCoord0 = defaultTexCoord ;
 85: 	vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[1 /* rpBumpMatrixS */] ) ;
 86: 	vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[2 /* rpBumpMatrixT */] ) ;
 87: 	vofi_TexCoord1 = defaultTexCoord ;
 88: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[3 /* rpDiffuseMatrixS */] ) ;
 89: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[4 /* rpDiffuseMatrixT */] ) ;
 90: 	vofi_TexCoord2 = defaultTexCoord ;
 91: 	vofi_TexCoord2 . x = dot4 ( in_TexCoord . xy , _va_[5 /* rpSpecularMatrixS */] ) ;
 92: 	vofi_TexCoord2 . y = dot4 ( in_TexCoord . xy , _va_[6 /* rpSpecularMatrixT */] ) ;
 93: 	vec4 toEye = normalize ( _va_[0 /* rpLocalViewOrigin */] - modelPosition ) ;
 94: 	vofi_TexCoord3 . x = dot3 ( toEye , _va_[11 /* rpModelMatrixX */] ) ;
 95: 	vofi_TexCoord3 . y = dot3 ( toEye , _va_[12 /* rpModelMatrixY */] ) ;
 96: 	vofi_TexCoord3 . z = dot3 ( toEye , _va_[13 /* rpModelMatrixZ */] ) ;
 97: 	vofi_TexCoord4 . x = dot3 ( tangent , _va_[11 /* rpModelMatrixX */] ) ;
 98: 	vofi_TexCoord5 . x = dot3 ( tangent , _va_[12 /* rpModelMatrixY */] ) ;
 99: 	vofi_TexCoord6 . x = dot3 ( tangent , _va_[13 /* rpModelMatrixZ */] ) ;
100: 	vofi_TexCoord4 . y = dot3 ( bitangent , _va_[11 /* rpModelMatrixX */] ) ;
101: 	vofi_TexCoord5 . y = dot3 ( bitangent , _va_[12 /* rpModelMatrixY */] ) ;
102: 	vofi_TexCoord6 . y = dot3 ( bitangent , _va_[13 /* rpModelMatrixZ */] ) ;
103: 	vofi_TexCoord4 . z = dot3 ( normal , _va_[11 /* rpModelMatrixX */] ) ;
104: 	vofi_TexCoord5 . z = dot3 ( normal , _va_[12 /* rpModelMatrixY */] ) ;
105: 	vofi_TexCoord6 . z = dot3 ( normal , _va_[13 /* rpModelMatrixZ */] ) ;
106: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
107: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/ambient_lighting_IBL.ps.hlsl
-----------------
  1: // filename renderprogs/ambient_lighting_IBL.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[4];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec3 Fresnel_SchlickRoughness (vec3 specularColor , float vDotN , float roughness ) {
 53: 	return specularColor + ( max ( vec3 ( 1.0 - roughness ) , specularColor ) - specularColor ) * pow ( 1.0 - vDotN , 5.0 ) ;
 54: }
 55: float ComputeSpecularAO (float vDotN , float ao , float roughness ) {
 56: 	return clamp ( pow ( vDotN + ao , exp2 ( - 16.0 * roughness - 1.0 ) ) - 1.0 + ao , 0.0 , 1.0 ) ;
 57: }
 58: uniform sampler2D samp0;
 59: uniform sampler2D samp1;
 60: uniform sampler2D samp2;
 61: uniform sampler2D samp3;
 62: uniform sampler2D samp4;
 63: uniform sampler2D samp7;
 64: uniform sampler2D samp8;
 65: 
 66: in vec4 vofi_TexCoord0;
 67: in vec4 vofi_TexCoord1;
 68: in vec4 vofi_TexCoord2;
 69: in vec4 vofi_TexCoord3;
 70: in vec4 vofi_TexCoord4;
 71: in vec4 vofi_TexCoord5;
 72: in vec4 vofi_TexCoord6;
 73: in vec4 vofi_Color;
 74: 
 75: out vec4 fo_FragColor;
 76: 
 77: float signNotZeroFloat (float k ) {
 78: 	return ( k >= 0.0 ) ? 1.0 : - 1.0 ;
 79: }
 80: vec2 signNotZero (vec2 v ) {
 81: 	return vec2 ( signNotZeroFloat ( v. x ) , signNotZeroFloat ( v. y ) ) ;
 82: }
 83: vec2 octEncode (vec3 v ) {
 84: 	float l1norm = abs ( v. x ) + abs ( v. y ) + abs ( v. z ) ;
 85: 	vec2 oct = v. xy * ( 1.0 / l1norm ) ;
 86: 	if ( v. z < 0.0 )
 87: 	{
 88: 		oct = ( 1.0 - abs ( oct. yx ) ) * signNotZero ( oct. xy ) ;
 89: 	}
 90: 	return oct ;
 91: }
 92: void main() {
 93: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord0 . xy ) ;
 94: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord1 . xy ) ;
 95: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord2 . xy ) ;
 96: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 97: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 98: 	vec3 localNormal ;
 99: 	localNormal. xy = bumpMap. wy - 0.5 ;
100: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
101: 	localNormal = normalize ( localNormal ) ;
102: 	vec3 globalNormal ;
103: 	globalNormal. x = dot3 ( localNormal , vofi_TexCoord4 ) ;
104: 	globalNormal. y = dot3 ( localNormal , vofi_TexCoord5 ) ;
105: 	globalNormal. z = dot3 ( localNormal , vofi_TexCoord6 ) ;
106: 	globalNormal = normalize ( globalNormal ) ;
107: 	vec3 globalEye = normalize ( vofi_TexCoord3 . xyz ) ;
108: 	vec3 reflectionVector = globalNormal * dot3 ( globalEye , globalNormal ) ;
109: 	reflectionVector = normalize ( ( reflectionVector * 2.0 ) - globalEye ) ;
110: 	float vDotN = saturate ( dot3 ( globalEye , globalNormal ) ) ;
111: 	float metallic = specMapSRGB. g ;
112: 	float roughness = specMapSRGB. r ;
113: 	float glossiness = 1.0 - roughness ;
114: 	vec3 dielectricColor = vec3 ( 0.04 ) ;
115: 	vec3 baseColor = diffuseMap ;
116: 	vec3 diffuseColor = baseColor * ( 1.0 - metallic ) ;
117: 	vec3 specularColor = mix ( dielectricColor , baseColor , metallic ) ;
118: 	vec3 kS = Fresnel_SchlickRoughness ( specularColor , vDotN , roughness ) ;
119: 	vec3 kD = ( vec3 ( 1.0 , 1.0 , 1.0 ) - kS ) * ( 1.0 - metallic ) ;
120: 	vec2 screenTexCoord = gl_FragCoord . xy * _fa_[0 /* rpWindowCoord */] . xy ;
121: 	float ao = texture ( samp4 , screenTexCoord ). r ;
122: 	vec2 normalizedOctCoord = octEncode ( globalNormal ) ;
123: 	vec2 normalizedOctCoordZeroOne = ( normalizedOctCoord + vec2 ( 1.0 ) ) * 0.5 ;
124: 	vec3 irradiance = texture ( samp7 , normalizedOctCoordZeroOne ). rgb ;
125: 	vec3 diffuseLight = ( kD * irradiance * diffuseColor ) * ao * ( _fa_[1 /* rpDiffuseModifier */] . xyz * 1.0 ) ;
126: 	float MAX_REFLECTION_LOD = 10.0 ;
127: 	float mip = clamp ( ( roughness * MAX_REFLECTION_LOD ) , 0.0 , MAX_REFLECTION_LOD ) ;
128: 	normalizedOctCoord = octEncode ( reflectionVector ) ;
129: 	normalizedOctCoordZeroOne = ( normalizedOctCoord + vec2 ( 1.0 ) ) * 0.5 ;
130: 	vec3 radiance = textureLod ( samp8 , normalizedOctCoordZeroOne , mip ). rgb ;
131: 	vec2 envBRDF = texture ( samp3 , vec2 ( max ( vDotN , 0.0 ) , roughness ) ). rg ;
132: 	float specAO = ComputeSpecularAO ( vDotN , ao , roughness ) ;
133: 	vec3 specularLight = radiance * ( kS * envBRDF. x + vec3 ( envBRDF. y ) ) * specAO * ( _fa_[2 /* rpSpecularModifier */] . xyz * 0.5 ) ;
134: 	vec3 lightColor = sRGBToLinearRGB ( _fa_[3 /* rpAmbientColor */] . rgb ) ;
135: 	fo_FragColor . rgb = ( diffuseLight + specularLight ) * lightColor * vofi_Color . rgb ;
136: 	fo_FragColor . w = vofi_Color . a ;
137: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 9 with vertexShader ambient_lighting_IBL and fragmentShader ambient_lighting_IBL
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/gbuffer.vs.hlsl
-----------------
  1: // filename renderprogs/gbuffer.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[11];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec2 vofi_TexCoord0;
 27: out vec3 vofi_TexCoord1;
 28: out vec3 vofi_TexCoord2;
 29: out vec3 vofi_TexCoord3;
 30: out vec3 vofi_TexCoord4;
 31: out vec4 vofi_Color;
 32: 
 33: void main() {
 34: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 35: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 36: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 37: 	vec4 modelPosition = in_Position ;
 38: 	vec3 normal = vNormal. xyz ;
 39: 	vec3 tangent = vTangent. xyz ;
 40: 	vec3 bitangent = vBitangent. xyz ;
 41: 	gl_Position . x = dot4 ( modelPosition , _va_[4 /* rpMVPmatrixX */] ) ;
 42: 	gl_Position . y = dot4 ( modelPosition , _va_[5 /* rpMVPmatrixY */] ) ;
 43: 	gl_Position . z = dot4 ( modelPosition , _va_[6 /* rpMVPmatrixZ */] ) ;
 44: 	gl_Position . w = dot4 ( modelPosition , _va_[7 /* rpMVPmatrixW */] ) ;
 45: 	vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[0 /* rpBumpMatrixS */] ) ;
 46: 	vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[1 /* rpBumpMatrixT */] ) ;
 47: 	vofi_TexCoord2 . x = dot3 ( tangent , _va_[8 /* rpModelViewMatrixX */] ) ;
 48: 	vofi_TexCoord3 . x = dot3 ( tangent , _va_[9 /* rpModelViewMatrixY */] ) ;
 49: 	vofi_TexCoord4 . x = dot3 ( tangent , _va_[10 /* rpModelViewMatrixZ */] ) ;
 50: 	vofi_TexCoord2 . y = dot3 ( bitangent , _va_[8 /* rpModelViewMatrixX */] ) ;
 51: 	vofi_TexCoord3 . y = dot3 ( bitangent , _va_[9 /* rpModelViewMatrixY */] ) ;
 52: 	vofi_TexCoord4 . y = dot3 ( bitangent , _va_[10 /* rpModelViewMatrixZ */] ) ;
 53: 	vofi_TexCoord2 . z = dot3 ( normal , _va_[8 /* rpModelViewMatrixX */] ) ;
 54: 	vofi_TexCoord3 . z = dot3 ( normal , _va_[9 /* rpModelViewMatrixY */] ) ;
 55: 	vofi_TexCoord4 . z = dot3 ( normal , _va_[10 /* rpModelViewMatrixZ */] ) ;
 56: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[2 /* rpVertexColorModulate */] ) + _va_[3 /* rpVertexColorAdd */] ;
 57: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/gbuffer.ps.hlsl
-----------------
  1: // filename renderprogs/gbuffer.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 17: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 18: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 19: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 20: uniform sampler2D samp0;
 21: 
 22: in vec2 vofi_TexCoord0;
 23: in vec3 vofi_TexCoord1;
 24: in vec3 vofi_TexCoord2;
 25: in vec3 vofi_TexCoord3;
 26: in vec3 vofi_TexCoord4;
 27: in vec4 vofi_Color;
 28: 
 29: out vec4 fo_FragColor;
 30: 
 31: void main() {
 32: 	vec4 bump = texture ( samp0 , vofi_TexCoord0 ) * 2.0 - 1.0 ;
 33: 	vec3 localNormal ;
 34: 	localNormal = vec3 ( bump. wy , 0.0 ) ;
 35: 	localNormal. z = sqrt ( 1.0 - dot3 ( localNormal , localNormal ) ) ;
 36: 	vec3 globalNormal ;
 37: 	globalNormal. x = dot3 ( localNormal , vofi_TexCoord2 ) ;
 38: 	globalNormal. y = dot3 ( localNormal , vofi_TexCoord3 ) ;
 39: 	globalNormal. z = dot3 ( localNormal , vofi_TexCoord4 ) ;
 40: 	fo_FragColor . rgb = ( globalNormal. xyz * 0.5 + 0.5 ) * vofi_Color . rgb ;
 41: 	fo_FragColor . a = 1.0 ;
 42: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 10 with vertexShader gbuffer and fragmentShader gbuffer
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/gbuffer.vs.hlsl
-----------------
  1: // filename renderprogs/gbuffer.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[9];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec2 vofi_TexCoord0;
 25: out vec3 vofi_TexCoord1;
 26: out vec3 vofi_TexCoord2;
 27: out vec3 vofi_TexCoord3;
 28: out vec3 vofi_TexCoord4;
 29: out vec4 vofi_Color;
 30: 
 31: void main() {
 32: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 33: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 34: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 35: 	float w0 = in_Color2 . x ;
 36: 	float w1 = in_Color2 . y ;
 37: 	float w2 = in_Color2 . z ;
 38: 	float w3 = in_Color2 . w ;
 39: 	vec4 matX , matY , matZ ;
 40: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 41: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 42: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 43: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 44: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 45: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 46: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 47: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 48: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 49: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 50: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 51: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 52: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 53: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 54: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 55: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 56: 	vec3 normal ;
 57: 	normal. x = dot3 ( matX , vNormal ) ;
 58: 	normal. y = dot3 ( matY , vNormal ) ;
 59: 	normal. z = dot3 ( matZ , vNormal ) ;
 60: 	normal = normalize ( normal ) ;
 61: 	vec3 tangent ;
 62: 	tangent. x = dot3 ( matX , vTangent ) ;
 63: 	tangent. y = dot3 ( matY , vTangent ) ;
 64: 	tangent. z = dot3 ( matZ , vTangent ) ;
 65: 	tangent = normalize ( tangent ) ;
 66: 	vec3 bitangent ;
 67: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 68: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 69: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 70: 	bitangent = normalize ( bitangent ) ;
 71: 	vec4 modelPosition ;
 72: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 73: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 74: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 75: 	modelPosition. w = 1.0 ;
 76: 	gl_Position . x = dot4 ( modelPosition , _va_[2 /* rpMVPmatrixX */] ) ;
 77: 	gl_Position . y = dot4 ( modelPosition , _va_[3 /* rpMVPmatrixY */] ) ;
 78: 	gl_Position . z = dot4 ( modelPosition , _va_[4 /* rpMVPmatrixZ */] ) ;
 79: 	gl_Position . w = dot4 ( modelPosition , _va_[5 /* rpMVPmatrixW */] ) ;
 80: 	vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[0 /* rpBumpMatrixS */] ) ;
 81: 	vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[1 /* rpBumpMatrixT */] ) ;
 82: 	vofi_TexCoord2 . x = dot3 ( tangent , _va_[6 /* rpModelViewMatrixX */] ) ;
 83: 	vofi_TexCoord3 . x = dot3 ( tangent , _va_[7 /* rpModelViewMatrixY */] ) ;
 84: 	vofi_TexCoord4 . x = dot3 ( tangent , _va_[8 /* rpModelViewMatrixZ */] ) ;
 85: 	vofi_TexCoord2 . y = dot3 ( bitangent , _va_[6 /* rpModelViewMatrixX */] ) ;
 86: 	vofi_TexCoord3 . y = dot3 ( bitangent , _va_[7 /* rpModelViewMatrixY */] ) ;
 87: 	vofi_TexCoord4 . y = dot3 ( bitangent , _va_[8 /* rpModelViewMatrixZ */] ) ;
 88: 	vofi_TexCoord2 . z = dot3 ( normal , _va_[6 /* rpModelViewMatrixX */] ) ;
 89: 	vofi_TexCoord3 . z = dot3 ( normal , _va_[7 /* rpModelViewMatrixY */] ) ;
 90: 	vofi_TexCoord4 . z = dot3 ( normal , _va_[8 /* rpModelViewMatrixZ */] ) ;
 91: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
 92: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/gbuffer.ps.hlsl
-----------------
  1: // filename renderprogs/gbuffer.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 17: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 18: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 19: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 20: uniform sampler2D samp0;
 21: 
 22: in vec2 vofi_TexCoord0;
 23: in vec3 vofi_TexCoord1;
 24: in vec3 vofi_TexCoord2;
 25: in vec3 vofi_TexCoord3;
 26: in vec3 vofi_TexCoord4;
 27: in vec4 vofi_Color;
 28: 
 29: out vec4 fo_FragColor;
 30: 
 31: void main() {
 32: 	vec4 bump = texture ( samp0 , vofi_TexCoord0 ) * 2.0 - 1.0 ;
 33: 	vec3 localNormal ;
 34: 	localNormal = vec3 ( bump. wy , 0.0 ) ;
 35: 	localNormal. z = sqrt ( 1.0 - dot3 ( localNormal , localNormal ) ) ;
 36: 	vec3 globalNormal ;
 37: 	globalNormal. x = dot3 ( localNormal , vofi_TexCoord2 ) ;
 38: 	globalNormal. y = dot3 ( localNormal , vofi_TexCoord3 ) ;
 39: 	globalNormal. z = dot3 ( localNormal , vofi_TexCoord4 ) ;
 40: 	fo_FragColor . rgb = ( globalNormal. xyz * 0.5 + 0.5 ) * vofi_Color . rgb ;
 41: 	fo_FragColor . a = 1.0 ;
 42: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 11 with vertexShader gbuffer and fragmentShader gbuffer
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/texture.vs.hlsl
-----------------
  1: // filename renderprogs/texture.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[9];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: in vec2 in_TexCoord;
 14: in vec4 in_Normal;
 15: in vec4 in_Tangent;
 16: in vec4 in_Color;
 17: 
 18: out vec2 vofi_TexCoord0;
 19: 
 20: void main() {
 21: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 22: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 23: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 24: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ; if ( _va_[8 /* rpTexGen0Enabled */] . x > 0.0 )
 25: 	{
 26: 		vofi_TexCoord0 . x = dot4 ( in_Position , _va_[6 /* rpTexGen0S */] ) ;
 27: 		vofi_TexCoord0 . y = dot4 ( in_Position , _va_[7 /* rpTexGen0T */] ) ;
 28: 	}
 29: 	else
 30: 	{
 31: 		vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[4 /* rpTextureMatrixS */] ) ;
 32: 		vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[5 /* rpTextureMatrixT */] ) ;
 33: 	}
 34: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/texture.ps.hlsl
-----------------
  1: // filename renderprogs/texture.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: uniform sampler2D samp0;
 20: 
 21: in vec2 vofi_TexCoord0;
 22: 
 23: out vec4 fo_FragColor;
 24: 
 25: void main() {
 26: 	fo_FragColor = texture ( samp0 , vofi_TexCoord0 ) * _fa_[0 /* rpColor */] ;
 27: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 12 with vertexShader texture and fragmentShader texture
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/texture_color.vs.hlsl
-----------------
  1: // filename renderprogs/texture_color.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[12];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: vec4 swizzleColor (vec4 c ) {
 12: 	return c ;
 13: }
 14: 
 15: in vec4 in_Position;
 16: in vec2 in_TexCoord;
 17: in vec4 in_Normal;
 18: in vec4 in_Tangent;
 19: in vec4 in_Color;
 20: 
 21: out vec2 vofi_TexCoord0;
 22: out vec4 vofi_Color;
 23: 
 24: void main() {
 25: 	gl_Position . x = dot4 ( in_Position , _va_[3 /* rpMVPmatrixX */] ) ;
 26: 	gl_Position . y = dot4 ( in_Position , _va_[4 /* rpMVPmatrixY */] ) ;
 27: 	gl_Position . z = dot4 ( in_Position , _va_[5 /* rpMVPmatrixZ */] ) ;
 28: 	gl_Position . w = dot4 ( in_Position , _va_[6 /* rpMVPmatrixW */] ) ; if ( _va_[11 /* rpTexGen0Enabled */] . x > 0.0 )
 29: 	{
 30: 		vofi_TexCoord0 . x = dot4 ( in_Position , _va_[9 /* rpTexGen0S */] ) ;
 31: 		vofi_TexCoord0 . y = dot4 ( in_Position , _va_[10 /* rpTexGen0T */] ) ;
 32: 	}
 33: 	else
 34: 	{
 35: 		vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[7 /* rpTextureMatrixS */] ) ;
 36: 		vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[8 /* rpTextureMatrixT */] ) ;
 37: 	}
 38: 	vec4 vertexColor = ( swizzleColor ( in_Color ) * _va_[0 /* rpVertexColorModulate */] ) + _va_[1 /* rpVertexColorAdd */] ;
 39: 	vofi_Color = vertexColor * _va_[2 /* rpColor */] ;
 40: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/texture_color.ps.hlsl
-----------------
  1: // filename renderprogs/texture_color.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: float Linear1 (float c ) {
 20: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 21: }
 22: vec4 sRGBAToLinearRGBA (vec4 c ) {
 23: 	c = clamp ( c , 0.0 , 1.0 ) ;
 24: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 25: }
 26: uniform sampler2D samp0;
 27: 
 28: in vec2 vofi_TexCoord0;
 29: in vec4 vofi_Color;
 30: 
 31: out vec4 fo_FragColor;
 32: 
 33: void main() {
 34: 	vec4 color = texture ( samp0 , vofi_TexCoord0 ) * vofi_Color ;
 35: 	clip ( color. a - _fa_[0 /* rpAlphaTest */] . x ) ;
 36: 	fo_FragColor = sRGBAToLinearRGBA ( color ) ;
 37: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 13 with vertexShader texture_color and fragmentShader texture_color
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/texture_color.vs.hlsl
-----------------
  1: // filename renderprogs/texture_color.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[12];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: vec4 swizzleColor (vec4 c ) {
 12: 	return c ;
 13: }
 14: 
 15: in vec4 in_Position;
 16: in vec2 in_TexCoord;
 17: in vec4 in_Normal;
 18: in vec4 in_Tangent;
 19: in vec4 in_Color;
 20: 
 21: out vec2 vofi_TexCoord0;
 22: out vec4 vofi_Color;
 23: 
 24: void main() {
 25: 	gl_Position . x = dot4 ( in_Position , _va_[3 /* rpMVPmatrixX */] ) ;
 26: 	gl_Position . y = dot4 ( in_Position , _va_[4 /* rpMVPmatrixY */] ) ;
 27: 	gl_Position . z = dot4 ( in_Position , _va_[5 /* rpMVPmatrixZ */] ) ;
 28: 	gl_Position . w = dot4 ( in_Position , _va_[6 /* rpMVPmatrixW */] ) ; if ( _va_[11 /* rpTexGen0Enabled */] . x > 0.0 )
 29: 	{
 30: 		vofi_TexCoord0 . x = dot4 ( in_Position , _va_[9 /* rpTexGen0S */] ) ;
 31: 		vofi_TexCoord0 . y = dot4 ( in_Position , _va_[10 /* rpTexGen0T */] ) ;
 32: 	}
 33: 	else
 34: 	{
 35: 		vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[7 /* rpTextureMatrixS */] ) ;
 36: 		vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[8 /* rpTextureMatrixT */] ) ;
 37: 	}
 38: 	vec4 vertexColor = ( swizzleColor ( in_Color ) * _va_[0 /* rpVertexColorModulate */] ) + _va_[1 /* rpVertexColorAdd */] ;
 39: 	vofi_Color = vertexColor * _va_[2 /* rpColor */] ;
 40: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/texture_color.ps.hlsl
-----------------
  1: // filename renderprogs/texture_color.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: vec4 sRGBAToLinearRGBA (vec4 c ) {
 20: 	return c ;
 21: }
 22: uniform sampler2D samp0;
 23: 
 24: in vec2 vofi_TexCoord0;
 25: in vec4 vofi_Color;
 26: 
 27: out vec4 fo_FragColor;
 28: 
 29: void main() {
 30: 	vec4 color = texture ( samp0 , vofi_TexCoord0 ) * vofi_Color ;
 31: 	clip ( color. a - _fa_[0 /* rpAlphaTest */] . x ) ;
 32: 	fo_FragColor = sRGBAToLinearRGBA ( color ) ;
 33: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 14 with vertexShader texture_color and fragmentShader texture_color
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/texture_color_skinned.vs.hlsl
-----------------
  1: // filename renderprogs/texture_color_skinned.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[12];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: vec4 swizzleColor (vec4 c ) {
 12: 	return c ;
 13: }
 14: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 15: 
 16: in vec4 in_Position;
 17: in vec2 in_TexCoord;
 18: in vec4 in_Normal;
 19: in vec4 in_Tangent;
 20: in vec4 in_Color;
 21: in vec4 in_Color2;
 22: 
 23: out vec2 vofi_TexCoord0;
 24: out vec4 vofi_Color;
 25: 
 26: void main() {
 27: 	float w0 = in_Color2 . x ;
 28: 	float w1 = in_Color2 . y ;
 29: 	float w2 = in_Color2 . z ;
 30: 	float w3 = in_Color2 . w ;
 31: 	vec4 matX , matY , matZ ;
 32: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 33: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 34: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 35: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 36: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 37: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 38: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 39: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 40: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 41: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 42: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 43: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 44: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 45: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 46: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 47: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 48: 	vec4 modelPosition ;
 49: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 50: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 51: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 52: 	modelPosition. w = 1.0 ;
 53: 	gl_Position . x = dot4 ( modelPosition , _va_[3 /* rpMVPmatrixX */] ) ;
 54: 	gl_Position . y = dot4 ( modelPosition , _va_[4 /* rpMVPmatrixY */] ) ;
 55: 	gl_Position . z = dot4 ( modelPosition , _va_[5 /* rpMVPmatrixZ */] ) ;
 56: 	gl_Position . w = dot4 ( modelPosition , _va_[6 /* rpMVPmatrixW */] ) ; if ( _va_[11 /* rpTexGen0Enabled */] . x > 0.0 )
 57: 	{
 58: 		vofi_TexCoord0 . x = dot4 ( modelPosition , _va_[9 /* rpTexGen0S */] ) ;
 59: 		vofi_TexCoord0 . y = dot4 ( modelPosition , _va_[10 /* rpTexGen0T */] ) ;
 60: 	}
 61: 	else
 62: 	{
 63: 		vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[7 /* rpTextureMatrixS */] ) ;
 64: 		vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[8 /* rpTextureMatrixT */] ) ;
 65: 	}
 66: 	vec4 vertexColor = ( swizzleColor ( in_Color ) * _va_[0 /* rpVertexColorModulate */] ) + _va_[1 /* rpVertexColorAdd */] ;
 67: 	vofi_Color = vertexColor * _va_[2 /* rpColor */] ;
 68: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/texture_color_skinned.ps.hlsl
-----------------
  1: // filename renderprogs/texture_color_skinned.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: float Linear1 (float c ) {
 20: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 21: }
 22: vec4 sRGBAToLinearRGBA (vec4 c ) {
 23: 	c = clamp ( c , 0.0 , 1.0 ) ;
 24: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 25: }
 26: uniform sampler2D samp0;
 27: 
 28: in vec2 vofi_TexCoord0;
 29: in vec4 vofi_Color;
 30: 
 31: out vec4 fo_FragColor;
 32: 
 33: void main() {
 34: 	vec4 color = texture ( samp0 , vofi_TexCoord0 ) * vofi_Color ;
 35: 	clip ( color. a - _fa_[0 /* rpAlphaTest */] . x ) ;
 36: 	fo_FragColor = sRGBAToLinearRGBA ( color ) ;
 37: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 15 with vertexShader texture_color_skinned and fragmentShader texture_color_skinned
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/texture_color_texgen.vs.hlsl
-----------------
  1: // filename renderprogs/texture_color_texgen.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[12];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: vec4 swizzleColor (vec4 c ) {
 12: 	return c ;
 13: }
 14: 
 15: in vec4 in_Position;
 16: in vec2 in_TexCoord;
 17: in vec4 in_Normal;
 18: in vec4 in_Tangent;
 19: in vec4 in_Color;
 20: 
 21: out vec4 vofi_TexCoord0;
 22: out vec4 vofi_Color;
 23: 
 24: void main() {
 25: 	gl_Position . x = dot4 ( in_Position , _va_[3 /* rpMVPmatrixX */] ) ;
 26: 	gl_Position . y = dot4 ( in_Position , _va_[4 /* rpMVPmatrixY */] ) ;
 27: 	gl_Position . z = dot4 ( in_Position , _va_[5 /* rpMVPmatrixZ */] ) ;
 28: 	gl_Position . w = dot4 ( in_Position , _va_[6 /* rpMVPmatrixW */] ) ;
 29: 	vec4 tc0 ;
 30: 	tc0. x = dot4 ( in_Position , _va_[9 /* rpTexGen0S */] ) ;
 31: 	tc0. y = dot4 ( in_Position , _va_[10 /* rpTexGen0T */] ) ;
 32: 	tc0. z = 0.0 ;
 33: 	tc0. w = dot4 ( in_Position , _va_[11 /* rpTexGen0Q */] ) ;
 34: 	vofi_TexCoord0 . x = dot4 ( tc0 , _va_[7 /* rpTextureMatrixS */] ) ;
 35: 	vofi_TexCoord0 . y = dot4 ( tc0 , _va_[8 /* rpTextureMatrixT */] ) ;
 36: 	vofi_TexCoord0 . zw = tc0. zw ;
 37: 	vec4 vertexColor = ( swizzleColor ( in_Color ) * _va_[0 /* rpVertexColorModulate */] ) + _va_[1 /* rpVertexColorAdd */] ;
 38: 	vofi_Color = vertexColor * _va_[2 /* rpColor */] ;
 39: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/texture_color_texgen.ps.hlsl
-----------------
  1: // filename renderprogs/texture_color_texgen.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: float Linear1 (float c ) {
 17: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 18: }
 19: vec4 sRGBAToLinearRGBA (vec4 c ) {
 20: 	c = clamp ( c , 0.0 , 1.0 ) ;
 21: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 22: }
 23: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 24: 	return textureProj ( samp , texCoords. xyw ) ;
 25: }
 26: uniform sampler2D samp0;
 27: 
 28: in vec4 vofi_TexCoord0;
 29: in vec4 vofi_Color;
 30: 
 31: out vec4 fo_FragColor;
 32: 
 33: void main() {
 34: 	vec4 texSample = idtex2Dproj ( samp0 , vofi_TexCoord0 ) ;
 35: 	fo_FragColor = sRGBAToLinearRGBA ( texSample ) * vofi_Color ;
 36: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 16 with vertexShader texture_color_texgen and fragmentShader texture_color_texgen
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interaction.vs.hlsl
-----------------
  1: // filename renderprogs/interaction.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[18];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_Color;
 34: 
 35: void main() {
 36: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 37: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 38: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 39: 	vec4 modelPosition = in_Position ;
 40: 	vec3 normal = vNormal. xyz ;
 41: 	vec3 tangent = vTangent. xyz ;
 42: 	vec3 bitangent = vBitangent. xyz ;
 43: 	gl_Position . x = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixX */] ) ;
 44: 	gl_Position . y = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixY */] ) ;
 45: 	gl_Position . z = dot4 ( modelPosition , _va_[16 /* rpMVPmatrixZ */] ) ;
 46: 	gl_Position . w = dot4 ( modelPosition , _va_[17 /* rpMVPmatrixW */] ) ;
 47: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 48: 	vec4 toLight = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 49: 	vofi_TexCoord0 . x = dot3 ( tangent , toLight ) ;
 50: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLight ) ;
 51: 	vofi_TexCoord0 . z = dot3 ( normal , toLight ) ;
 52: 	vofi_TexCoord0 . w = 1.0 ;
 53: 	vofi_TexCoord1 = defaultTexCoord ;
 54: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 55: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 56: 	vofi_TexCoord2 = defaultTexCoord ;
 57: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 58: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 59: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 60: 	vofi_TexCoord3 . z = 0.0 ;
 61: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 62: 	vofi_TexCoord4 = defaultTexCoord ;
 63: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 64: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 65: 	vofi_TexCoord5 = defaultTexCoord ;
 66: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
 67: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
 68: 	toLight = normalize ( toLight ) ;
 69: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
 70: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
 71: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
 72: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
 73: 	vofi_TexCoord6 . w = 1.0 ;
 74: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
 75: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interaction.ps.hlsl
-----------------
  1: // filename renderprogs/interaction.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[2];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 53: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 54: 	return textureProj ( samp , texCoords. xyw ) ;
 55: }
 56: uniform sampler2D samp0;
 57: uniform sampler2D samp1;
 58: uniform sampler2D samp2;
 59: uniform sampler2D samp3;
 60: uniform sampler2D samp4;
 61: 
 62: in vec4 vofi_TexCoord0;
 63: in vec4 vofi_TexCoord1;
 64: in vec4 vofi_TexCoord2;
 65: in vec4 vofi_TexCoord3;
 66: in vec4 vofi_TexCoord4;
 67: in vec4 vofi_TexCoord5;
 68: in vec4 vofi_TexCoord6;
 69: in vec4 vofi_Color;
 70: 
 71: out vec4 fo_FragColor;
 72: 
 73: void main() {
 74: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 75: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 76: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 77: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 78: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 79: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 80: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
 81: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
 82: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 83: 	vec3 localNormal ;
 84: 	localNormal. xy = bumpMap. wy - 0.5 ;
 85: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
 86: 	localNormal = normalize ( localNormal ) ;
 87: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
 88: 	float lambert = ldotN ;
 89: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
 90: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
 91: 	float Y = dot ( LUMINANCE_SRGB. rgb , specMapSRGB. rgb ) ;
 92: 	float glossiness = clamp ( pow ( Y , 1.0 / 2.0 ) , 0.0 , 0.98 ) ;
 93: 	float roughness = 1.0 - glossiness ;
 94: 	vec3 diffuseColor = diffuseMap ;
 95: 	vec3 specularColor = specMapSRGB. rgb ;
 96: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
 97: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
 98: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
 99: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
100: 	vec3 reflectColor = specularColor * _fa_[1 /* rpSpecularModifier */] . rgb * 1.0 ;
101: 	float rr = roughness * roughness ;
102: 	float rrrr = rr * rr ;
103: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
104: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
105: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
106: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[0 /* rpDiffuseModifier */] . xyz ) ;
107: 	fo_FragColor . xyz = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb ;
108: 	fo_FragColor . w = 1.0 ;
109: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 17 with vertexShader interaction and fragmentShader interaction
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interaction.vs.hlsl
-----------------
  1: // filename renderprogs/interaction.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[16];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_Color;
 32: 
 33: void main() {
 34: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 35: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 36: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 37: 	float w0 = in_Color2 . x ;
 38: 	float w1 = in_Color2 . y ;
 39: 	float w2 = in_Color2 . z ;
 40: 	float w3 = in_Color2 . w ;
 41: 	vec4 matX , matY , matZ ;
 42: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 43: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 44: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 45: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 46: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 47: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 48: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 49: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 50: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 51: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 52: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 53: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 54: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 55: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 56: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 57: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 58: 	vec3 normal ;
 59: 	normal. x = dot3 ( matX , vNormal ) ;
 60: 	normal. y = dot3 ( matY , vNormal ) ;
 61: 	normal. z = dot3 ( matZ , vNormal ) ;
 62: 	normal = normalize ( normal ) ;
 63: 	vec3 tangent ;
 64: 	tangent. x = dot3 ( matX , vTangent ) ;
 65: 	tangent. y = dot3 ( matY , vTangent ) ;
 66: 	tangent. z = dot3 ( matZ , vTangent ) ;
 67: 	tangent = normalize ( tangent ) ;
 68: 	vec3 bitangent ;
 69: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 70: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 71: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 72: 	bitangent = normalize ( bitangent ) ;
 73: 	vec4 modelPosition ;
 74: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 75: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 76: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 77: 	modelPosition. w = 1.0 ;
 78: 	gl_Position . x = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixX */] ) ;
 79: 	gl_Position . y = dot4 ( modelPosition , _va_[13 /* rpMVPmatrixY */] ) ;
 80: 	gl_Position . z = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixZ */] ) ;
 81: 	gl_Position . w = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixW */] ) ;
 82: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 83: 	vec4 toLight = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 84: 	vofi_TexCoord0 . x = dot3 ( tangent , toLight ) ;
 85: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLight ) ;
 86: 	vofi_TexCoord0 . z = dot3 ( normal , toLight ) ;
 87: 	vofi_TexCoord0 . w = 1.0 ;
 88: 	vofi_TexCoord1 = defaultTexCoord ;
 89: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 90: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 91: 	vofi_TexCoord2 = defaultTexCoord ;
 92: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 93: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 94: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 95: 	vofi_TexCoord3 . z = 0.0 ;
 96: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 97: 	vofi_TexCoord4 = defaultTexCoord ;
 98: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 99: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
100: 	vofi_TexCoord5 = defaultTexCoord ;
101: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
102: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
103: 	toLight = normalize ( toLight ) ;
104: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
105: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
106: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
107: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
108: 	vofi_TexCoord6 . w = 1.0 ;
109: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
110: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interaction.ps.hlsl
-----------------
  1: // filename renderprogs/interaction.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[2];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 53: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 54: 	return textureProj ( samp , texCoords. xyw ) ;
 55: }
 56: uniform sampler2D samp0;
 57: uniform sampler2D samp1;
 58: uniform sampler2D samp2;
 59: uniform sampler2D samp3;
 60: uniform sampler2D samp4;
 61: 
 62: in vec4 vofi_TexCoord0;
 63: in vec4 vofi_TexCoord1;
 64: in vec4 vofi_TexCoord2;
 65: in vec4 vofi_TexCoord3;
 66: in vec4 vofi_TexCoord4;
 67: in vec4 vofi_TexCoord5;
 68: in vec4 vofi_TexCoord6;
 69: in vec4 vofi_Color;
 70: 
 71: out vec4 fo_FragColor;
 72: 
 73: void main() {
 74: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 75: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 76: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 77: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 78: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 79: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 80: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
 81: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
 82: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 83: 	vec3 localNormal ;
 84: 	localNormal. xy = bumpMap. wy - 0.5 ;
 85: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
 86: 	localNormal = normalize ( localNormal ) ;
 87: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
 88: 	float lambert = ldotN ;
 89: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
 90: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
 91: 	float Y = dot ( LUMINANCE_SRGB. rgb , specMapSRGB. rgb ) ;
 92: 	float glossiness = clamp ( pow ( Y , 1.0 / 2.0 ) , 0.0 , 0.98 ) ;
 93: 	float roughness = 1.0 - glossiness ;
 94: 	vec3 diffuseColor = diffuseMap ;
 95: 	vec3 specularColor = specMapSRGB. rgb ;
 96: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
 97: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
 98: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
 99: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
100: 	vec3 reflectColor = specularColor * _fa_[1 /* rpSpecularModifier */] . rgb * 1.0 ;
101: 	float rr = roughness * roughness ;
102: 	float rrrr = rr * rr ;
103: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
104: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
105: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
106: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[0 /* rpDiffuseModifier */] . xyz ) ;
107: 	fo_FragColor . xyz = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb ;
108: 	fo_FragColor . w = 1.0 ;
109: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 18 with vertexShader interaction and fragmentShader interaction
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionAmbient.vs.hlsl
-----------------
  1: // filename renderprogs/interactionAmbient.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[18];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: 
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_Color;
 32: 
 33: void main() {
 34: 	vec4 normal = in_Normal * 2.0 - 1.0 ;
 35: 	vec4 tangent = in_Tangent * 2.0 - 1.0 ;
 36: 	vec3 binormal = cross ( normal. xyz , tangent. xyz ) * tangent. w ;
 37: 	gl_Position . x = dot4 ( in_Position , _va_[14 /* rpMVPmatrixX */] ) ;
 38: 	gl_Position . y = dot4 ( in_Position , _va_[15 /* rpMVPmatrixY */] ) ;
 39: 	gl_Position . z = dot4 ( in_Position , _va_[16 /* rpMVPmatrixZ */] ) ;
 40: 	gl_Position . w = dot4 ( in_Position , _va_[17 /* rpMVPmatrixW */] ) ;
 41: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 42: 	vec4 toLight = _va_[0 /* rpLocalLightOrigin */] - in_Position ;
 43: 	vofi_TexCoord1 = defaultTexCoord ;
 44: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 45: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 46: 	vofi_TexCoord2 = defaultTexCoord ;
 47: 	vofi_TexCoord2 . x = dot4 ( in_Position , _va_[5 /* rpLightFalloffS */] ) ;
 48: 	vofi_TexCoord3 . x = dot4 ( in_Position , _va_[2 /* rpLightProjectionS */] ) ;
 49: 	vofi_TexCoord3 . y = dot4 ( in_Position , _va_[3 /* rpLightProjectionT */] ) ;
 50: 	vofi_TexCoord3 . z = 0.0 ;
 51: 	vofi_TexCoord3 . w = dot4 ( in_Position , _va_[4 /* rpLightProjectionQ */] ) ;
 52: 	vofi_TexCoord4 = defaultTexCoord ;
 53: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 54: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 55: 	vofi_TexCoord5 = defaultTexCoord ;
 56: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
 57: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
 58: 	toLight = normalize ( toLight ) ;
 59: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - in_Position ) ;
 60: 	vec4 halfAngleVector = toLight + toView ;
 61: 	vofi_TexCoord6 . x = dot3 ( tangent , halfAngleVector ) ;
 62: 	vofi_TexCoord6 . y = dot3 ( binormal , halfAngleVector ) ;
 63: 	vofi_TexCoord6 . z = dot3 ( normal , halfAngleVector ) ;
 64: 	vofi_TexCoord6 . w = 1.0 ;
 65: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
 66: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionAmbient.ps.hlsl
-----------------
  1: // filename renderprogs/interactionAmbient.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[2];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: uniform sampler2D samp0;
 56: uniform sampler2D samp1;
 57: uniform sampler2D samp2;
 58: uniform sampler2D samp3;
 59: uniform sampler2D samp4;
 60: 
 61: in vec4 vofi_TexCoord1;
 62: in vec4 vofi_TexCoord2;
 63: in vec4 vofi_TexCoord3;
 64: in vec4 vofi_TexCoord4;
 65: in vec4 vofi_TexCoord5;
 66: in vec4 vofi_TexCoord6;
 67: in vec4 vofi_Color;
 68: 
 69: out vec4 fo_FragColor;
 70: 
 71: void main() {
 72: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 73: 	vec4 lightFalloff = idtex2Dproj ( samp3 , vofi_TexCoord2 ) ;
 74: 	vec4 lightProj = idtex2Dproj ( samp4 , vofi_TexCoord3 ) ;
 75: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 76: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 77: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 78: 	vec3 ambientLightVector = vec3 ( 0.5 , 9.5 - 0.385 , 0.8925 ) ;
 79: 	vec3 lightVector = normalize ( ambientLightVector ) ;
 80: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 81: 	vec3 localNormal ;
 82: 	localNormal. xy = bumpMap. wy - 0.5 ;
 83: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
 84: 	localNormal = normalize ( localNormal ) ;
 85: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
 86: 	float lambert = ldotN ;
 87: 	float specularPower = 10.0 ;
 88: 	float hDotN = dot3 ( normalize ( vofi_TexCoord6 . xyz ) , localNormal ) ;
 89: 	vec3 specularContribution = vec3 ( pow ( abs ( hDotN ) , specularPower ) ) ;
 90: 	vec3 diffuseColor = diffuseMap * ( _fa_[0 /* rpDiffuseModifier */] . xyz ) ;
 91: 	vec3 specularColor = specMap. xyz * specularContribution * ( _fa_[1 /* rpSpecularModifier */] . xyz ) ;
 92: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
 93: 	fo_FragColor . xyz = ( diffuseColor + specularColor ) * lightColor * vofi_Color . xyz ;
 94: 	fo_FragColor . w = 1.0 ;
 95: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 19 with vertexShader interactionAmbient and fragmentShader interactionAmbient
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionAmbient_skinned.vs.hlsl
-----------------
  1: // filename renderprogs/interactionAmbient_skinned.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[18];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 19: 
 20: in vec4 in_Position;
 21: in vec2 in_TexCoord;
 22: in vec4 in_Normal;
 23: in vec4 in_Tangent;
 24: in vec4 in_Color;
 25: in vec4 in_Color2;
 26: 
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_Color;
 34: 
 35: void main() {
 36: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 37: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 38: 	vec3 vBinormal = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 39: 	float w0 = in_Color2 . x ;
 40: 	float w1 = in_Color2 . y ;
 41: 	float w2 = in_Color2 . z ;
 42: 	float w3 = in_Color2 . w ;
 43: 	vec4 matX , matY , matZ ;
 44: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 45: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 46: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 47: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 48: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 49: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 50: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 51: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 52: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 53: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 54: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 55: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 56: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 57: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 58: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 59: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 60: 	vec3 normal ;
 61: 	normal. x = dot3 ( matX , vNormal ) ;
 62: 	normal. y = dot3 ( matY , vNormal ) ;
 63: 	normal. z = dot3 ( matZ , vNormal ) ;
 64: 	normal = normalize ( normal ) ;
 65: 	vec3 tangent ;
 66: 	tangent. x = dot3 ( matX , vTangent ) ;
 67: 	tangent. y = dot3 ( matY , vTangent ) ;
 68: 	tangent. z = dot3 ( matZ , vTangent ) ;
 69: 	tangent = normalize ( tangent ) ;
 70: 	vec3 binormal ;
 71: 	binormal. x = dot3 ( matX , vBinormal ) ;
 72: 	binormal. y = dot3 ( matY , vBinormal ) ;
 73: 	binormal. z = dot3 ( matZ , vBinormal ) ;
 74: 	binormal = normalize ( binormal ) ;
 75: 	vec4 modelPosition ;
 76: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 77: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 78: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 79: 	modelPosition. w = 1.0 ;
 80: 	gl_Position . x = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixX */] ) ;
 81: 	gl_Position . y = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixY */] ) ;
 82: 	gl_Position . z = dot4 ( modelPosition , _va_[16 /* rpMVPmatrixZ */] ) ;
 83: 	gl_Position . w = dot4 ( modelPosition , _va_[17 /* rpMVPmatrixW */] ) ;
 84: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 85: 	vec4 toLight = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 86: 	vofi_TexCoord1 = defaultTexCoord ;
 87: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 88: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 89: 	vofi_TexCoord2 = defaultTexCoord ;
 90: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 91: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 92: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 93: 	vofi_TexCoord3 . z = 0.0 ;
 94: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 95: 	vofi_TexCoord4 = defaultTexCoord ;
 96: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 97: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 98: 	vofi_TexCoord5 = defaultTexCoord ;
 99: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
100: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
101: 	toLight = normalize ( toLight ) ;
102: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
103: 	vec4 halfAngleVector = toLight + toView ;
104: 	vofi_TexCoord6 . x = dot3 ( tangent , halfAngleVector ) ;
105: 	vofi_TexCoord6 . y = dot3 ( binormal , halfAngleVector ) ;
106: 	vofi_TexCoord6 . z = dot3 ( normal , halfAngleVector ) ;
107: 	vofi_TexCoord6 . w = 1.0 ;
108: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
109: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionAmbient_skinned.ps.hlsl
-----------------
  1: // filename renderprogs/interactionAmbient_skinned.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[2];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: uniform sampler2D samp0;
 56: uniform sampler2D samp1;
 57: uniform sampler2D samp2;
 58: uniform sampler2D samp3;
 59: uniform sampler2D samp4;
 60: 
 61: in vec4 vofi_TexCoord1;
 62: in vec4 vofi_TexCoord2;
 63: in vec4 vofi_TexCoord3;
 64: in vec4 vofi_TexCoord4;
 65: in vec4 vofi_TexCoord5;
 66: in vec4 vofi_TexCoord6;
 67: in vec4 vofi_Color;
 68: 
 69: out vec4 fo_FragColor;
 70: 
 71: void main() {
 72: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 73: 	vec4 lightFalloff = idtex2Dproj ( samp3 , vofi_TexCoord2 ) ;
 74: 	vec4 lightProj = idtex2Dproj ( samp4 , vofi_TexCoord3 ) ;
 75: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 76: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 77: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 78: 	vec3 ambientLightVector = vec3 ( 0.5 , 9.5 - 0.385 , 0.8925 ) ;
 79: 	vec3 lightVector = normalize ( ambientLightVector ) ;
 80: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 81: 	vec3 localNormal ;
 82: 	localNormal. xy = bumpMap. wy - 0.5 ;
 83: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
 84: 	localNormal = normalize ( localNormal ) ;
 85: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
 86: 	float lambert = ldotN ;
 87: 	float specularPower = 10.0 ;
 88: 	float hDotN = dot3 ( normalize ( vofi_TexCoord6 . xyz ) , localNormal ) ;
 89: 	vec3 specularContribution = vec3 ( pow ( abs ( hDotN ) , specularPower ) ) ;
 90: 	vec3 diffuseColor = diffuseMap * ( _fa_[0 /* rpDiffuseModifier */] . xyz ) ;
 91: 	vec3 specularColor = specMap. xyz * specularContribution * ( _fa_[1 /* rpSpecularModifier */] . xyz ) ;
 92: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
 93: 	fo_FragColor . xyz = ( diffuseColor + specularColor ) * lightColor * vofi_Color . xyz ;
 94: 	fo_FragColor . w = 1.0 ;
 95: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 20 with vertexShader interactionAmbient_skinned and fragmentShader interactionAmbient_skinned
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[27];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_TexCoord7;
 34: out vec4 vofi_TexCoord8;
 35: out vec4 vofi_TexCoord9;
 36: out vec4 vofi_Color;
 37: 
 38: void main() {
 39: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 40: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 41: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 42: 	vec4 modelPosition = in_Position ;
 43: 	vec3 normal = vNormal. xyz ;
 44: 	vec3 tangent = vTangent. xyz ;
 45: 	vec3 bitangent = vBitangent. xyz ;
 46: 	gl_Position . x = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixX */] ) ;
 47: 	gl_Position . y = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixY */] ) ;
 48: 	gl_Position . z = dot4 ( modelPosition , _va_[16 /* rpMVPmatrixZ */] ) ;
 49: 	gl_Position . w = dot4 ( modelPosition , _va_[17 /* rpMVPmatrixW */] ) ;
 50: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 51: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 52: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 53: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 54: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 55: 	vofi_TexCoord0 . w = 1.0 ;
 56: 	vofi_TexCoord1 = defaultTexCoord ;
 57: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 58: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 59: 	vofi_TexCoord2 = defaultTexCoord ;
 60: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 61: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 62: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 63: 	vofi_TexCoord3 . z = 0.0 ;
 64: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 65: 	vofi_TexCoord4 = defaultTexCoord ;
 66: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 67: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 68: 	vofi_TexCoord5 = defaultTexCoord ;
 69: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
 70: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
 71: 	toLightLocal = normalize ( toLightLocal ) ;
 72: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
 73: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
 74: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
 75: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
 76: 	vofi_TexCoord6 . w = 1.0 ;
 77: 	vofi_TexCoord7 = modelPosition ;
 78: 	vec4 worldPosition ;
 79: 	worldPosition. x = dot4 ( modelPosition , _va_[18 /* rpModelMatrixX */] ) ;
 80: 	worldPosition. y = dot4 ( modelPosition , _va_[19 /* rpModelMatrixY */] ) ;
 81: 	worldPosition. z = dot4 ( modelPosition , _va_[20 /* rpModelMatrixZ */] ) ;
 82: 	worldPosition. w = dot4 ( modelPosition , _va_[21 /* rpModelMatrixW */] ) ;
 83: 	vec4 toLightGlobal = _va_[26 /* rpGlobalLightOrigin */] - worldPosition ;
 84: 	vofi_TexCoord8 = toLightGlobal ;
 85: 	vec4 viewPosition ;
 86: 	viewPosition. x = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixX */] ) ;
 87: 	viewPosition. y = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixY */] ) ;
 88: 	viewPosition. z = dot4 ( modelPosition , _va_[24 /* rpModelViewMatrixZ */] ) ;
 89: 	viewPosition. w = dot4 ( modelPosition , _va_[25 /* rpModelViewMatrixW */] ) ;
 90: 	vofi_TexCoord9 = viewPosition ;
 91: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
 92: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[30];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 53: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 54: 	return textureProj ( samp , texCoords. xyw ) ;
 55: }
 56: const float c_goldenRatioConjugate = 0.61803398875;
 57: uniform sampler2D samp0;
 58: uniform sampler2D samp1;
 59: uniform sampler2D samp2;
 60: uniform sampler2D samp3;
 61: uniform sampler2D samp4;
 62: uniform sampler2DArrayShadow samp5;
 63: uniform sampler2D samp6;
 64: 
 65: in vec4 vofi_TexCoord0;
 66: in vec4 vofi_TexCoord1;
 67: in vec4 vofi_TexCoord2;
 68: in vec4 vofi_TexCoord3;
 69: in vec4 vofi_TexCoord4;
 70: in vec4 vofi_TexCoord5;
 71: in vec4 vofi_TexCoord6;
 72: in vec4 vofi_TexCoord7;
 73: in vec4 vofi_TexCoord8;
 74: in vec4 vofi_TexCoord9;
 75: in vec4 vofi_Color;
 76: 
 77: out vec4 fo_FragColor;
 78: 
 79: float BlueNoise (vec2 n , float x ) {
 80: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 81: 	float noise = texture ( samp6 , uv ). r ;
 82: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 83: 	return noise ;
 84: }
 85: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 86: 	float goldenAngle = 2.4 ;
 87: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 88: 	float theta = sampleIndex * goldenAngle + phi ;
 89: 	float sine = sin ( theta ) ;
 90: 	float cosine = cos ( theta ) ;
 91: 	return vec2 ( r * cosine , r * sine ) ;
 92: }
 93: void main() {
 94: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 95: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 96: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 97: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 98: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 99: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
100: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
101: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
102: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
103: 	vec3 localNormal ;
104: 	localNormal. xy = bumpMap. wy - 0.5 ;
105: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
106: 	localNormal = normalize ( localNormal ) ;
107: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
108: 	float lambert = ldotN ;
109: 	int shadowIndex = 0 ;
110: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 0 ) ] ;
111: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 1 ) ] ;
112: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 2 ) ] ;
113: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 3 ) ] ;
114: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
115: 	vec4 shadowTexcoord ;
116: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
117: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
118: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
119: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
120: 	float bias = 0.001 ;
121: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
122: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
123: 	shadowTexcoord. w = float ( shadowIndex ) ;
124: 	float shadow = 0.0 ;
125: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
126: 	float stepSize = 1.0 / numSamples ;
127: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
128: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
129: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
130: 	{
131: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
132: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
133: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
134: 	}
135: 	shadow *= stepSize ;
136: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
137: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
138: 	float Y = dot ( LUMINANCE_SRGB. rgb , specMapSRGB. rgb ) ;
139: 	float glossiness = clamp ( pow ( Y , 1.0 / 2.0 ) , 0.0 , 0.98 ) ;
140: 	float roughness = 1.0 - glossiness ;
141: 	vec3 diffuseColor = diffuseMap ;
142: 	vec3 specularColor = specMapSRGB. rgb ;
143: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
144: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
145: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
146: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
147: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
148: 	float rr = roughness * roughness ;
149: 	float rrrr = rr * rr ;
150: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
151: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
152: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
153: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
154: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
155: 	fo_FragColor . rgb = color ;
156: 	fo_FragColor . a = 1.0 ;
157: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 21 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[25];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_TexCoord7;
 32: out vec4 vofi_TexCoord8;
 33: out vec4 vofi_TexCoord9;
 34: out vec4 vofi_Color;
 35: 
 36: void main() {
 37: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 38: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 39: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 40: 	float w0 = in_Color2 . x ;
 41: 	float w1 = in_Color2 . y ;
 42: 	float w2 = in_Color2 . z ;
 43: 	float w3 = in_Color2 . w ;
 44: 	vec4 matX , matY , matZ ;
 45: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 46: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 47: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 48: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 49: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 50: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 51: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 52: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 53: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 54: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 55: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 56: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 57: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 58: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 59: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 60: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 61: 	vec3 normal ;
 62: 	normal. x = dot3 ( matX , vNormal ) ;
 63: 	normal. y = dot3 ( matY , vNormal ) ;
 64: 	normal. z = dot3 ( matZ , vNormal ) ;
 65: 	normal = normalize ( normal ) ;
 66: 	vec3 tangent ;
 67: 	tangent. x = dot3 ( matX , vTangent ) ;
 68: 	tangent. y = dot3 ( matY , vTangent ) ;
 69: 	tangent. z = dot3 ( matZ , vTangent ) ;
 70: 	tangent = normalize ( tangent ) ;
 71: 	vec3 bitangent ;
 72: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 73: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 74: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 75: 	bitangent = normalize ( bitangent ) ;
 76: 	vec4 modelPosition ;
 77: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 78: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 79: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 80: 	modelPosition. w = 1.0 ;
 81: 	gl_Position . x = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixX */] ) ;
 82: 	gl_Position . y = dot4 ( modelPosition , _va_[13 /* rpMVPmatrixY */] ) ;
 83: 	gl_Position . z = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixZ */] ) ;
 84: 	gl_Position . w = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixW */] ) ;
 85: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 86: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 87: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 88: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 89: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 90: 	vofi_TexCoord0 . w = 1.0 ;
 91: 	vofi_TexCoord1 = defaultTexCoord ;
 92: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 93: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 94: 	vofi_TexCoord2 = defaultTexCoord ;
 95: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 96: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 97: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 98: 	vofi_TexCoord3 . z = 0.0 ;
 99: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
100: 	vofi_TexCoord4 = defaultTexCoord ;
101: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
102: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
103: 	vofi_TexCoord5 = defaultTexCoord ;
104: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
105: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
106: 	toLightLocal = normalize ( toLightLocal ) ;
107: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
108: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
109: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
110: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
111: 	vofi_TexCoord6 . w = 1.0 ;
112: 	vofi_TexCoord7 = modelPosition ;
113: 	vec4 worldPosition ;
114: 	worldPosition. x = dot4 ( modelPosition , _va_[16 /* rpModelMatrixX */] ) ;
115: 	worldPosition. y = dot4 ( modelPosition , _va_[17 /* rpModelMatrixY */] ) ;
116: 	worldPosition. z = dot4 ( modelPosition , _va_[18 /* rpModelMatrixZ */] ) ;
117: 	worldPosition. w = dot4 ( modelPosition , _va_[19 /* rpModelMatrixW */] ) ;
118: 	vec4 toLightGlobal = _va_[24 /* rpGlobalLightOrigin */] - worldPosition ;
119: 	vofi_TexCoord8 = toLightGlobal ;
120: 	vec4 viewPosition ;
121: 	viewPosition. x = dot4 ( modelPosition , _va_[20 /* rpModelViewMatrixX */] ) ;
122: 	viewPosition. y = dot4 ( modelPosition , _va_[21 /* rpModelViewMatrixY */] ) ;
123: 	viewPosition. z = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixZ */] ) ;
124: 	viewPosition. w = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixW */] ) ;
125: 	vofi_TexCoord9 = viewPosition ;
126: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
127: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[30];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 53: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 54: 	return textureProj ( samp , texCoords. xyw ) ;
 55: }
 56: const float c_goldenRatioConjugate = 0.61803398875;
 57: uniform sampler2D samp0;
 58: uniform sampler2D samp1;
 59: uniform sampler2D samp2;
 60: uniform sampler2D samp3;
 61: uniform sampler2D samp4;
 62: uniform sampler2DArrayShadow samp5;
 63: uniform sampler2D samp6;
 64: 
 65: in vec4 vofi_TexCoord0;
 66: in vec4 vofi_TexCoord1;
 67: in vec4 vofi_TexCoord2;
 68: in vec4 vofi_TexCoord3;
 69: in vec4 vofi_TexCoord4;
 70: in vec4 vofi_TexCoord5;
 71: in vec4 vofi_TexCoord6;
 72: in vec4 vofi_TexCoord7;
 73: in vec4 vofi_TexCoord8;
 74: in vec4 vofi_TexCoord9;
 75: in vec4 vofi_Color;
 76: 
 77: out vec4 fo_FragColor;
 78: 
 79: float BlueNoise (vec2 n , float x ) {
 80: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 81: 	float noise = texture ( samp6 , uv ). r ;
 82: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 83: 	return noise ;
 84: }
 85: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 86: 	float goldenAngle = 2.4 ;
 87: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 88: 	float theta = sampleIndex * goldenAngle + phi ;
 89: 	float sine = sin ( theta ) ;
 90: 	float cosine = cos ( theta ) ;
 91: 	return vec2 ( r * cosine , r * sine ) ;
 92: }
 93: void main() {
 94: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 95: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 96: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 97: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 98: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 99: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
100: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
101: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
102: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
103: 	vec3 localNormal ;
104: 	localNormal. xy = bumpMap. wy - 0.5 ;
105: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
106: 	localNormal = normalize ( localNormal ) ;
107: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
108: 	float lambert = ldotN ;
109: 	int shadowIndex = 0 ;
110: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 0 ) ] ;
111: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 1 ) ] ;
112: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 2 ) ] ;
113: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 3 ) ] ;
114: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
115: 	vec4 shadowTexcoord ;
116: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
117: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
118: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
119: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
120: 	float bias = 0.001 ;
121: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
122: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
123: 	shadowTexcoord. w = float ( shadowIndex ) ;
124: 	float shadow = 0.0 ;
125: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
126: 	float stepSize = 1.0 / numSamples ;
127: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
128: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
129: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
130: 	{
131: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
132: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
133: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
134: 	}
135: 	shadow *= stepSize ;
136: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
137: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
138: 	float Y = dot ( LUMINANCE_SRGB. rgb , specMapSRGB. rgb ) ;
139: 	float glossiness = clamp ( pow ( Y , 1.0 / 2.0 ) , 0.0 , 0.98 ) ;
140: 	float roughness = 1.0 - glossiness ;
141: 	vec3 diffuseColor = diffuseMap ;
142: 	vec3 specularColor = specMapSRGB. rgb ;
143: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
144: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
145: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
146: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
147: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
148: 	float rr = roughness * roughness ;
149: 	float rrrr = rr * rr ;
150: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
151: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
152: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
153: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
154: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
155: 	fo_FragColor . rgb = color ;
156: 	fo_FragColor . a = 1.0 ;
157: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 22 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[27];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_TexCoord7;
 34: out vec4 vofi_TexCoord8;
 35: out vec4 vofi_TexCoord9;
 36: out vec4 vofi_Color;
 37: 
 38: void main() {
 39: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 40: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 41: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 42: 	vec4 modelPosition = in_Position ;
 43: 	vec3 normal = vNormal. xyz ;
 44: 	vec3 tangent = vTangent. xyz ;
 45: 	vec3 bitangent = vBitangent. xyz ;
 46: 	gl_Position . x = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixX */] ) ;
 47: 	gl_Position . y = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixY */] ) ;
 48: 	gl_Position . z = dot4 ( modelPosition , _va_[16 /* rpMVPmatrixZ */] ) ;
 49: 	gl_Position . w = dot4 ( modelPosition , _va_[17 /* rpMVPmatrixW */] ) ;
 50: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 51: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 52: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 53: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 54: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 55: 	vofi_TexCoord0 . w = 1.0 ;
 56: 	vofi_TexCoord1 = defaultTexCoord ;
 57: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 58: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 59: 	vofi_TexCoord2 = defaultTexCoord ;
 60: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 61: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 62: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 63: 	vofi_TexCoord3 . z = 0.0 ;
 64: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 65: 	vofi_TexCoord4 = defaultTexCoord ;
 66: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 67: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 68: 	vofi_TexCoord5 = defaultTexCoord ;
 69: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
 70: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
 71: 	toLightLocal = normalize ( toLightLocal ) ;
 72: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
 73: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
 74: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
 75: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
 76: 	vofi_TexCoord6 . w = 1.0 ;
 77: 	vofi_TexCoord7 = modelPosition ;
 78: 	vec4 worldPosition ;
 79: 	worldPosition. x = dot4 ( modelPosition , _va_[18 /* rpModelMatrixX */] ) ;
 80: 	worldPosition. y = dot4 ( modelPosition , _va_[19 /* rpModelMatrixY */] ) ;
 81: 	worldPosition. z = dot4 ( modelPosition , _va_[20 /* rpModelMatrixZ */] ) ;
 82: 	worldPosition. w = dot4 ( modelPosition , _va_[21 /* rpModelMatrixW */] ) ;
 83: 	vec4 toLightGlobal = _va_[26 /* rpGlobalLightOrigin */] - worldPosition ;
 84: 	vofi_TexCoord8 = toLightGlobal ;
 85: 	vec4 viewPosition ;
 86: 	viewPosition. x = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixX */] ) ;
 87: 	viewPosition. y = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixY */] ) ;
 88: 	viewPosition. z = dot4 ( modelPosition , _va_[24 /* rpModelViewMatrixZ */] ) ;
 89: 	viewPosition. w = dot4 ( modelPosition , _va_[25 /* rpModelViewMatrixW */] ) ;
 90: 	vofi_TexCoord9 = viewPosition ;
 91: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
 92: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[30];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 53: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 54: 	return textureProj ( samp , texCoords. xyw ) ;
 55: }
 56: const float c_goldenRatioConjugate = 0.61803398875;
 57: uniform sampler2D samp0;
 58: uniform sampler2D samp1;
 59: uniform sampler2D samp2;
 60: uniform sampler2D samp3;
 61: uniform sampler2D samp4;
 62: uniform sampler2DArrayShadow samp5;
 63: uniform sampler2D samp6;
 64: 
 65: in vec4 vofi_TexCoord0;
 66: in vec4 vofi_TexCoord1;
 67: in vec4 vofi_TexCoord2;
 68: in vec4 vofi_TexCoord3;
 69: in vec4 vofi_TexCoord4;
 70: in vec4 vofi_TexCoord5;
 71: in vec4 vofi_TexCoord6;
 72: in vec4 vofi_TexCoord7;
 73: in vec4 vofi_TexCoord8;
 74: in vec4 vofi_TexCoord9;
 75: in vec4 vofi_Color;
 76: 
 77: out vec4 fo_FragColor;
 78: 
 79: float BlueNoise (vec2 n , float x ) {
 80: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 81: 	float noise = texture ( samp6 , uv ). r ;
 82: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 83: 	return noise ;
 84: }
 85: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 86: 	float goldenAngle = 2.4 ;
 87: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 88: 	float theta = sampleIndex * goldenAngle + phi ;
 89: 	float sine = sin ( theta ) ;
 90: 	float cosine = cos ( theta ) ;
 91: 	return vec2 ( r * cosine , r * sine ) ;
 92: }
 93: void main() {
 94: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 95: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 96: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 97: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 98: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 99: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
100: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
101: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
102: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
103: 	vec3 localNormal ;
104: 	localNormal. xy = bumpMap. wy - 0.5 ;
105: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
106: 	localNormal = normalize ( localNormal ) ;
107: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
108: 	float lambert = ldotN ;
109: 	int shadowIndex = 0 ;
110: 	vec3 toLightGlobal = normalize ( vofi_TexCoord8 . xyz ) ;
111: 	float axis [ 6 ] ;
112: 	axis [ 0 ] = - toLightGlobal. x ;
113: 	axis [ 1 ] = toLightGlobal. x ;
114: 	axis [ 2 ] = - toLightGlobal. y ;
115: 	axis [ 3 ] = toLightGlobal. y ;
116: 	axis [ 4 ] = - toLightGlobal. z ;
117: 	axis [ 5 ] = toLightGlobal. z ;
118: 	for ( int i = 0 ; i < 6 ; i ++ )
119: 	{
120: 		if ( axis [ i ] > axis [ shadowIndex ] )
121: 		{
122: 			shadowIndex = i ;
123: 		}
124: 	}
125: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 0 ) ] ;
126: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 1 ) ] ;
127: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 2 ) ] ;
128: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 3 ) ] ;
129: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
130: 	vec4 shadowTexcoord ;
131: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
132: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
133: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
134: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
135: 	float bias = 0.001 ;
136: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
137: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
138: 	shadowTexcoord. w = float ( shadowIndex ) ;
139: 	float shadow = 0.0 ;
140: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
141: 	float stepSize = 1.0 / numSamples ;
142: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
143: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
144: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
145: 	{
146: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
147: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
148: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
149: 	}
150: 	shadow *= stepSize ;
151: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
152: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
153: 	float Y = dot ( LUMINANCE_SRGB. rgb , specMapSRGB. rgb ) ;
154: 	float glossiness = clamp ( pow ( Y , 1.0 / 2.0 ) , 0.0 , 0.98 ) ;
155: 	float roughness = 1.0 - glossiness ;
156: 	vec3 diffuseColor = diffuseMap ;
157: 	vec3 specularColor = specMapSRGB. rgb ;
158: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
159: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
160: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
161: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
162: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
163: 	float rr = roughness * roughness ;
164: 	float rrrr = rr * rr ;
165: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
166: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
167: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
168: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
169: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
170: 	fo_FragColor . rgb = color ;
171: 	fo_FragColor . a = 1.0 ;
172: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 23 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[25];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_TexCoord7;
 32: out vec4 vofi_TexCoord8;
 33: out vec4 vofi_TexCoord9;
 34: out vec4 vofi_Color;
 35: 
 36: void main() {
 37: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 38: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 39: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 40: 	float w0 = in_Color2 . x ;
 41: 	float w1 = in_Color2 . y ;
 42: 	float w2 = in_Color2 . z ;
 43: 	float w3 = in_Color2 . w ;
 44: 	vec4 matX , matY , matZ ;
 45: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 46: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 47: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 48: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 49: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 50: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 51: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 52: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 53: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 54: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 55: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 56: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 57: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 58: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 59: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 60: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 61: 	vec3 normal ;
 62: 	normal. x = dot3 ( matX , vNormal ) ;
 63: 	normal. y = dot3 ( matY , vNormal ) ;
 64: 	normal. z = dot3 ( matZ , vNormal ) ;
 65: 	normal = normalize ( normal ) ;
 66: 	vec3 tangent ;
 67: 	tangent. x = dot3 ( matX , vTangent ) ;
 68: 	tangent. y = dot3 ( matY , vTangent ) ;
 69: 	tangent. z = dot3 ( matZ , vTangent ) ;
 70: 	tangent = normalize ( tangent ) ;
 71: 	vec3 bitangent ;
 72: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 73: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 74: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 75: 	bitangent = normalize ( bitangent ) ;
 76: 	vec4 modelPosition ;
 77: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 78: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 79: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 80: 	modelPosition. w = 1.0 ;
 81: 	gl_Position . x = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixX */] ) ;
 82: 	gl_Position . y = dot4 ( modelPosition , _va_[13 /* rpMVPmatrixY */] ) ;
 83: 	gl_Position . z = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixZ */] ) ;
 84: 	gl_Position . w = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixW */] ) ;
 85: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 86: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 87: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 88: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 89: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 90: 	vofi_TexCoord0 . w = 1.0 ;
 91: 	vofi_TexCoord1 = defaultTexCoord ;
 92: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 93: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 94: 	vofi_TexCoord2 = defaultTexCoord ;
 95: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 96: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 97: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 98: 	vofi_TexCoord3 . z = 0.0 ;
 99: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
100: 	vofi_TexCoord4 = defaultTexCoord ;
101: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
102: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
103: 	vofi_TexCoord5 = defaultTexCoord ;
104: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
105: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
106: 	toLightLocal = normalize ( toLightLocal ) ;
107: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
108: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
109: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
110: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
111: 	vofi_TexCoord6 . w = 1.0 ;
112: 	vofi_TexCoord7 = modelPosition ;
113: 	vec4 worldPosition ;
114: 	worldPosition. x = dot4 ( modelPosition , _va_[16 /* rpModelMatrixX */] ) ;
115: 	worldPosition. y = dot4 ( modelPosition , _va_[17 /* rpModelMatrixY */] ) ;
116: 	worldPosition. z = dot4 ( modelPosition , _va_[18 /* rpModelMatrixZ */] ) ;
117: 	worldPosition. w = dot4 ( modelPosition , _va_[19 /* rpModelMatrixW */] ) ;
118: 	vec4 toLightGlobal = _va_[24 /* rpGlobalLightOrigin */] - worldPosition ;
119: 	vofi_TexCoord8 = toLightGlobal ;
120: 	vec4 viewPosition ;
121: 	viewPosition. x = dot4 ( modelPosition , _va_[20 /* rpModelViewMatrixX */] ) ;
122: 	viewPosition. y = dot4 ( modelPosition , _va_[21 /* rpModelViewMatrixY */] ) ;
123: 	viewPosition. z = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixZ */] ) ;
124: 	viewPosition. w = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixW */] ) ;
125: 	vofi_TexCoord9 = viewPosition ;
126: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
127: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[30];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 53: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 54: 	return textureProj ( samp , texCoords. xyw ) ;
 55: }
 56: const float c_goldenRatioConjugate = 0.61803398875;
 57: uniform sampler2D samp0;
 58: uniform sampler2D samp1;
 59: uniform sampler2D samp2;
 60: uniform sampler2D samp3;
 61: uniform sampler2D samp4;
 62: uniform sampler2DArrayShadow samp5;
 63: uniform sampler2D samp6;
 64: 
 65: in vec4 vofi_TexCoord0;
 66: in vec4 vofi_TexCoord1;
 67: in vec4 vofi_TexCoord2;
 68: in vec4 vofi_TexCoord3;
 69: in vec4 vofi_TexCoord4;
 70: in vec4 vofi_TexCoord5;
 71: in vec4 vofi_TexCoord6;
 72: in vec4 vofi_TexCoord7;
 73: in vec4 vofi_TexCoord8;
 74: in vec4 vofi_TexCoord9;
 75: in vec4 vofi_Color;
 76: 
 77: out vec4 fo_FragColor;
 78: 
 79: float BlueNoise (vec2 n , float x ) {
 80: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 81: 	float noise = texture ( samp6 , uv ). r ;
 82: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 83: 	return noise ;
 84: }
 85: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 86: 	float goldenAngle = 2.4 ;
 87: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 88: 	float theta = sampleIndex * goldenAngle + phi ;
 89: 	float sine = sin ( theta ) ;
 90: 	float cosine = cos ( theta ) ;
 91: 	return vec2 ( r * cosine , r * sine ) ;
 92: }
 93: void main() {
 94: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 95: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 96: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 97: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 98: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 99: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
100: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
101: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
102: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
103: 	vec3 localNormal ;
104: 	localNormal. xy = bumpMap. wy - 0.5 ;
105: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
106: 	localNormal = normalize ( localNormal ) ;
107: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
108: 	float lambert = ldotN ;
109: 	int shadowIndex = 0 ;
110: 	vec3 toLightGlobal = normalize ( vofi_TexCoord8 . xyz ) ;
111: 	float axis [ 6 ] ;
112: 	axis [ 0 ] = - toLightGlobal. x ;
113: 	axis [ 1 ] = toLightGlobal. x ;
114: 	axis [ 2 ] = - toLightGlobal. y ;
115: 	axis [ 3 ] = toLightGlobal. y ;
116: 	axis [ 4 ] = - toLightGlobal. z ;
117: 	axis [ 5 ] = toLightGlobal. z ;
118: 	for ( int i = 0 ; i < 6 ; i ++ )
119: 	{
120: 		if ( axis [ i ] > axis [ shadowIndex ] )
121: 		{
122: 			shadowIndex = i ;
123: 		}
124: 	}
125: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 0 ) ] ;
126: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 1 ) ] ;
127: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 2 ) ] ;
128: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 3 ) ] ;
129: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
130: 	vec4 shadowTexcoord ;
131: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
132: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
133: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
134: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
135: 	float bias = 0.001 ;
136: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
137: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
138: 	shadowTexcoord. w = float ( shadowIndex ) ;
139: 	float shadow = 0.0 ;
140: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
141: 	float stepSize = 1.0 / numSamples ;
142: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
143: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
144: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
145: 	{
146: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
147: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
148: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
149: 	}
150: 	shadow *= stepSize ;
151: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
152: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
153: 	float Y = dot ( LUMINANCE_SRGB. rgb , specMapSRGB. rgb ) ;
154: 	float glossiness = clamp ( pow ( Y , 1.0 / 2.0 ) , 0.0 , 0.98 ) ;
155: 	float roughness = 1.0 - glossiness ;
156: 	vec3 diffuseColor = diffuseMap ;
157: 	vec3 specularColor = specMapSRGB. rgb ;
158: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
159: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
160: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
161: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
162: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
163: 	float rr = roughness * roughness ;
164: 	float rrrr = rr * rr ;
165: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
166: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
167: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
168: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
169: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
170: 	fo_FragColor . rgb = color ;
171: 	fo_FragColor . a = 1.0 ;
172: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 24 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[27];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_TexCoord7;
 34: out vec4 vofi_TexCoord8;
 35: out vec4 vofi_TexCoord9;
 36: out vec4 vofi_Color;
 37: 
 38: void main() {
 39: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 40: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 41: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 42: 	vec4 modelPosition = in_Position ;
 43: 	vec3 normal = vNormal. xyz ;
 44: 	vec3 tangent = vTangent. xyz ;
 45: 	vec3 bitangent = vBitangent. xyz ;
 46: 	gl_Position . x = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixX */] ) ;
 47: 	gl_Position . y = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixY */] ) ;
 48: 	gl_Position . z = dot4 ( modelPosition , _va_[16 /* rpMVPmatrixZ */] ) ;
 49: 	gl_Position . w = dot4 ( modelPosition , _va_[17 /* rpMVPmatrixW */] ) ;
 50: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 51: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 52: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 53: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 54: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 55: 	vofi_TexCoord0 . w = 1.0 ;
 56: 	vofi_TexCoord1 = defaultTexCoord ;
 57: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 58: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 59: 	vofi_TexCoord2 = defaultTexCoord ;
 60: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 61: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 62: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 63: 	vofi_TexCoord3 . z = 0.0 ;
 64: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 65: 	vofi_TexCoord4 = defaultTexCoord ;
 66: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 67: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 68: 	vofi_TexCoord5 = defaultTexCoord ;
 69: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
 70: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
 71: 	toLightLocal = normalize ( toLightLocal ) ;
 72: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
 73: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
 74: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
 75: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
 76: 	vofi_TexCoord6 . w = 1.0 ;
 77: 	vofi_TexCoord7 = modelPosition ;
 78: 	vec4 worldPosition ;
 79: 	worldPosition. x = dot4 ( modelPosition , _va_[18 /* rpModelMatrixX */] ) ;
 80: 	worldPosition. y = dot4 ( modelPosition , _va_[19 /* rpModelMatrixY */] ) ;
 81: 	worldPosition. z = dot4 ( modelPosition , _va_[20 /* rpModelMatrixZ */] ) ;
 82: 	worldPosition. w = dot4 ( modelPosition , _va_[21 /* rpModelMatrixW */] ) ;
 83: 	vec4 toLightGlobal = _va_[26 /* rpGlobalLightOrigin */] - worldPosition ;
 84: 	vofi_TexCoord8 = toLightGlobal ;
 85: 	vec4 viewPosition ;
 86: 	viewPosition. x = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixX */] ) ;
 87: 	viewPosition. y = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixY */] ) ;
 88: 	viewPosition. z = dot4 ( modelPosition , _va_[24 /* rpModelViewMatrixZ */] ) ;
 89: 	viewPosition. w = dot4 ( modelPosition , _va_[25 /* rpModelViewMatrixW */] ) ;
 90: 	vofi_TexCoord9 = viewPosition ;
 91: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
 92: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[31];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 53: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 54: 	return textureProj ( samp , texCoords. xyw ) ;
 55: }
 56: const float c_goldenRatioConjugate = 0.61803398875;
 57: uniform sampler2D samp0;
 58: uniform sampler2D samp1;
 59: uniform sampler2D samp2;
 60: uniform sampler2D samp3;
 61: uniform sampler2D samp4;
 62: uniform sampler2DArrayShadow samp5;
 63: uniform sampler2D samp6;
 64: 
 65: in vec4 vofi_TexCoord0;
 66: in vec4 vofi_TexCoord1;
 67: in vec4 vofi_TexCoord2;
 68: in vec4 vofi_TexCoord3;
 69: in vec4 vofi_TexCoord4;
 70: in vec4 vofi_TexCoord5;
 71: in vec4 vofi_TexCoord6;
 72: in vec4 vofi_TexCoord7;
 73: in vec4 vofi_TexCoord8;
 74: in vec4 vofi_TexCoord9;
 75: in vec4 vofi_Color;
 76: 
 77: out vec4 fo_FragColor;
 78: 
 79: float BlueNoise (vec2 n , float x ) {
 80: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 81: 	float noise = texture ( samp6 , uv ). r ;
 82: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 83: 	return noise ;
 84: }
 85: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 86: 	float goldenAngle = 2.4 ;
 87: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 88: 	float theta = sampleIndex * goldenAngle + phi ;
 89: 	float sine = sin ( theta ) ;
 90: 	float cosine = cos ( theta ) ;
 91: 	return vec2 ( r * cosine , r * sine ) ;
 92: }
 93: void main() {
 94: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 95: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 96: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 97: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 98: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 99: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
100: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
101: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
102: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
103: 	vec3 localNormal ;
104: 	localNormal. xy = bumpMap. wy - 0.5 ;
105: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
106: 	localNormal = normalize ( localNormal ) ;
107: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
108: 	float lambert = ldotN ;
109: 	int shadowIndex = 0 ;
110: 	float viewZ = - vofi_TexCoord9 . z ;
111: 	shadowIndex = 4 ;
112: 	for ( int i = 0 ; i < 4 ; i ++ )
113: 	{
114: 		if ( viewZ < _fa_[5 /* rpCascadeDistances */] [ i ] )
115: 		{
116: 			shadowIndex = i ;
117: 			break ;
118: 		}
119: 	}
120: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 0 ) ] ;
121: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 1 ) ] ;
122: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 2 ) ] ;
123: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 3 ) ] ;
124: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
125: 	vec4 shadowTexcoord ;
126: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
127: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
128: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
129: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
130: 	float bias = 0.001 ;
131: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
132: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
133: 	shadowTexcoord. w = float ( shadowIndex ) ;
134: 	float shadow = 0.0 ;
135: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
136: 	float stepSize = 1.0 / numSamples ;
137: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
138: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
139: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
140: 	{
141: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
142: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
143: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
144: 	}
145: 	shadow *= stepSize ;
146: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
147: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
148: 	float Y = dot ( LUMINANCE_SRGB. rgb , specMapSRGB. rgb ) ;
149: 	float glossiness = clamp ( pow ( Y , 1.0 / 2.0 ) , 0.0 , 0.98 ) ;
150: 	float roughness = 1.0 - glossiness ;
151: 	vec3 diffuseColor = diffuseMap ;
152: 	vec3 specularColor = specMapSRGB. rgb ;
153: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
154: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
155: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
156: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
157: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
158: 	float rr = roughness * roughness ;
159: 	float rrrr = rr * rr ;
160: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
161: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
162: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
163: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
164: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
165: 	fo_FragColor . rgb = color ;
166: 	fo_FragColor . a = 1.0 ;
167: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 25 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[25];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_TexCoord7;
 32: out vec4 vofi_TexCoord8;
 33: out vec4 vofi_TexCoord9;
 34: out vec4 vofi_Color;
 35: 
 36: void main() {
 37: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 38: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 39: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 40: 	float w0 = in_Color2 . x ;
 41: 	float w1 = in_Color2 . y ;
 42: 	float w2 = in_Color2 . z ;
 43: 	float w3 = in_Color2 . w ;
 44: 	vec4 matX , matY , matZ ;
 45: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 46: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 47: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 48: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 49: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 50: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 51: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 52: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 53: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 54: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 55: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 56: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 57: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 58: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 59: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 60: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 61: 	vec3 normal ;
 62: 	normal. x = dot3 ( matX , vNormal ) ;
 63: 	normal. y = dot3 ( matY , vNormal ) ;
 64: 	normal. z = dot3 ( matZ , vNormal ) ;
 65: 	normal = normalize ( normal ) ;
 66: 	vec3 tangent ;
 67: 	tangent. x = dot3 ( matX , vTangent ) ;
 68: 	tangent. y = dot3 ( matY , vTangent ) ;
 69: 	tangent. z = dot3 ( matZ , vTangent ) ;
 70: 	tangent = normalize ( tangent ) ;
 71: 	vec3 bitangent ;
 72: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 73: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 74: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 75: 	bitangent = normalize ( bitangent ) ;
 76: 	vec4 modelPosition ;
 77: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 78: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 79: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 80: 	modelPosition. w = 1.0 ;
 81: 	gl_Position . x = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixX */] ) ;
 82: 	gl_Position . y = dot4 ( modelPosition , _va_[13 /* rpMVPmatrixY */] ) ;
 83: 	gl_Position . z = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixZ */] ) ;
 84: 	gl_Position . w = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixW */] ) ;
 85: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 86: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 87: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 88: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 89: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 90: 	vofi_TexCoord0 . w = 1.0 ;
 91: 	vofi_TexCoord1 = defaultTexCoord ;
 92: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 93: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 94: 	vofi_TexCoord2 = defaultTexCoord ;
 95: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 96: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 97: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 98: 	vofi_TexCoord3 . z = 0.0 ;
 99: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
100: 	vofi_TexCoord4 = defaultTexCoord ;
101: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
102: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
103: 	vofi_TexCoord5 = defaultTexCoord ;
104: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
105: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
106: 	toLightLocal = normalize ( toLightLocal ) ;
107: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
108: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
109: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
110: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
111: 	vofi_TexCoord6 . w = 1.0 ;
112: 	vofi_TexCoord7 = modelPosition ;
113: 	vec4 worldPosition ;
114: 	worldPosition. x = dot4 ( modelPosition , _va_[16 /* rpModelMatrixX */] ) ;
115: 	worldPosition. y = dot4 ( modelPosition , _va_[17 /* rpModelMatrixY */] ) ;
116: 	worldPosition. z = dot4 ( modelPosition , _va_[18 /* rpModelMatrixZ */] ) ;
117: 	worldPosition. w = dot4 ( modelPosition , _va_[19 /* rpModelMatrixW */] ) ;
118: 	vec4 toLightGlobal = _va_[24 /* rpGlobalLightOrigin */] - worldPosition ;
119: 	vofi_TexCoord8 = toLightGlobal ;
120: 	vec4 viewPosition ;
121: 	viewPosition. x = dot4 ( modelPosition , _va_[20 /* rpModelViewMatrixX */] ) ;
122: 	viewPosition. y = dot4 ( modelPosition , _va_[21 /* rpModelViewMatrixY */] ) ;
123: 	viewPosition. z = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixZ */] ) ;
124: 	viewPosition. w = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixW */] ) ;
125: 	vofi_TexCoord9 = viewPosition ;
126: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
127: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[31];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 53: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 54: 	return textureProj ( samp , texCoords. xyw ) ;
 55: }
 56: const float c_goldenRatioConjugate = 0.61803398875;
 57: uniform sampler2D samp0;
 58: uniform sampler2D samp1;
 59: uniform sampler2D samp2;
 60: uniform sampler2D samp3;
 61: uniform sampler2D samp4;
 62: uniform sampler2DArrayShadow samp5;
 63: uniform sampler2D samp6;
 64: 
 65: in vec4 vofi_TexCoord0;
 66: in vec4 vofi_TexCoord1;
 67: in vec4 vofi_TexCoord2;
 68: in vec4 vofi_TexCoord3;
 69: in vec4 vofi_TexCoord4;
 70: in vec4 vofi_TexCoord5;
 71: in vec4 vofi_TexCoord6;
 72: in vec4 vofi_TexCoord7;
 73: in vec4 vofi_TexCoord8;
 74: in vec4 vofi_TexCoord9;
 75: in vec4 vofi_Color;
 76: 
 77: out vec4 fo_FragColor;
 78: 
 79: float BlueNoise (vec2 n , float x ) {
 80: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 81: 	float noise = texture ( samp6 , uv ). r ;
 82: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 83: 	return noise ;
 84: }
 85: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 86: 	float goldenAngle = 2.4 ;
 87: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 88: 	float theta = sampleIndex * goldenAngle + phi ;
 89: 	float sine = sin ( theta ) ;
 90: 	float cosine = cos ( theta ) ;
 91: 	return vec2 ( r * cosine , r * sine ) ;
 92: }
 93: void main() {
 94: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 95: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 96: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 97: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 98: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 99: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
100: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
101: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
102: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
103: 	vec3 localNormal ;
104: 	localNormal. xy = bumpMap. wy - 0.5 ;
105: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
106: 	localNormal = normalize ( localNormal ) ;
107: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
108: 	float lambert = ldotN ;
109: 	int shadowIndex = 0 ;
110: 	float viewZ = - vofi_TexCoord9 . z ;
111: 	shadowIndex = 4 ;
112: 	for ( int i = 0 ; i < 4 ; i ++ )
113: 	{
114: 		if ( viewZ < _fa_[5 /* rpCascadeDistances */] [ i ] )
115: 		{
116: 			shadowIndex = i ;
117: 			break ;
118: 		}
119: 	}
120: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 0 ) ] ;
121: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 1 ) ] ;
122: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 2 ) ] ;
123: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 3 ) ] ;
124: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
125: 	vec4 shadowTexcoord ;
126: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
127: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
128: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
129: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
130: 	float bias = 0.001 ;
131: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
132: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
133: 	shadowTexcoord. w = float ( shadowIndex ) ;
134: 	float shadow = 0.0 ;
135: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
136: 	float stepSize = 1.0 / numSamples ;
137: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
138: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
139: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
140: 	{
141: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
142: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
143: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
144: 	}
145: 	shadow *= stepSize ;
146: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
147: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
148: 	float Y = dot ( LUMINANCE_SRGB. rgb , specMapSRGB. rgb ) ;
149: 	float glossiness = clamp ( pow ( Y , 1.0 / 2.0 ) , 0.0 , 0.98 ) ;
150: 	float roughness = 1.0 - glossiness ;
151: 	vec3 diffuseColor = diffuseMap ;
152: 	vec3 specularColor = specMapSRGB. rgb ;
153: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
154: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
155: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
156: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
157: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
158: 	float rr = roughness * roughness ;
159: 	float rrrr = rr * rr ;
160: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
161: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
162: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
163: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
164: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
165: 	fo_FragColor . rgb = color ;
166: 	fo_FragColor . a = 1.0 ;
167: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 26 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interaction.vs.hlsl
-----------------
  1: // filename renderprogs/interaction.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[18];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_Color;
 34: 
 35: void main() {
 36: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 37: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 38: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 39: 	vec4 modelPosition = in_Position ;
 40: 	vec3 normal = vNormal. xyz ;
 41: 	vec3 tangent = vTangent. xyz ;
 42: 	vec3 bitangent = vBitangent. xyz ;
 43: 	gl_Position . x = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixX */] ) ;
 44: 	gl_Position . y = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixY */] ) ;
 45: 	gl_Position . z = dot4 ( modelPosition , _va_[16 /* rpMVPmatrixZ */] ) ;
 46: 	gl_Position . w = dot4 ( modelPosition , _va_[17 /* rpMVPmatrixW */] ) ;
 47: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 48: 	vec4 toLight = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 49: 	vofi_TexCoord0 . x = dot3 ( tangent , toLight ) ;
 50: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLight ) ;
 51: 	vofi_TexCoord0 . z = dot3 ( normal , toLight ) ;
 52: 	vofi_TexCoord0 . w = 1.0 ;
 53: 	vofi_TexCoord1 = defaultTexCoord ;
 54: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 55: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 56: 	vofi_TexCoord2 = defaultTexCoord ;
 57: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 58: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 59: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 60: 	vofi_TexCoord3 . z = 0.0 ;
 61: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 62: 	vofi_TexCoord4 = defaultTexCoord ;
 63: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 64: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 65: 	vofi_TexCoord5 = defaultTexCoord ;
 66: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
 67: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
 68: 	toLight = normalize ( toLight ) ;
 69: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
 70: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
 71: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
 72: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
 73: 	vofi_TexCoord6 . w = 1.0 ;
 74: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
 75: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interaction.ps.hlsl
-----------------
  1: // filename renderprogs/interaction.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[2];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: uniform sampler2D samp0;
 56: uniform sampler2D samp1;
 57: uniform sampler2D samp2;
 58: uniform sampler2D samp3;
 59: uniform sampler2D samp4;
 60: 
 61: in vec4 vofi_TexCoord0;
 62: in vec4 vofi_TexCoord1;
 63: in vec4 vofi_TexCoord2;
 64: in vec4 vofi_TexCoord3;
 65: in vec4 vofi_TexCoord4;
 66: in vec4 vofi_TexCoord5;
 67: in vec4 vofi_TexCoord6;
 68: in vec4 vofi_Color;
 69: 
 70: out vec4 fo_FragColor;
 71: 
 72: void main() {
 73: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 74: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 75: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 76: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 77: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 78: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 79: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
 80: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
 81: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 82: 	vec3 localNormal ;
 83: 	localNormal. xy = bumpMap. wy - 0.5 ;
 84: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
 85: 	localNormal = normalize ( localNormal ) ;
 86: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
 87: 	float lambert = ldotN ;
 88: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
 89: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
 90: 	float metallic = specMapSRGB. g ;
 91: 	float roughness = specMapSRGB. r ;
 92: 	float glossiness = 1.0 - roughness ;
 93: 	vec3 dielectricColor = vec3 ( 0.04 ) ;
 94: 	vec3 baseColor = diffuseMap ;
 95: 	vec3 diffuseColor = baseColor * ( 1.0 - metallic ) ;
 96: 	vec3 specularColor = mix ( dielectricColor , baseColor , metallic ) ;
 97: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
 98: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
 99: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
100: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
101: 	vec3 reflectColor = specularColor * _fa_[1 /* rpSpecularModifier */] . rgb * 1.0 ;
102: 	float rr = roughness * roughness ;
103: 	float rrrr = rr * rr ;
104: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
105: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
106: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
107: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[0 /* rpDiffuseModifier */] . xyz ) ;
108: 	fo_FragColor . xyz = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb ;
109: 	fo_FragColor . w = 1.0 ;
110: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 27 with vertexShader interaction and fragmentShader interaction
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interaction.vs.hlsl
-----------------
  1: // filename renderprogs/interaction.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[16];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_Color;
 32: 
 33: void main() {
 34: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 35: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 36: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 37: 	float w0 = in_Color2 . x ;
 38: 	float w1 = in_Color2 . y ;
 39: 	float w2 = in_Color2 . z ;
 40: 	float w3 = in_Color2 . w ;
 41: 	vec4 matX , matY , matZ ;
 42: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 43: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 44: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 45: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 46: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 47: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 48: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 49: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 50: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 51: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 52: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 53: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 54: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 55: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 56: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 57: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 58: 	vec3 normal ;
 59: 	normal. x = dot3 ( matX , vNormal ) ;
 60: 	normal. y = dot3 ( matY , vNormal ) ;
 61: 	normal. z = dot3 ( matZ , vNormal ) ;
 62: 	normal = normalize ( normal ) ;
 63: 	vec3 tangent ;
 64: 	tangent. x = dot3 ( matX , vTangent ) ;
 65: 	tangent. y = dot3 ( matY , vTangent ) ;
 66: 	tangent. z = dot3 ( matZ , vTangent ) ;
 67: 	tangent = normalize ( tangent ) ;
 68: 	vec3 bitangent ;
 69: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 70: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 71: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 72: 	bitangent = normalize ( bitangent ) ;
 73: 	vec4 modelPosition ;
 74: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 75: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 76: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 77: 	modelPosition. w = 1.0 ;
 78: 	gl_Position . x = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixX */] ) ;
 79: 	gl_Position . y = dot4 ( modelPosition , _va_[13 /* rpMVPmatrixY */] ) ;
 80: 	gl_Position . z = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixZ */] ) ;
 81: 	gl_Position . w = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixW */] ) ;
 82: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 83: 	vec4 toLight = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 84: 	vofi_TexCoord0 . x = dot3 ( tangent , toLight ) ;
 85: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLight ) ;
 86: 	vofi_TexCoord0 . z = dot3 ( normal , toLight ) ;
 87: 	vofi_TexCoord0 . w = 1.0 ;
 88: 	vofi_TexCoord1 = defaultTexCoord ;
 89: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 90: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 91: 	vofi_TexCoord2 = defaultTexCoord ;
 92: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 93: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 94: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 95: 	vofi_TexCoord3 . z = 0.0 ;
 96: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 97: 	vofi_TexCoord4 = defaultTexCoord ;
 98: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 99: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
100: 	vofi_TexCoord5 = defaultTexCoord ;
101: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
102: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
103: 	toLight = normalize ( toLight ) ;
104: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
105: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
106: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
107: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
108: 	vofi_TexCoord6 . w = 1.0 ;
109: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
110: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interaction.ps.hlsl
-----------------
  1: // filename renderprogs/interaction.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[2];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: uniform sampler2D samp0;
 56: uniform sampler2D samp1;
 57: uniform sampler2D samp2;
 58: uniform sampler2D samp3;
 59: uniform sampler2D samp4;
 60: 
 61: in vec4 vofi_TexCoord0;
 62: in vec4 vofi_TexCoord1;
 63: in vec4 vofi_TexCoord2;
 64: in vec4 vofi_TexCoord3;
 65: in vec4 vofi_TexCoord4;
 66: in vec4 vofi_TexCoord5;
 67: in vec4 vofi_TexCoord6;
 68: in vec4 vofi_Color;
 69: 
 70: out vec4 fo_FragColor;
 71: 
 72: void main() {
 73: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 74: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 75: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 76: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 77: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 78: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 79: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
 80: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
 81: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 82: 	vec3 localNormal ;
 83: 	localNormal. xy = bumpMap. wy - 0.5 ;
 84: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
 85: 	localNormal = normalize ( localNormal ) ;
 86: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
 87: 	float lambert = ldotN ;
 88: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
 89: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
 90: 	float metallic = specMapSRGB. g ;
 91: 	float roughness = specMapSRGB. r ;
 92: 	float glossiness = 1.0 - roughness ;
 93: 	vec3 dielectricColor = vec3 ( 0.04 ) ;
 94: 	vec3 baseColor = diffuseMap ;
 95: 	vec3 diffuseColor = baseColor * ( 1.0 - metallic ) ;
 96: 	vec3 specularColor = mix ( dielectricColor , baseColor , metallic ) ;
 97: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
 98: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
 99: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
100: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
101: 	vec3 reflectColor = specularColor * _fa_[1 /* rpSpecularModifier */] . rgb * 1.0 ;
102: 	float rr = roughness * roughness ;
103: 	float rrrr = rr * rr ;
104: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
105: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
106: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
107: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[0 /* rpDiffuseModifier */] . xyz ) ;
108: 	fo_FragColor . xyz = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb ;
109: 	fo_FragColor . w = 1.0 ;
110: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 28 with vertexShader interaction and fragmentShader interaction
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionAmbient.vs.hlsl
-----------------
  1: // filename renderprogs/interactionAmbient.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[18];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: 
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_Color;
 32: 
 33: void main() {
 34: 	vec4 normal = in_Normal * 2.0 - 1.0 ;
 35: 	vec4 tangent = in_Tangent * 2.0 - 1.0 ;
 36: 	vec3 binormal = cross ( normal. xyz , tangent. xyz ) * tangent. w ;
 37: 	gl_Position . x = dot4 ( in_Position , _va_[14 /* rpMVPmatrixX */] ) ;
 38: 	gl_Position . y = dot4 ( in_Position , _va_[15 /* rpMVPmatrixY */] ) ;
 39: 	gl_Position . z = dot4 ( in_Position , _va_[16 /* rpMVPmatrixZ */] ) ;
 40: 	gl_Position . w = dot4 ( in_Position , _va_[17 /* rpMVPmatrixW */] ) ;
 41: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 42: 	vec4 toLight = _va_[0 /* rpLocalLightOrigin */] - in_Position ;
 43: 	vofi_TexCoord1 = defaultTexCoord ;
 44: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 45: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 46: 	vofi_TexCoord2 = defaultTexCoord ;
 47: 	vofi_TexCoord2 . x = dot4 ( in_Position , _va_[5 /* rpLightFalloffS */] ) ;
 48: 	vofi_TexCoord3 . x = dot4 ( in_Position , _va_[2 /* rpLightProjectionS */] ) ;
 49: 	vofi_TexCoord3 . y = dot4 ( in_Position , _va_[3 /* rpLightProjectionT */] ) ;
 50: 	vofi_TexCoord3 . z = 0.0 ;
 51: 	vofi_TexCoord3 . w = dot4 ( in_Position , _va_[4 /* rpLightProjectionQ */] ) ;
 52: 	vofi_TexCoord4 = defaultTexCoord ;
 53: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 54: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 55: 	vofi_TexCoord5 = defaultTexCoord ;
 56: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
 57: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
 58: 	toLight = normalize ( toLight ) ;
 59: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - in_Position ) ;
 60: 	vec4 halfAngleVector = toLight + toView ;
 61: 	vofi_TexCoord6 . x = dot3 ( tangent , halfAngleVector ) ;
 62: 	vofi_TexCoord6 . y = dot3 ( binormal , halfAngleVector ) ;
 63: 	vofi_TexCoord6 . z = dot3 ( normal , halfAngleVector ) ;
 64: 	vofi_TexCoord6 . w = 1.0 ;
 65: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
 66: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionAmbient.ps.hlsl
-----------------
  1: // filename renderprogs/interactionAmbient.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[2];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: uniform sampler2D samp0;
 56: uniform sampler2D samp1;
 57: uniform sampler2D samp2;
 58: uniform sampler2D samp3;
 59: uniform sampler2D samp4;
 60: 
 61: in vec4 vofi_TexCoord1;
 62: in vec4 vofi_TexCoord2;
 63: in vec4 vofi_TexCoord3;
 64: in vec4 vofi_TexCoord4;
 65: in vec4 vofi_TexCoord5;
 66: in vec4 vofi_TexCoord6;
 67: in vec4 vofi_Color;
 68: 
 69: out vec4 fo_FragColor;
 70: 
 71: void main() {
 72: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 73: 	vec4 lightFalloff = idtex2Dproj ( samp3 , vofi_TexCoord2 ) ;
 74: 	vec4 lightProj = idtex2Dproj ( samp4 , vofi_TexCoord3 ) ;
 75: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 76: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 77: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 78: 	vec3 ambientLightVector = vec3 ( 0.5 , 9.5 - 0.385 , 0.8925 ) ;
 79: 	vec3 lightVector = normalize ( ambientLightVector ) ;
 80: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 81: 	vec3 localNormal ;
 82: 	localNormal. xy = bumpMap. wy - 0.5 ;
 83: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
 84: 	localNormal = normalize ( localNormal ) ;
 85: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
 86: 	float lambert = ldotN ;
 87: 	float specularPower = 10.0 ;
 88: 	float hDotN = dot3 ( normalize ( vofi_TexCoord6 . xyz ) , localNormal ) ;
 89: 	vec3 specularContribution = vec3 ( pow ( abs ( hDotN ) , specularPower ) ) ;
 90: 	vec3 diffuseColor = diffuseMap * ( _fa_[0 /* rpDiffuseModifier */] . xyz ) ;
 91: 	vec3 specularColor = specMap. xyz * specularContribution * ( _fa_[1 /* rpSpecularModifier */] . xyz ) ;
 92: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
 93: 	fo_FragColor . xyz = ( diffuseColor + specularColor ) * lightColor * vofi_Color . xyz ;
 94: 	fo_FragColor . w = 1.0 ;
 95: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 29 with vertexShader interactionAmbient and fragmentShader interactionAmbient
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionAmbient_skinned.vs.hlsl
-----------------
  1: // filename renderprogs/interactionAmbient_skinned.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[18];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 19: 
 20: in vec4 in_Position;
 21: in vec2 in_TexCoord;
 22: in vec4 in_Normal;
 23: in vec4 in_Tangent;
 24: in vec4 in_Color;
 25: in vec4 in_Color2;
 26: 
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_Color;
 34: 
 35: void main() {
 36: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 37: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 38: 	vec3 vBinormal = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 39: 	float w0 = in_Color2 . x ;
 40: 	float w1 = in_Color2 . y ;
 41: 	float w2 = in_Color2 . z ;
 42: 	float w3 = in_Color2 . w ;
 43: 	vec4 matX , matY , matZ ;
 44: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 45: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 46: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 47: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 48: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 49: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 50: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 51: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 52: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 53: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 54: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 55: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 56: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 57: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 58: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 59: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 60: 	vec3 normal ;
 61: 	normal. x = dot3 ( matX , vNormal ) ;
 62: 	normal. y = dot3 ( matY , vNormal ) ;
 63: 	normal. z = dot3 ( matZ , vNormal ) ;
 64: 	normal = normalize ( normal ) ;
 65: 	vec3 tangent ;
 66: 	tangent. x = dot3 ( matX , vTangent ) ;
 67: 	tangent. y = dot3 ( matY , vTangent ) ;
 68: 	tangent. z = dot3 ( matZ , vTangent ) ;
 69: 	tangent = normalize ( tangent ) ;
 70: 	vec3 binormal ;
 71: 	binormal. x = dot3 ( matX , vBinormal ) ;
 72: 	binormal. y = dot3 ( matY , vBinormal ) ;
 73: 	binormal. z = dot3 ( matZ , vBinormal ) ;
 74: 	binormal = normalize ( binormal ) ;
 75: 	vec4 modelPosition ;
 76: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 77: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 78: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 79: 	modelPosition. w = 1.0 ;
 80: 	gl_Position . x = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixX */] ) ;
 81: 	gl_Position . y = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixY */] ) ;
 82: 	gl_Position . z = dot4 ( modelPosition , _va_[16 /* rpMVPmatrixZ */] ) ;
 83: 	gl_Position . w = dot4 ( modelPosition , _va_[17 /* rpMVPmatrixW */] ) ;
 84: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 85: 	vec4 toLight = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 86: 	vofi_TexCoord1 = defaultTexCoord ;
 87: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 88: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 89: 	vofi_TexCoord2 = defaultTexCoord ;
 90: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 91: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 92: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 93: 	vofi_TexCoord3 . z = 0.0 ;
 94: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 95: 	vofi_TexCoord4 = defaultTexCoord ;
 96: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 97: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 98: 	vofi_TexCoord5 = defaultTexCoord ;
 99: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
100: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
101: 	toLight = normalize ( toLight ) ;
102: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
103: 	vec4 halfAngleVector = toLight + toView ;
104: 	vofi_TexCoord6 . x = dot3 ( tangent , halfAngleVector ) ;
105: 	vofi_TexCoord6 . y = dot3 ( binormal , halfAngleVector ) ;
106: 	vofi_TexCoord6 . z = dot3 ( normal , halfAngleVector ) ;
107: 	vofi_TexCoord6 . w = 1.0 ;
108: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
109: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionAmbient_skinned.ps.hlsl
-----------------
  1: // filename renderprogs/interactionAmbient_skinned.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[2];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: uniform sampler2D samp0;
 56: uniform sampler2D samp1;
 57: uniform sampler2D samp2;
 58: uniform sampler2D samp3;
 59: uniform sampler2D samp4;
 60: 
 61: in vec4 vofi_TexCoord1;
 62: in vec4 vofi_TexCoord2;
 63: in vec4 vofi_TexCoord3;
 64: in vec4 vofi_TexCoord4;
 65: in vec4 vofi_TexCoord5;
 66: in vec4 vofi_TexCoord6;
 67: in vec4 vofi_Color;
 68: 
 69: out vec4 fo_FragColor;
 70: 
 71: void main() {
 72: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 73: 	vec4 lightFalloff = idtex2Dproj ( samp3 , vofi_TexCoord2 ) ;
 74: 	vec4 lightProj = idtex2Dproj ( samp4 , vofi_TexCoord3 ) ;
 75: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 76: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 77: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 78: 	vec3 ambientLightVector = vec3 ( 0.5 , 9.5 - 0.385 , 0.8925 ) ;
 79: 	vec3 lightVector = normalize ( ambientLightVector ) ;
 80: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
 81: 	vec3 localNormal ;
 82: 	localNormal. xy = bumpMap. wy - 0.5 ;
 83: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
 84: 	localNormal = normalize ( localNormal ) ;
 85: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
 86: 	float lambert = ldotN ;
 87: 	float specularPower = 10.0 ;
 88: 	float hDotN = dot3 ( normalize ( vofi_TexCoord6 . xyz ) , localNormal ) ;
 89: 	vec3 specularContribution = vec3 ( pow ( abs ( hDotN ) , specularPower ) ) ;
 90: 	vec3 diffuseColor = diffuseMap * ( _fa_[0 /* rpDiffuseModifier */] . xyz ) ;
 91: 	vec3 specularColor = specMap. xyz * specularContribution * ( _fa_[1 /* rpSpecularModifier */] . xyz ) ;
 92: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
 93: 	fo_FragColor . xyz = ( diffuseColor + specularColor ) * lightColor * vofi_Color . xyz ;
 94: 	fo_FragColor . w = 1.0 ;
 95: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 30 with vertexShader interactionAmbient_skinned and fragmentShader interactionAmbient_skinned
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[27];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_TexCoord7;
 34: out vec4 vofi_TexCoord8;
 35: out vec4 vofi_TexCoord9;
 36: out vec4 vofi_Color;
 37: 
 38: void main() {
 39: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 40: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 41: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 42: 	vec4 modelPosition = in_Position ;
 43: 	vec3 normal = vNormal. xyz ;
 44: 	vec3 tangent = vTangent. xyz ;
 45: 	vec3 bitangent = vBitangent. xyz ;
 46: 	gl_Position . x = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixX */] ) ;
 47: 	gl_Position . y = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixY */] ) ;
 48: 	gl_Position . z = dot4 ( modelPosition , _va_[16 /* rpMVPmatrixZ */] ) ;
 49: 	gl_Position . w = dot4 ( modelPosition , _va_[17 /* rpMVPmatrixW */] ) ;
 50: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 51: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 52: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 53: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 54: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 55: 	vofi_TexCoord0 . w = 1.0 ;
 56: 	vofi_TexCoord1 = defaultTexCoord ;
 57: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 58: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 59: 	vofi_TexCoord2 = defaultTexCoord ;
 60: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 61: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 62: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 63: 	vofi_TexCoord3 . z = 0.0 ;
 64: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 65: 	vofi_TexCoord4 = defaultTexCoord ;
 66: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 67: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 68: 	vofi_TexCoord5 = defaultTexCoord ;
 69: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
 70: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
 71: 	toLightLocal = normalize ( toLightLocal ) ;
 72: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
 73: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
 74: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
 75: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
 76: 	vofi_TexCoord6 . w = 1.0 ;
 77: 	vofi_TexCoord7 = modelPosition ;
 78: 	vec4 worldPosition ;
 79: 	worldPosition. x = dot4 ( modelPosition , _va_[18 /* rpModelMatrixX */] ) ;
 80: 	worldPosition. y = dot4 ( modelPosition , _va_[19 /* rpModelMatrixY */] ) ;
 81: 	worldPosition. z = dot4 ( modelPosition , _va_[20 /* rpModelMatrixZ */] ) ;
 82: 	worldPosition. w = dot4 ( modelPosition , _va_[21 /* rpModelMatrixW */] ) ;
 83: 	vec4 toLightGlobal = _va_[26 /* rpGlobalLightOrigin */] - worldPosition ;
 84: 	vofi_TexCoord8 = toLightGlobal ;
 85: 	vec4 viewPosition ;
 86: 	viewPosition. x = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixX */] ) ;
 87: 	viewPosition. y = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixY */] ) ;
 88: 	viewPosition. z = dot4 ( modelPosition , _va_[24 /* rpModelViewMatrixZ */] ) ;
 89: 	viewPosition. w = dot4 ( modelPosition , _va_[25 /* rpModelViewMatrixW */] ) ;
 90: 	vofi_TexCoord9 = viewPosition ;
 91: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
 92: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[30];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: const float c_goldenRatioConjugate = 0.61803398875;
 56: uniform sampler2D samp0;
 57: uniform sampler2D samp1;
 58: uniform sampler2D samp2;
 59: uniform sampler2D samp3;
 60: uniform sampler2D samp4;
 61: uniform sampler2DArrayShadow samp5;
 62: uniform sampler2D samp6;
 63: 
 64: in vec4 vofi_TexCoord0;
 65: in vec4 vofi_TexCoord1;
 66: in vec4 vofi_TexCoord2;
 67: in vec4 vofi_TexCoord3;
 68: in vec4 vofi_TexCoord4;
 69: in vec4 vofi_TexCoord5;
 70: in vec4 vofi_TexCoord6;
 71: in vec4 vofi_TexCoord7;
 72: in vec4 vofi_TexCoord8;
 73: in vec4 vofi_TexCoord9;
 74: in vec4 vofi_Color;
 75: 
 76: out vec4 fo_FragColor;
 77: 
 78: float BlueNoise (vec2 n , float x ) {
 79: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 80: 	float noise = texture ( samp6 , uv ). r ;
 81: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 82: 	return noise ;
 83: }
 84: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 85: 	float goldenAngle = 2.4 ;
 86: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 87: 	float theta = sampleIndex * goldenAngle + phi ;
 88: 	float sine = sin ( theta ) ;
 89: 	float cosine = cos ( theta ) ;
 90: 	return vec2 ( r * cosine , r * sine ) ;
 91: }
 92: void main() {
 93: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 94: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 95: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 96: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 97: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 98: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 99: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
100: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
101: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
102: 	vec3 localNormal ;
103: 	localNormal. xy = bumpMap. wy - 0.5 ;
104: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
105: 	localNormal = normalize ( localNormal ) ;
106: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
107: 	float lambert = ldotN ;
108: 	int shadowIndex = 0 ;
109: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 0 ) ] ;
110: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 1 ) ] ;
111: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 2 ) ] ;
112: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 3 ) ] ;
113: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
114: 	vec4 shadowTexcoord ;
115: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
116: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
117: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
118: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
119: 	float bias = 0.001 ;
120: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
121: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
122: 	shadowTexcoord. w = float ( shadowIndex ) ;
123: 	float shadow = 0.0 ;
124: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
125: 	float stepSize = 1.0 / numSamples ;
126: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
127: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
128: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
129: 	{
130: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
131: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
132: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
133: 	}
134: 	shadow *= stepSize ;
135: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
136: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
137: 	float metallic = specMapSRGB. g ;
138: 	float roughness = specMapSRGB. r ;
139: 	float glossiness = 1.0 - roughness ;
140: 	vec3 dielectricColor = vec3 ( 0.04 ) ;
141: 	vec3 baseColor = diffuseMap ;
142: 	vec3 diffuseColor = baseColor * ( 1.0 - metallic ) ;
143: 	vec3 specularColor = mix ( dielectricColor , baseColor , metallic ) ;
144: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
145: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
146: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
147: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
148: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
149: 	float rr = roughness * roughness ;
150: 	float rrrr = rr * rr ;
151: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
152: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
153: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
154: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
155: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
156: 	fo_FragColor . rgb = color ;
157: 	fo_FragColor . a = 1.0 ;
158: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 31 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[25];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_TexCoord7;
 32: out vec4 vofi_TexCoord8;
 33: out vec4 vofi_TexCoord9;
 34: out vec4 vofi_Color;
 35: 
 36: void main() {
 37: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 38: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 39: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 40: 	float w0 = in_Color2 . x ;
 41: 	float w1 = in_Color2 . y ;
 42: 	float w2 = in_Color2 . z ;
 43: 	float w3 = in_Color2 . w ;
 44: 	vec4 matX , matY , matZ ;
 45: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 46: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 47: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 48: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 49: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 50: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 51: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 52: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 53: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 54: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 55: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 56: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 57: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 58: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 59: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 60: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 61: 	vec3 normal ;
 62: 	normal. x = dot3 ( matX , vNormal ) ;
 63: 	normal. y = dot3 ( matY , vNormal ) ;
 64: 	normal. z = dot3 ( matZ , vNormal ) ;
 65: 	normal = normalize ( normal ) ;
 66: 	vec3 tangent ;
 67: 	tangent. x = dot3 ( matX , vTangent ) ;
 68: 	tangent. y = dot3 ( matY , vTangent ) ;
 69: 	tangent. z = dot3 ( matZ , vTangent ) ;
 70: 	tangent = normalize ( tangent ) ;
 71: 	vec3 bitangent ;
 72: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 73: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 74: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 75: 	bitangent = normalize ( bitangent ) ;
 76: 	vec4 modelPosition ;
 77: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 78: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 79: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 80: 	modelPosition. w = 1.0 ;
 81: 	gl_Position . x = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixX */] ) ;
 82: 	gl_Position . y = dot4 ( modelPosition , _va_[13 /* rpMVPmatrixY */] ) ;
 83: 	gl_Position . z = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixZ */] ) ;
 84: 	gl_Position . w = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixW */] ) ;
 85: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 86: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 87: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 88: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 89: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 90: 	vofi_TexCoord0 . w = 1.0 ;
 91: 	vofi_TexCoord1 = defaultTexCoord ;
 92: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 93: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 94: 	vofi_TexCoord2 = defaultTexCoord ;
 95: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 96: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 97: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 98: 	vofi_TexCoord3 . z = 0.0 ;
 99: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
100: 	vofi_TexCoord4 = defaultTexCoord ;
101: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
102: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
103: 	vofi_TexCoord5 = defaultTexCoord ;
104: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
105: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
106: 	toLightLocal = normalize ( toLightLocal ) ;
107: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
108: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
109: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
110: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
111: 	vofi_TexCoord6 . w = 1.0 ;
112: 	vofi_TexCoord7 = modelPosition ;
113: 	vec4 worldPosition ;
114: 	worldPosition. x = dot4 ( modelPosition , _va_[16 /* rpModelMatrixX */] ) ;
115: 	worldPosition. y = dot4 ( modelPosition , _va_[17 /* rpModelMatrixY */] ) ;
116: 	worldPosition. z = dot4 ( modelPosition , _va_[18 /* rpModelMatrixZ */] ) ;
117: 	worldPosition. w = dot4 ( modelPosition , _va_[19 /* rpModelMatrixW */] ) ;
118: 	vec4 toLightGlobal = _va_[24 /* rpGlobalLightOrigin */] - worldPosition ;
119: 	vofi_TexCoord8 = toLightGlobal ;
120: 	vec4 viewPosition ;
121: 	viewPosition. x = dot4 ( modelPosition , _va_[20 /* rpModelViewMatrixX */] ) ;
122: 	viewPosition. y = dot4 ( modelPosition , _va_[21 /* rpModelViewMatrixY */] ) ;
123: 	viewPosition. z = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixZ */] ) ;
124: 	viewPosition. w = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixW */] ) ;
125: 	vofi_TexCoord9 = viewPosition ;
126: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
127: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[30];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: const float c_goldenRatioConjugate = 0.61803398875;
 56: uniform sampler2D samp0;
 57: uniform sampler2D samp1;
 58: uniform sampler2D samp2;
 59: uniform sampler2D samp3;
 60: uniform sampler2D samp4;
 61: uniform sampler2DArrayShadow samp5;
 62: uniform sampler2D samp6;
 63: 
 64: in vec4 vofi_TexCoord0;
 65: in vec4 vofi_TexCoord1;
 66: in vec4 vofi_TexCoord2;
 67: in vec4 vofi_TexCoord3;
 68: in vec4 vofi_TexCoord4;
 69: in vec4 vofi_TexCoord5;
 70: in vec4 vofi_TexCoord6;
 71: in vec4 vofi_TexCoord7;
 72: in vec4 vofi_TexCoord8;
 73: in vec4 vofi_TexCoord9;
 74: in vec4 vofi_Color;
 75: 
 76: out vec4 fo_FragColor;
 77: 
 78: float BlueNoise (vec2 n , float x ) {
 79: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 80: 	float noise = texture ( samp6 , uv ). r ;
 81: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 82: 	return noise ;
 83: }
 84: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 85: 	float goldenAngle = 2.4 ;
 86: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 87: 	float theta = sampleIndex * goldenAngle + phi ;
 88: 	float sine = sin ( theta ) ;
 89: 	float cosine = cos ( theta ) ;
 90: 	return vec2 ( r * cosine , r * sine ) ;
 91: }
 92: void main() {
 93: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 94: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 95: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 96: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 97: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 98: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 99: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
100: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
101: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
102: 	vec3 localNormal ;
103: 	localNormal. xy = bumpMap. wy - 0.5 ;
104: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
105: 	localNormal = normalize ( localNormal ) ;
106: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
107: 	float lambert = ldotN ;
108: 	int shadowIndex = 0 ;
109: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 0 ) ] ;
110: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 1 ) ] ;
111: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 2 ) ] ;
112: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 3 ) ] ;
113: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
114: 	vec4 shadowTexcoord ;
115: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
116: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
117: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
118: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
119: 	float bias = 0.001 ;
120: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
121: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
122: 	shadowTexcoord. w = float ( shadowIndex ) ;
123: 	float shadow = 0.0 ;
124: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
125: 	float stepSize = 1.0 / numSamples ;
126: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
127: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
128: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
129: 	{
130: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
131: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
132: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
133: 	}
134: 	shadow *= stepSize ;
135: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
136: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
137: 	float metallic = specMapSRGB. g ;
138: 	float roughness = specMapSRGB. r ;
139: 	float glossiness = 1.0 - roughness ;
140: 	vec3 dielectricColor = vec3 ( 0.04 ) ;
141: 	vec3 baseColor = diffuseMap ;
142: 	vec3 diffuseColor = baseColor * ( 1.0 - metallic ) ;
143: 	vec3 specularColor = mix ( dielectricColor , baseColor , metallic ) ;
144: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
145: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
146: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
147: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
148: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
149: 	float rr = roughness * roughness ;
150: 	float rrrr = rr * rr ;
151: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
152: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
153: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
154: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
155: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
156: 	fo_FragColor . rgb = color ;
157: 	fo_FragColor . a = 1.0 ;
158: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 32 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[27];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_TexCoord7;
 34: out vec4 vofi_TexCoord8;
 35: out vec4 vofi_TexCoord9;
 36: out vec4 vofi_Color;
 37: 
 38: void main() {
 39: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 40: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 41: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 42: 	vec4 modelPosition = in_Position ;
 43: 	vec3 normal = vNormal. xyz ;
 44: 	vec3 tangent = vTangent. xyz ;
 45: 	vec3 bitangent = vBitangent. xyz ;
 46: 	gl_Position . x = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixX */] ) ;
 47: 	gl_Position . y = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixY */] ) ;
 48: 	gl_Position . z = dot4 ( modelPosition , _va_[16 /* rpMVPmatrixZ */] ) ;
 49: 	gl_Position . w = dot4 ( modelPosition , _va_[17 /* rpMVPmatrixW */] ) ;
 50: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 51: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 52: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 53: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 54: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 55: 	vofi_TexCoord0 . w = 1.0 ;
 56: 	vofi_TexCoord1 = defaultTexCoord ;
 57: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 58: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 59: 	vofi_TexCoord2 = defaultTexCoord ;
 60: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 61: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 62: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 63: 	vofi_TexCoord3 . z = 0.0 ;
 64: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 65: 	vofi_TexCoord4 = defaultTexCoord ;
 66: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 67: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 68: 	vofi_TexCoord5 = defaultTexCoord ;
 69: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
 70: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
 71: 	toLightLocal = normalize ( toLightLocal ) ;
 72: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
 73: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
 74: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
 75: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
 76: 	vofi_TexCoord6 . w = 1.0 ;
 77: 	vofi_TexCoord7 = modelPosition ;
 78: 	vec4 worldPosition ;
 79: 	worldPosition. x = dot4 ( modelPosition , _va_[18 /* rpModelMatrixX */] ) ;
 80: 	worldPosition. y = dot4 ( modelPosition , _va_[19 /* rpModelMatrixY */] ) ;
 81: 	worldPosition. z = dot4 ( modelPosition , _va_[20 /* rpModelMatrixZ */] ) ;
 82: 	worldPosition. w = dot4 ( modelPosition , _va_[21 /* rpModelMatrixW */] ) ;
 83: 	vec4 toLightGlobal = _va_[26 /* rpGlobalLightOrigin */] - worldPosition ;
 84: 	vofi_TexCoord8 = toLightGlobal ;
 85: 	vec4 viewPosition ;
 86: 	viewPosition. x = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixX */] ) ;
 87: 	viewPosition. y = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixY */] ) ;
 88: 	viewPosition. z = dot4 ( modelPosition , _va_[24 /* rpModelViewMatrixZ */] ) ;
 89: 	viewPosition. w = dot4 ( modelPosition , _va_[25 /* rpModelViewMatrixW */] ) ;
 90: 	vofi_TexCoord9 = viewPosition ;
 91: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
 92: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[30];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: const float c_goldenRatioConjugate = 0.61803398875;
 56: uniform sampler2D samp0;
 57: uniform sampler2D samp1;
 58: uniform sampler2D samp2;
 59: uniform sampler2D samp3;
 60: uniform sampler2D samp4;
 61: uniform sampler2DArrayShadow samp5;
 62: uniform sampler2D samp6;
 63: 
 64: in vec4 vofi_TexCoord0;
 65: in vec4 vofi_TexCoord1;
 66: in vec4 vofi_TexCoord2;
 67: in vec4 vofi_TexCoord3;
 68: in vec4 vofi_TexCoord4;
 69: in vec4 vofi_TexCoord5;
 70: in vec4 vofi_TexCoord6;
 71: in vec4 vofi_TexCoord7;
 72: in vec4 vofi_TexCoord8;
 73: in vec4 vofi_TexCoord9;
 74: in vec4 vofi_Color;
 75: 
 76: out vec4 fo_FragColor;
 77: 
 78: float BlueNoise (vec2 n , float x ) {
 79: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 80: 	float noise = texture ( samp6 , uv ). r ;
 81: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 82: 	return noise ;
 83: }
 84: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 85: 	float goldenAngle = 2.4 ;
 86: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 87: 	float theta = sampleIndex * goldenAngle + phi ;
 88: 	float sine = sin ( theta ) ;
 89: 	float cosine = cos ( theta ) ;
 90: 	return vec2 ( r * cosine , r * sine ) ;
 91: }
 92: void main() {
 93: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 94: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 95: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 96: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 97: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 98: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 99: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
100: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
101: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
102: 	vec3 localNormal ;
103: 	localNormal. xy = bumpMap. wy - 0.5 ;
104: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
105: 	localNormal = normalize ( localNormal ) ;
106: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
107: 	float lambert = ldotN ;
108: 	int shadowIndex = 0 ;
109: 	vec3 toLightGlobal = normalize ( vofi_TexCoord8 . xyz ) ;
110: 	float axis [ 6 ] ;
111: 	axis [ 0 ] = - toLightGlobal. x ;
112: 	axis [ 1 ] = toLightGlobal. x ;
113: 	axis [ 2 ] = - toLightGlobal. y ;
114: 	axis [ 3 ] = toLightGlobal. y ;
115: 	axis [ 4 ] = - toLightGlobal. z ;
116: 	axis [ 5 ] = toLightGlobal. z ;
117: 	for ( int i = 0 ; i < 6 ; i ++ )
118: 	{
119: 		if ( axis [ i ] > axis [ shadowIndex ] )
120: 		{
121: 			shadowIndex = i ;
122: 		}
123: 	}
124: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 0 ) ] ;
125: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 1 ) ] ;
126: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 2 ) ] ;
127: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 3 ) ] ;
128: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
129: 	vec4 shadowTexcoord ;
130: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
131: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
132: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
133: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
134: 	float bias = 0.001 ;
135: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
136: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
137: 	shadowTexcoord. w = float ( shadowIndex ) ;
138: 	float shadow = 0.0 ;
139: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
140: 	float stepSize = 1.0 / numSamples ;
141: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
142: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
143: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
144: 	{
145: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
146: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
147: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
148: 	}
149: 	shadow *= stepSize ;
150: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
151: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
152: 	float metallic = specMapSRGB. g ;
153: 	float roughness = specMapSRGB. r ;
154: 	float glossiness = 1.0 - roughness ;
155: 	vec3 dielectricColor = vec3 ( 0.04 ) ;
156: 	vec3 baseColor = diffuseMap ;
157: 	vec3 diffuseColor = baseColor * ( 1.0 - metallic ) ;
158: 	vec3 specularColor = mix ( dielectricColor , baseColor , metallic ) ;
159: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
160: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
161: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
162: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
163: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
164: 	float rr = roughness * roughness ;
165: 	float rrrr = rr * rr ;
166: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
167: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
168: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
169: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
170: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
171: 	fo_FragColor . rgb = color ;
172: 	fo_FragColor . a = 1.0 ;
173: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 33 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[25];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_TexCoord7;
 32: out vec4 vofi_TexCoord8;
 33: out vec4 vofi_TexCoord9;
 34: out vec4 vofi_Color;
 35: 
 36: void main() {
 37: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 38: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 39: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 40: 	float w0 = in_Color2 . x ;
 41: 	float w1 = in_Color2 . y ;
 42: 	float w2 = in_Color2 . z ;
 43: 	float w3 = in_Color2 . w ;
 44: 	vec4 matX , matY , matZ ;
 45: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 46: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 47: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 48: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 49: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 50: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 51: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 52: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 53: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 54: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 55: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 56: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 57: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 58: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 59: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 60: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 61: 	vec3 normal ;
 62: 	normal. x = dot3 ( matX , vNormal ) ;
 63: 	normal. y = dot3 ( matY , vNormal ) ;
 64: 	normal. z = dot3 ( matZ , vNormal ) ;
 65: 	normal = normalize ( normal ) ;
 66: 	vec3 tangent ;
 67: 	tangent. x = dot3 ( matX , vTangent ) ;
 68: 	tangent. y = dot3 ( matY , vTangent ) ;
 69: 	tangent. z = dot3 ( matZ , vTangent ) ;
 70: 	tangent = normalize ( tangent ) ;
 71: 	vec3 bitangent ;
 72: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 73: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 74: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 75: 	bitangent = normalize ( bitangent ) ;
 76: 	vec4 modelPosition ;
 77: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 78: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 79: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 80: 	modelPosition. w = 1.0 ;
 81: 	gl_Position . x = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixX */] ) ;
 82: 	gl_Position . y = dot4 ( modelPosition , _va_[13 /* rpMVPmatrixY */] ) ;
 83: 	gl_Position . z = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixZ */] ) ;
 84: 	gl_Position . w = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixW */] ) ;
 85: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 86: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 87: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 88: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 89: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 90: 	vofi_TexCoord0 . w = 1.0 ;
 91: 	vofi_TexCoord1 = defaultTexCoord ;
 92: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 93: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 94: 	vofi_TexCoord2 = defaultTexCoord ;
 95: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 96: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 97: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 98: 	vofi_TexCoord3 . z = 0.0 ;
 99: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
100: 	vofi_TexCoord4 = defaultTexCoord ;
101: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
102: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
103: 	vofi_TexCoord5 = defaultTexCoord ;
104: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
105: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
106: 	toLightLocal = normalize ( toLightLocal ) ;
107: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
108: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
109: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
110: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
111: 	vofi_TexCoord6 . w = 1.0 ;
112: 	vofi_TexCoord7 = modelPosition ;
113: 	vec4 worldPosition ;
114: 	worldPosition. x = dot4 ( modelPosition , _va_[16 /* rpModelMatrixX */] ) ;
115: 	worldPosition. y = dot4 ( modelPosition , _va_[17 /* rpModelMatrixY */] ) ;
116: 	worldPosition. z = dot4 ( modelPosition , _va_[18 /* rpModelMatrixZ */] ) ;
117: 	worldPosition. w = dot4 ( modelPosition , _va_[19 /* rpModelMatrixW */] ) ;
118: 	vec4 toLightGlobal = _va_[24 /* rpGlobalLightOrigin */] - worldPosition ;
119: 	vofi_TexCoord8 = toLightGlobal ;
120: 	vec4 viewPosition ;
121: 	viewPosition. x = dot4 ( modelPosition , _va_[20 /* rpModelViewMatrixX */] ) ;
122: 	viewPosition. y = dot4 ( modelPosition , _va_[21 /* rpModelViewMatrixY */] ) ;
123: 	viewPosition. z = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixZ */] ) ;
124: 	viewPosition. w = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixW */] ) ;
125: 	vofi_TexCoord9 = viewPosition ;
126: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
127: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[30];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: const float c_goldenRatioConjugate = 0.61803398875;
 56: uniform sampler2D samp0;
 57: uniform sampler2D samp1;
 58: uniform sampler2D samp2;
 59: uniform sampler2D samp3;
 60: uniform sampler2D samp4;
 61: uniform sampler2DArrayShadow samp5;
 62: uniform sampler2D samp6;
 63: 
 64: in vec4 vofi_TexCoord0;
 65: in vec4 vofi_TexCoord1;
 66: in vec4 vofi_TexCoord2;
 67: in vec4 vofi_TexCoord3;
 68: in vec4 vofi_TexCoord4;
 69: in vec4 vofi_TexCoord5;
 70: in vec4 vofi_TexCoord6;
 71: in vec4 vofi_TexCoord7;
 72: in vec4 vofi_TexCoord8;
 73: in vec4 vofi_TexCoord9;
 74: in vec4 vofi_Color;
 75: 
 76: out vec4 fo_FragColor;
 77: 
 78: float BlueNoise (vec2 n , float x ) {
 79: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 80: 	float noise = texture ( samp6 , uv ). r ;
 81: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 82: 	return noise ;
 83: }
 84: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 85: 	float goldenAngle = 2.4 ;
 86: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 87: 	float theta = sampleIndex * goldenAngle + phi ;
 88: 	float sine = sin ( theta ) ;
 89: 	float cosine = cos ( theta ) ;
 90: 	return vec2 ( r * cosine , r * sine ) ;
 91: }
 92: void main() {
 93: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 94: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 95: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 96: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 97: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 98: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 99: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
100: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
101: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
102: 	vec3 localNormal ;
103: 	localNormal. xy = bumpMap. wy - 0.5 ;
104: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
105: 	localNormal = normalize ( localNormal ) ;
106: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
107: 	float lambert = ldotN ;
108: 	int shadowIndex = 0 ;
109: 	vec3 toLightGlobal = normalize ( vofi_TexCoord8 . xyz ) ;
110: 	float axis [ 6 ] ;
111: 	axis [ 0 ] = - toLightGlobal. x ;
112: 	axis [ 1 ] = toLightGlobal. x ;
113: 	axis [ 2 ] = - toLightGlobal. y ;
114: 	axis [ 3 ] = toLightGlobal. y ;
115: 	axis [ 4 ] = - toLightGlobal. z ;
116: 	axis [ 5 ] = toLightGlobal. z ;
117: 	for ( int i = 0 ; i < 6 ; i ++ )
118: 	{
119: 		if ( axis [ i ] > axis [ shadowIndex ] )
120: 		{
121: 			shadowIndex = i ;
122: 		}
123: 	}
124: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 0 ) ] ;
125: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 1 ) ] ;
126: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 2 ) ] ;
127: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 5 + int ( shadowIndex * 4 + 3 ) ] ;
128: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
129: 	vec4 shadowTexcoord ;
130: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
131: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
132: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
133: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
134: 	float bias = 0.001 ;
135: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
136: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
137: 	shadowTexcoord. w = float ( shadowIndex ) ;
138: 	float shadow = 0.0 ;
139: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
140: 	float stepSize = 1.0 / numSamples ;
141: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
142: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
143: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
144: 	{
145: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
146: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
147: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
148: 	}
149: 	shadow *= stepSize ;
150: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
151: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
152: 	float metallic = specMapSRGB. g ;
153: 	float roughness = specMapSRGB. r ;
154: 	float glossiness = 1.0 - roughness ;
155: 	vec3 dielectricColor = vec3 ( 0.04 ) ;
156: 	vec3 baseColor = diffuseMap ;
157: 	vec3 diffuseColor = baseColor * ( 1.0 - metallic ) ;
158: 	vec3 specularColor = mix ( dielectricColor , baseColor , metallic ) ;
159: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
160: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
161: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
162: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
163: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
164: 	float rr = roughness * roughness ;
165: 	float rrrr = rr * rr ;
166: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
167: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
168: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
169: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
170: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
171: 	fo_FragColor . rgb = color ;
172: 	fo_FragColor . a = 1.0 ;
173: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 34 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[27];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: in vec4 in_Color2;
 25: 
 26: out vec4 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: out vec4 vofi_TexCoord5;
 32: out vec4 vofi_TexCoord6;
 33: out vec4 vofi_TexCoord7;
 34: out vec4 vofi_TexCoord8;
 35: out vec4 vofi_TexCoord9;
 36: out vec4 vofi_Color;
 37: 
 38: void main() {
 39: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 40: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 41: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 42: 	vec4 modelPosition = in_Position ;
 43: 	vec3 normal = vNormal. xyz ;
 44: 	vec3 tangent = vTangent. xyz ;
 45: 	vec3 bitangent = vBitangent. xyz ;
 46: 	gl_Position . x = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixX */] ) ;
 47: 	gl_Position . y = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixY */] ) ;
 48: 	gl_Position . z = dot4 ( modelPosition , _va_[16 /* rpMVPmatrixZ */] ) ;
 49: 	gl_Position . w = dot4 ( modelPosition , _va_[17 /* rpMVPmatrixW */] ) ;
 50: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 51: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 52: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 53: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 54: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 55: 	vofi_TexCoord0 . w = 1.0 ;
 56: 	vofi_TexCoord1 = defaultTexCoord ;
 57: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 58: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 59: 	vofi_TexCoord2 = defaultTexCoord ;
 60: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 61: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 62: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 63: 	vofi_TexCoord3 . z = 0.0 ;
 64: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
 65: 	vofi_TexCoord4 = defaultTexCoord ;
 66: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
 67: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
 68: 	vofi_TexCoord5 = defaultTexCoord ;
 69: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
 70: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
 71: 	toLightLocal = normalize ( toLightLocal ) ;
 72: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
 73: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
 74: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
 75: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
 76: 	vofi_TexCoord6 . w = 1.0 ;
 77: 	vofi_TexCoord7 = modelPosition ;
 78: 	vec4 worldPosition ;
 79: 	worldPosition. x = dot4 ( modelPosition , _va_[18 /* rpModelMatrixX */] ) ;
 80: 	worldPosition. y = dot4 ( modelPosition , _va_[19 /* rpModelMatrixY */] ) ;
 81: 	worldPosition. z = dot4 ( modelPosition , _va_[20 /* rpModelMatrixZ */] ) ;
 82: 	worldPosition. w = dot4 ( modelPosition , _va_[21 /* rpModelMatrixW */] ) ;
 83: 	vec4 toLightGlobal = _va_[26 /* rpGlobalLightOrigin */] - worldPosition ;
 84: 	vofi_TexCoord8 = toLightGlobal ;
 85: 	vec4 viewPosition ;
 86: 	viewPosition. x = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixX */] ) ;
 87: 	viewPosition. y = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixY */] ) ;
 88: 	viewPosition. z = dot4 ( modelPosition , _va_[24 /* rpModelViewMatrixZ */] ) ;
 89: 	viewPosition. w = dot4 ( modelPosition , _va_[25 /* rpModelViewMatrixW */] ) ;
 90: 	vofi_TexCoord9 = viewPosition ;
 91: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[12 /* rpVertexColorModulate */] ) + _va_[13 /* rpVertexColorAdd */] ;
 92: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[31];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: const float c_goldenRatioConjugate = 0.61803398875;
 56: uniform sampler2D samp0;
 57: uniform sampler2D samp1;
 58: uniform sampler2D samp2;
 59: uniform sampler2D samp3;
 60: uniform sampler2D samp4;
 61: uniform sampler2DArrayShadow samp5;
 62: uniform sampler2D samp6;
 63: 
 64: in vec4 vofi_TexCoord0;
 65: in vec4 vofi_TexCoord1;
 66: in vec4 vofi_TexCoord2;
 67: in vec4 vofi_TexCoord3;
 68: in vec4 vofi_TexCoord4;
 69: in vec4 vofi_TexCoord5;
 70: in vec4 vofi_TexCoord6;
 71: in vec4 vofi_TexCoord7;
 72: in vec4 vofi_TexCoord8;
 73: in vec4 vofi_TexCoord9;
 74: in vec4 vofi_Color;
 75: 
 76: out vec4 fo_FragColor;
 77: 
 78: float BlueNoise (vec2 n , float x ) {
 79: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 80: 	float noise = texture ( samp6 , uv ). r ;
 81: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 82: 	return noise ;
 83: }
 84: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 85: 	float goldenAngle = 2.4 ;
 86: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 87: 	float theta = sampleIndex * goldenAngle + phi ;
 88: 	float sine = sin ( theta ) ;
 89: 	float cosine = cos ( theta ) ;
 90: 	return vec2 ( r * cosine , r * sine ) ;
 91: }
 92: void main() {
 93: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 94: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 95: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 96: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 97: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 98: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 99: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
100: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
101: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
102: 	vec3 localNormal ;
103: 	localNormal. xy = bumpMap. wy - 0.5 ;
104: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
105: 	localNormal = normalize ( localNormal ) ;
106: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
107: 	float lambert = ldotN ;
108: 	int shadowIndex = 0 ;
109: 	float viewZ = - vofi_TexCoord9 . z ;
110: 	shadowIndex = 4 ;
111: 	for ( int i = 0 ; i < 4 ; i ++ )
112: 	{
113: 		if ( viewZ < _fa_[5 /* rpCascadeDistances */] [ i ] )
114: 		{
115: 			shadowIndex = i ;
116: 			break ;
117: 		}
118: 	}
119: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 0 ) ] ;
120: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 1 ) ] ;
121: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 2 ) ] ;
122: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 3 ) ] ;
123: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
124: 	vec4 shadowTexcoord ;
125: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
126: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
127: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
128: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
129: 	float bias = 0.001 ;
130: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
131: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
132: 	shadowTexcoord. w = float ( shadowIndex ) ;
133: 	float shadow = 0.0 ;
134: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
135: 	float stepSize = 1.0 / numSamples ;
136: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
137: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
138: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
139: 	{
140: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
141: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
142: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
143: 	}
144: 	shadow *= stepSize ;
145: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
146: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
147: 	float metallic = specMapSRGB. g ;
148: 	float roughness = specMapSRGB. r ;
149: 	float glossiness = 1.0 - roughness ;
150: 	vec3 dielectricColor = vec3 ( 0.04 ) ;
151: 	vec3 baseColor = diffuseMap ;
152: 	vec3 diffuseColor = baseColor * ( 1.0 - metallic ) ;
153: 	vec3 specularColor = mix ( dielectricColor , baseColor , metallic ) ;
154: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
155: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
156: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
157: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
158: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
159: 	float rr = roughness * roughness ;
160: 	float rrrr = rr * rr ;
161: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
162: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
163: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
164: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
165: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
166: 	fo_FragColor . rgb = color ;
167: 	fo_FragColor . a = 1.0 ;
168: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 35 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/interactionSM.vs.hlsl
-----------------
  1: // filename renderprogs/interactionSM.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[25];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec4 vofi_TexCoord0;
 25: out vec4 vofi_TexCoord1;
 26: out vec4 vofi_TexCoord2;
 27: out vec4 vofi_TexCoord3;
 28: out vec4 vofi_TexCoord4;
 29: out vec4 vofi_TexCoord5;
 30: out vec4 vofi_TexCoord6;
 31: out vec4 vofi_TexCoord7;
 32: out vec4 vofi_TexCoord8;
 33: out vec4 vofi_TexCoord9;
 34: out vec4 vofi_Color;
 35: 
 36: void main() {
 37: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 38: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 39: 	vec3 vBitangent = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 40: 	float w0 = in_Color2 . x ;
 41: 	float w1 = in_Color2 . y ;
 42: 	float w2 = in_Color2 . z ;
 43: 	float w3 = in_Color2 . w ;
 44: 	vec4 matX , matY , matZ ;
 45: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 46: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 47: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 48: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 49: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 50: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 51: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 52: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 53: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 54: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 55: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 56: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 57: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 58: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 59: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 60: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 61: 	vec3 normal ;
 62: 	normal. x = dot3 ( matX , vNormal ) ;
 63: 	normal. y = dot3 ( matY , vNormal ) ;
 64: 	normal. z = dot3 ( matZ , vNormal ) ;
 65: 	normal = normalize ( normal ) ;
 66: 	vec3 tangent ;
 67: 	tangent. x = dot3 ( matX , vTangent ) ;
 68: 	tangent. y = dot3 ( matY , vTangent ) ;
 69: 	tangent. z = dot3 ( matZ , vTangent ) ;
 70: 	tangent = normalize ( tangent ) ;
 71: 	vec3 bitangent ;
 72: 	bitangent. x = dot3 ( matX , vBitangent ) ;
 73: 	bitangent. y = dot3 ( matY , vBitangent ) ;
 74: 	bitangent. z = dot3 ( matZ , vBitangent ) ;
 75: 	bitangent = normalize ( bitangent ) ;
 76: 	vec4 modelPosition ;
 77: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 78: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 79: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 80: 	modelPosition. w = 1.0 ;
 81: 	gl_Position . x = dot4 ( modelPosition , _va_[12 /* rpMVPmatrixX */] ) ;
 82: 	gl_Position . y = dot4 ( modelPosition , _va_[13 /* rpMVPmatrixY */] ) ;
 83: 	gl_Position . z = dot4 ( modelPosition , _va_[14 /* rpMVPmatrixZ */] ) ;
 84: 	gl_Position . w = dot4 ( modelPosition , _va_[15 /* rpMVPmatrixW */] ) ;
 85: 	vec4 defaultTexCoord = vec4 ( 0.0 , 0.5 , 0.0 , 1.0 ) ;
 86: 	vec4 toLightLocal = _va_[0 /* rpLocalLightOrigin */] - modelPosition ;
 87: 	vofi_TexCoord0 . x = dot3 ( tangent , toLightLocal ) ;
 88: 	vofi_TexCoord0 . y = dot3 ( bitangent , toLightLocal ) ;
 89: 	vofi_TexCoord0 . z = dot3 ( normal , toLightLocal ) ;
 90: 	vofi_TexCoord0 . w = 1.0 ;
 91: 	vofi_TexCoord1 = defaultTexCoord ;
 92: 	vofi_TexCoord1 . x = dot4 ( in_TexCoord . xy , _va_[6 /* rpBumpMatrixS */] ) ;
 93: 	vofi_TexCoord1 . y = dot4 ( in_TexCoord . xy , _va_[7 /* rpBumpMatrixT */] ) ;
 94: 	vofi_TexCoord2 = defaultTexCoord ;
 95: 	vofi_TexCoord2 . x = dot4 ( modelPosition , _va_[5 /* rpLightFalloffS */] ) ;
 96: 	vofi_TexCoord3 . x = dot4 ( modelPosition , _va_[2 /* rpLightProjectionS */] ) ;
 97: 	vofi_TexCoord3 . y = dot4 ( modelPosition , _va_[3 /* rpLightProjectionT */] ) ;
 98: 	vofi_TexCoord3 . z = 0.0 ;
 99: 	vofi_TexCoord3 . w = dot4 ( modelPosition , _va_[4 /* rpLightProjectionQ */] ) ;
100: 	vofi_TexCoord4 = defaultTexCoord ;
101: 	vofi_TexCoord4 . x = dot4 ( in_TexCoord . xy , _va_[8 /* rpDiffuseMatrixS */] ) ;
102: 	vofi_TexCoord4 . y = dot4 ( in_TexCoord . xy , _va_[9 /* rpDiffuseMatrixT */] ) ;
103: 	vofi_TexCoord5 = defaultTexCoord ;
104: 	vofi_TexCoord5 . x = dot4 ( in_TexCoord . xy , _va_[10 /* rpSpecularMatrixS */] ) ;
105: 	vofi_TexCoord5 . y = dot4 ( in_TexCoord . xy , _va_[11 /* rpSpecularMatrixT */] ) ;
106: 	toLightLocal = normalize ( toLightLocal ) ;
107: 	vec4 toView = normalize ( _va_[1 /* rpLocalViewOrigin */] - modelPosition ) ;
108: 	vofi_TexCoord6 . x = dot3 ( tangent , toView ) ;
109: 	vofi_TexCoord6 . y = dot3 ( bitangent , toView ) ;
110: 	vofi_TexCoord6 . z = dot3 ( normal , toView ) ;
111: 	vofi_TexCoord6 . w = 1.0 ;
112: 	vofi_TexCoord7 = modelPosition ;
113: 	vec4 worldPosition ;
114: 	worldPosition. x = dot4 ( modelPosition , _va_[16 /* rpModelMatrixX */] ) ;
115: 	worldPosition. y = dot4 ( modelPosition , _va_[17 /* rpModelMatrixY */] ) ;
116: 	worldPosition. z = dot4 ( modelPosition , _va_[18 /* rpModelMatrixZ */] ) ;
117: 	worldPosition. w = dot4 ( modelPosition , _va_[19 /* rpModelMatrixW */] ) ;
118: 	vec4 toLightGlobal = _va_[24 /* rpGlobalLightOrigin */] - worldPosition ;
119: 	vofi_TexCoord8 = toLightGlobal ;
120: 	vec4 viewPosition ;
121: 	viewPosition. x = dot4 ( modelPosition , _va_[20 /* rpModelViewMatrixX */] ) ;
122: 	viewPosition. y = dot4 ( modelPosition , _va_[21 /* rpModelViewMatrixY */] ) ;
123: 	viewPosition. z = dot4 ( modelPosition , _va_[22 /* rpModelViewMatrixZ */] ) ;
124: 	viewPosition. w = dot4 ( modelPosition , _va_[23 /* rpModelViewMatrixW */] ) ;
125: 	vofi_TexCoord9 = viewPosition ;
126: 	vofi_Color = vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ;
127: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/interactionSM.ps.hlsl
-----------------
  1: // filename renderprogs/interactionSM.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[31];
 18: 
 19: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 20: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 21: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 22: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 23: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 24: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 25: float Linear1 (float c ) {
 26: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 27: }
 28: vec3 Linear3 (vec3 c ) {
 29: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 30: }
 31: vec3 sRGBToLinearRGB (vec3 c ) {
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	return Linear3 ( c ) ;
 34: }
 35: vec4 sRGBAToLinearRGBA (vec4 c ) {
 36: 	c = clamp ( c , 0.0 , 1.0 ) ;
 37: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 38: }
 39: const vec4 matrixCoCg1YtoRGB1X = vec4( 1.0, -1.0, 0.0, 1.0 );
 40: const vec4 matrixCoCg1YtoRGB1Y = vec4( 0.0, 1.0, -0.50196078, 1.0 );
 41: const vec4 matrixCoCg1YtoRGB1Z = vec4( -1.0, -1.0, 1.00392156, 1.0 );
 42: vec3 ConvertYCoCgToRGB (vec4 YCoCg ) {
 43: 	vec3 rgbColor ;
 44: 	YCoCg. z = ( YCoCg. z * 31.875 ) + 1.0 ;
 45: 	YCoCg. z = 1.0 / YCoCg. z ;
 46: 	YCoCg. xy *= YCoCg. z ;
 47: 	rgbColor. x = dot4 ( YCoCg , matrixCoCg1YtoRGB1X ) ;
 48: 	rgbColor. y = dot4 ( YCoCg , matrixCoCg1YtoRGB1Y ) ;
 49: 	rgbColor. z = dot4 ( YCoCg , matrixCoCg1YtoRGB1Z ) ;
 50: 	return rgbColor ;
 51: }
 52: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 53: 	return textureProj ( samp , texCoords. xyw ) ;
 54: }
 55: const float c_goldenRatioConjugate = 0.61803398875;
 56: uniform sampler2D samp0;
 57: uniform sampler2D samp1;
 58: uniform sampler2D samp2;
 59: uniform sampler2D samp3;
 60: uniform sampler2D samp4;
 61: uniform sampler2DArrayShadow samp5;
 62: uniform sampler2D samp6;
 63: 
 64: in vec4 vofi_TexCoord0;
 65: in vec4 vofi_TexCoord1;
 66: in vec4 vofi_TexCoord2;
 67: in vec4 vofi_TexCoord3;
 68: in vec4 vofi_TexCoord4;
 69: in vec4 vofi_TexCoord5;
 70: in vec4 vofi_TexCoord6;
 71: in vec4 vofi_TexCoord7;
 72: in vec4 vofi_TexCoord8;
 73: in vec4 vofi_TexCoord9;
 74: in vec4 vofi_Color;
 75: 
 76: out vec4 fo_FragColor;
 77: 
 78: float BlueNoise (vec2 n , float x ) {
 79: 	vec2 uv = n. xy * _fa_[4 /* rpJitterTexOffset */] . xy ;
 80: 	float noise = texture ( samp6 , uv ). r ;
 81: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[4 /* rpJitterTexOffset */] . w * x ) ;
 82: 	return noise ;
 83: }
 84: vec2 VogelDiskSample (float sampleIndex , float samplesCount , float phi ) {
 85: 	float goldenAngle = 2.4 ;
 86: 	float r = sqrt ( sampleIndex + 0.5 ) / sqrt ( samplesCount ) ;
 87: 	float theta = sampleIndex * goldenAngle + phi ;
 88: 	float sine = sin ( theta ) ;
 89: 	float cosine = cos ( theta ) ;
 90: 	return vec2 ( r * cosine , r * sine ) ;
 91: }
 92: void main() {
 93: 	vec4 bumpMap = texture ( samp0 , vofi_TexCoord1 . xy ) ;
 94: 	vec4 lightFalloff = ( idtex2Dproj ( samp3 , vofi_TexCoord2 ) ) ;
 95: 	vec4 lightProj = ( idtex2Dproj ( samp4 , vofi_TexCoord3 ) ) ;
 96: 	vec4 YCoCG = texture ( samp2 , vofi_TexCoord4 . xy ) ;
 97: 	vec4 specMapSRGB = texture ( samp1 , vofi_TexCoord5 . xy ) ;
 98: 	vec4 specMap = sRGBAToLinearRGBA ( specMapSRGB ) ;
 99: 	vec3 lightVector = normalize ( vofi_TexCoord0 . xyz ) ;
100: 	vec3 viewVector = normalize ( vofi_TexCoord6 . xyz ) ;
101: 	vec3 diffuseMap = sRGBToLinearRGB ( ConvertYCoCgToRGB ( YCoCG ) ) ;
102: 	vec3 localNormal ;
103: 	localNormal. xy = bumpMap. wy - 0.5 ;
104: 	localNormal. z = sqrt ( abs ( dot ( localNormal. xy , localNormal. xy ) - 0.25 ) ) ;
105: 	localNormal = normalize ( localNormal ) ;
106: 	float ldotN = saturate ( dot3 ( localNormal , lightVector ) ) ;
107: 	float lambert = ldotN ;
108: 	int shadowIndex = 0 ;
109: 	float viewZ = - vofi_TexCoord9 . z ;
110: 	shadowIndex = 4 ;
111: 	for ( int i = 0 ; i < 4 ; i ++ )
112: 	{
113: 		if ( viewZ < _fa_[5 /* rpCascadeDistances */] [ i ] )
114: 		{
115: 			shadowIndex = i ;
116: 			break ;
117: 		}
118: 	}
119: 	vec4 shadowMatrixX = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 0 ) ] ;
120: 	vec4 shadowMatrixY = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 1 ) ] ;
121: 	vec4 shadowMatrixZ = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 2 ) ] ;
122: 	vec4 shadowMatrixW = _fa_[/* rpShadowMatrices */ 6 + int ( shadowIndex * 4 + 3 ) ] ;
123: 	vec4 modelPosition = vec4 ( vofi_TexCoord7 . xyz , 1.0 ) ;
124: 	vec4 shadowTexcoord ;
125: 	shadowTexcoord. x = dot4 ( modelPosition , shadowMatrixX ) ;
126: 	shadowTexcoord. y = dot4 ( modelPosition , shadowMatrixY ) ;
127: 	shadowTexcoord. z = dot4 ( modelPosition , shadowMatrixZ ) ;
128: 	shadowTexcoord. w = dot4 ( modelPosition , shadowMatrixW ) ;
129: 	float bias = 0.001 ;
130: 	shadowTexcoord. xyz /= shadowTexcoord. w ;
131: 	shadowTexcoord. z = shadowTexcoord. z * _fa_[0 /* rpScreenCorrectionFactor */] . w ;
132: 	shadowTexcoord. w = float ( shadowIndex ) ;
133: 	float shadow = 0.0 ;
134: 	float numSamples = _fa_[3 /* rpJitterTexScale */] . w ;
135: 	float stepSize = 1.0 / numSamples ;
136: 	float vogelPhi = BlueNoise ( gl_FragCoord . xy , 1.0 ) ;
137: 	float shadowTexelSize = _fa_[0 /* rpScreenCorrectionFactor */] . z * _fa_[3 /* rpJitterTexScale */] . x ;
138: 	for ( float i = 0.0 ; i < numSamples ; i += 1.0 )
139: 	{
140: 		vec2 jitter = VogelDiskSample ( i , numSamples , vogelPhi ) ;
141: 		vec4 shadowTexcoordJittered = vec4 ( shadowTexcoord. xy + jitter * shadowTexelSize , shadowTexcoord. z , shadowTexcoord. w ) ;
142: 		shadow += texture ( samp5 , shadowTexcoordJittered. xywz ) ;
143: 	}
144: 	shadow *= stepSize ;
145: 	vec3 halfAngleVector = normalize ( lightVector + viewVector ) ;
146: 	float hdotN = clamp ( dot3 ( halfAngleVector , localNormal ) , 0.0 , 1.0 ) ;
147: 	float metallic = specMapSRGB. g ;
148: 	float roughness = specMapSRGB. r ;
149: 	float glossiness = 1.0 - roughness ;
150: 	vec3 dielectricColor = vec3 ( 0.04 ) ;
151: 	vec3 baseColor = diffuseMap ;
152: 	vec3 diffuseColor = baseColor * ( 1.0 - metallic ) ;
153: 	vec3 specularColor = mix ( dielectricColor , baseColor , metallic ) ;
154: 	vec3 lightColor = sRGBToLinearRGB ( lightProj. xyz * lightFalloff. xyz ) ;
155: 	float vdotN = clamp ( dot3 ( viewVector , localNormal ) , 0.0 , 1.0 ) ;
156: 	float vdotH = clamp ( dot3 ( viewVector , halfAngleVector ) , 0.0 , 1.0 ) ;
157: 	float ldotH = clamp ( dot3 ( lightVector , halfAngleVector ) , 0.0 , 1.0 ) ;
158: 	vec3 reflectColor = specularColor * _fa_[2 /* rpSpecularModifier */] . rgb * 1.0 ;
159: 	float rr = roughness * roughness ;
160: 	float rrrr = rr * rr ;
161: 	float D = ( hdotN * hdotN ) * ( rrrr - 1.0 ) + 1.0 ;
162: 	float VFapprox = ( ldotH * ldotH ) * ( roughness + 0.5 ) ;
163: 	vec3 specularBRDF = ( rrrr / ( 4.0 * 3.14159265358979323846 * D * D * VFapprox ) ) * ldotN * reflectColor ;
164: 	vec3 diffuseBRDF = diffuseColor * lambert * ( _fa_[1 /* rpDiffuseModifier */] . xyz ) ;
165: 	vec3 color = ( diffuseBRDF + specularBRDF ) * lightColor * vofi_Color . rgb * shadow ;
166: 	fo_FragColor . rgb = color ;
167: 	fo_FragColor . a = 1.0 ;
168: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 36 with vertexShader interactionSM and fragmentShader interactionSM
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While linking GLSL program 37 with vertexShader octahedron and fragmentShader octahedron
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While linking GLSL program 38 with vertexShader octahedron and fragmentShader octahedron
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/environment.vs.hlsl
-----------------
  1: // filename renderprogs/environment.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[6];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: float Linear1 (float c ) {
 12: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 13: }
 14: vec4 sRGBAToLinearRGBA (vec4 c ) {
 15: 	c = clamp ( c , 0.0 , 1.0 ) ;
 16: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec4 in_Normal;
 21: in vec4 in_Color;
 22: 
 23: out vec3 vofi_TexCoord0;
 24: out vec3 vofi_TexCoord1;
 25: out vec4 vofi_Color;
 26: 
 27: void main() {
 28: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 29: 	gl_Position . x = dot4 ( in_Position , _va_[2 /* rpMVPmatrixX */] ) ;
 30: 	gl_Position . y = dot4 ( in_Position , _va_[3 /* rpMVPmatrixY */] ) ;
 31: 	gl_Position . z = dot4 ( in_Position , _va_[4 /* rpMVPmatrixZ */] ) ;
 32: 	gl_Position . w = dot4 ( in_Position , _va_[5 /* rpMVPmatrixW */] ) ;
 33: 	vec4 toEye = _va_[0 /* rpLocalViewOrigin */] - in_Position ;
 34: 	vofi_TexCoord0 = toEye. xyz ;
 35: 	vofi_TexCoord1 = vNormal. xyz ;
 36: 	vofi_Color = sRGBAToLinearRGBA ( _va_[1 /* rpColor */] ) ;
 37: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/environment.ps.hlsl
-----------------
  1: // filename renderprogs/environment.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 17: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 18: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 19: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 20: float Linear1 (float c ) {
 21: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 22: }
 23: vec3 Linear3 (vec3 c ) {
 24: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 25: }
 26: vec3 sRGBToLinearRGB (vec3 c ) {
 27: 	c = clamp ( c , 0.0 , 1.0 ) ;
 28: 	return Linear3 ( c ) ;
 29: }
 30: uniform samplerCube samp0;
 31: 
 32: in vec3 vofi_TexCoord0;
 33: in vec3 vofi_TexCoord1;
 34: in vec4 vofi_Color;
 35: 
 36: out vec4 fo_FragColor;
 37: 
 38: void main() {
 39: 	vec3 globalNormal = normalize ( vofi_TexCoord1 ) ;
 40: 	vec3 globalEye = normalize ( vofi_TexCoord0 ) ;
 41: 	vec3 reflectionVector = vec3 ( dot3 ( globalEye , globalNormal ) ) ;
 42: 	reflectionVector *= globalNormal ;
 43: 	reflectionVector = ( reflectionVector * 2.0 ) - globalEye ;
 44: 	vec4 envMap = texture ( samp0 , reflectionVector ) ;
 45: 	fo_FragColor = vec4 ( sRGBToLinearRGB ( envMap. xyz ) , 1.0 ) * vofi_Color ;
 46: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 39 with vertexShader environment and fragmentShader environment
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/environment_skinned.vs.hlsl
-----------------
  1: // filename renderprogs/environment_skinned.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[6];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec3 vofi_TexCoord0;
 25: out vec3 vofi_TexCoord1;
 26: out vec4 vofi_Color;
 27: 
 28: void main() {
 29: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 30: 	float w0 = in_Color2 . x ;
 31: 	float w1 = in_Color2 . y ;
 32: 	float w2 = in_Color2 . z ;
 33: 	float w3 = in_Color2 . w ;
 34: 	vec4 matX , matY , matZ ;
 35: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 36: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 37: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 38: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 39: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 40: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 41: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 42: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 43: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 44: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 45: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 46: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 47: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 48: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 49: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 50: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 51: 	vec3 vNormalSkinned ;
 52: 	vNormalSkinned. x = dot3 ( matX , vNormal ) ;
 53: 	vNormalSkinned. y = dot3 ( matY , vNormal ) ;
 54: 	vNormalSkinned. z = dot3 ( matZ , vNormal ) ;
 55: 	vNormalSkinned = normalize ( vNormalSkinned ) ;
 56: 	vec4 modelPosition ;
 57: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 58: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 59: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 60: 	modelPosition. w = 1.0 ;
 61: 	gl_Position . x = dot4 ( modelPosition , _va_[2 /* rpMVPmatrixX */] ) ;
 62: 	gl_Position . y = dot4 ( modelPosition , _va_[3 /* rpMVPmatrixY */] ) ;
 63: 	gl_Position . z = dot4 ( modelPosition , _va_[4 /* rpMVPmatrixZ */] ) ;
 64: 	gl_Position . w = dot4 ( modelPosition , _va_[5 /* rpMVPmatrixW */] ) ;
 65: 	vec4 toEye = _va_[0 /* rpLocalViewOrigin */] - modelPosition ;
 66: 	vofi_TexCoord0 = toEye. xyz ;
 67: 	vofi_TexCoord1 = vNormalSkinned. xyz ;
 68: 	vofi_Color = _va_[1 /* rpColor */] ;
 69: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/environment_skinned.ps.hlsl
-----------------
  1: // filename renderprogs/environment_skinned.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 17: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 18: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 19: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 20: float Linear1 (float c ) {
 21: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 22: }
 23: vec3 Linear3 (vec3 c ) {
 24: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 25: }
 26: vec3 sRGBToLinearRGB (vec3 c ) {
 27: 	c = clamp ( c , 0.0 , 1.0 ) ;
 28: 	return Linear3 ( c ) ;
 29: }
 30: uniform samplerCube samp0;
 31: 
 32: in vec3 vofi_TexCoord0;
 33: in vec3 vofi_TexCoord1;
 34: in vec4 vofi_Color;
 35: 
 36: out vec4 fo_FragColor;
 37: 
 38: void main() {
 39: 	vec3 globalNormal = normalize ( vofi_TexCoord1 ) ;
 40: 	vec3 globalEye = normalize ( vofi_TexCoord0 ) ;
 41: 	vec3 reflectionVector = vec3 ( dot3 ( globalEye , globalNormal ) ) ;
 42: 	reflectionVector *= globalNormal ;
 43: 	reflectionVector = ( reflectionVector * 2.0 ) - globalEye ;
 44: 	vec4 envMap = texture ( samp0 , reflectionVector ) ;
 45: 	fo_FragColor = vec4 ( sRGBToLinearRGB ( envMap. xyz ) , 1.0 ) * vofi_Color ;
 46: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 40 with vertexShader environment_skinned and fragmentShader environment_skinned
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/bumpyenvironment.vs.hlsl
-----------------
  1: // filename renderprogs/bumpyenvironment.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[9];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: 
 16: in vec4 in_Position;
 17: in vec2 in_TexCoord;
 18: in vec4 in_Normal;
 19: in vec4 in_Tangent;
 20: in vec4 in_Color;
 21: 
 22: out vec2 vofi_TexCoord0;
 23: out vec3 vofi_TexCoord1;
 24: out vec3 vofi_TexCoord2;
 25: out vec3 vofi_TexCoord3;
 26: out vec3 vofi_TexCoord4;
 27: out vec4 vofi_Color;
 28: 
 29: void main() {
 30: 	vec4 normal = in_Normal * 2.0 - 1.0 ;
 31: 	vec4 tangent = in_Tangent * 2.0 - 1.0 ;
 32: 	vec3 binormal = cross ( normal. xyz , tangent. xyz ) * tangent. w ;
 33: 	gl_Position . x = dot4 ( in_Position , _va_[2 /* rpMVPmatrixX */] ) ;
 34: 	gl_Position . y = dot4 ( in_Position , _va_[3 /* rpMVPmatrixY */] ) ;
 35: 	gl_Position . z = dot4 ( in_Position , _va_[4 /* rpMVPmatrixZ */] ) ;
 36: 	gl_Position . w = dot4 ( in_Position , _va_[5 /* rpMVPmatrixW */] ) ;
 37: 	vofi_TexCoord0 = in_TexCoord . xy ;
 38: 	vec4 toEye = _va_[0 /* rpLocalViewOrigin */] - in_Position ;
 39: 	vofi_TexCoord1 . x = dot3 ( toEye , _va_[6 /* rpModelMatrixX */] ) ;
 40: 	vofi_TexCoord1 . y = dot3 ( toEye , _va_[7 /* rpModelMatrixY */] ) ;
 41: 	vofi_TexCoord1 . z = dot3 ( toEye , _va_[8 /* rpModelMatrixZ */] ) ;
 42: 	vofi_TexCoord2 . x = dot3 ( tangent , _va_[6 /* rpModelMatrixX */] ) ;
 43: 	vofi_TexCoord3 . x = dot3 ( tangent , _va_[7 /* rpModelMatrixY */] ) ;
 44: 	vofi_TexCoord4 . x = dot3 ( tangent , _va_[8 /* rpModelMatrixZ */] ) ;
 45: 	vofi_TexCoord2 . y = dot3 ( binormal , _va_[6 /* rpModelMatrixX */] ) ;
 46: 	vofi_TexCoord3 . y = dot3 ( binormal , _va_[7 /* rpModelMatrixY */] ) ;
 47: 	vofi_TexCoord4 . y = dot3 ( binormal , _va_[8 /* rpModelMatrixZ */] ) ;
 48: 	vofi_TexCoord2 . z = dot3 ( normal , _va_[6 /* rpModelMatrixX */] ) ;
 49: 	vofi_TexCoord3 . z = dot3 ( normal , _va_[7 /* rpModelMatrixY */] ) ;
 50: 	vofi_TexCoord4 . z = dot3 ( normal , _va_[8 /* rpModelMatrixZ */] ) ;
 51: 	vofi_Color = _va_[1 /* rpColor */] ;
 52: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/bumpyenvironment.ps.hlsl
-----------------
  1: // filename renderprogs/bumpyenvironment.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 17: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 18: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 19: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 20: float Linear1 (float c ) {
 21: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 22: }
 23: vec3 Linear3 (vec3 c ) {
 24: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 25: }
 26: vec3 sRGBToLinearRGB (vec3 c ) {
 27: 	c = clamp ( c , 0.0 , 1.0 ) ;
 28: 	return Linear3 ( c ) ;
 29: }
 30: uniform samplerCube samp0;
 31: uniform sampler2D samp1;
 32: 
 33: in vec2 vofi_TexCoord0;
 34: in vec3 vofi_TexCoord1;
 35: in vec3 vofi_TexCoord2;
 36: in vec3 vofi_TexCoord3;
 37: in vec3 vofi_TexCoord4;
 38: in vec4 vofi_Color;
 39: 
 40: out vec4 fo_FragColor;
 41: 
 42: void main() {
 43: 	vec4 bump = texture ( samp1 , vofi_TexCoord0 ) * 2.0 - 1.0 ;
 44: 	vec3 localNormal ;
 45: 	localNormal = vec3 ( bump. wy , 0.0 ) ;
 46: 	localNormal. z = sqrt ( 1.0 - dot3 ( localNormal , localNormal ) ) ;
 47: 	vec3 globalNormal ;
 48: 	globalNormal. x = dot3 ( localNormal , vofi_TexCoord2 ) ;
 49: 	globalNormal. y = dot3 ( localNormal , vofi_TexCoord3 ) ;
 50: 	globalNormal. z = dot3 ( localNormal , vofi_TexCoord4 ) ;
 51: 	vec3 globalEye = normalize ( vofi_TexCoord1 ) ;
 52: 	vec3 reflectionVector = globalNormal * dot3 ( globalEye , globalNormal ) ;
 53: 	reflectionVector = ( reflectionVector * 2.0 ) - globalEye ;
 54: 	vec4 envMap = texture ( samp0 , reflectionVector ) ;
 55: 	fo_FragColor = vec4 ( sRGBToLinearRGB ( envMap. xyz ) , 1.0 ) * vofi_Color ;
 56: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 41 with vertexShader bumpyenvironment and fragmentShader bumpyenvironment
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/bumpyenvironment_skinned.vs.hlsl
-----------------
  1: // filename renderprogs/bumpyenvironment_skinned.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[9];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 16: 
 17: in vec4 in_Position;
 18: in vec2 in_TexCoord;
 19: in vec4 in_Normal;
 20: in vec4 in_Tangent;
 21: in vec4 in_Color;
 22: in vec4 in_Color2;
 23: 
 24: out vec2 vofi_TexCoord0;
 25: out vec3 vofi_TexCoord1;
 26: out vec3 vofi_TexCoord2;
 27: out vec3 vofi_TexCoord3;
 28: out vec3 vofi_TexCoord4;
 29: out vec4 vofi_Color;
 30: 
 31: void main() {
 32: 	vec4 vNormal = in_Normal * 2.0 - 1.0 ;
 33: 	vec4 vTangent = in_Tangent * 2.0 - 1.0 ;
 34: 	vec3 vBinormal = cross ( vNormal. xyz , vTangent. xyz ) * vTangent. w ;
 35: 	float w0 = in_Color2 . x ;
 36: 	float w1 = in_Color2 . y ;
 37: 	float w2 = in_Color2 . z ;
 38: 	float w3 = in_Color2 . w ;
 39: 	vec4 matX , matY , matZ ;
 40: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 41: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 42: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 43: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 44: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 45: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 46: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 47: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 48: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 49: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 50: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 51: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 52: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 53: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 54: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 55: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 56: 	vec3 normal ;
 57: 	normal. x = dot3 ( matX , vNormal ) ;
 58: 	normal. y = dot3 ( matY , vNormal ) ;
 59: 	normal. z = dot3 ( matZ , vNormal ) ;
 60: 	normal = normalize ( normal ) ;
 61: 	vec3 tangent ;
 62: 	tangent. x = dot3 ( matX , vTangent ) ;
 63: 	tangent. y = dot3 ( matY , vTangent ) ;
 64: 	tangent. z = dot3 ( matZ , vTangent ) ;
 65: 	tangent = normalize ( tangent ) ;
 66: 	vec3 binormal ;
 67: 	binormal. x = dot3 ( matX , vBinormal ) ;
 68: 	binormal. y = dot3 ( matY , vBinormal ) ;
 69: 	binormal. z = dot3 ( matZ , vBinormal ) ;
 70: 	binormal = normalize ( binormal ) ;
 71: 	vec4 modelPosition ;
 72: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 73: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 74: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 75: 	modelPosition. w = 1.0 ;
 76: 	gl_Position . x = dot4 ( modelPosition , _va_[2 /* rpMVPmatrixX */] ) ;
 77: 	gl_Position . y = dot4 ( modelPosition , _va_[3 /* rpMVPmatrixY */] ) ;
 78: 	gl_Position . z = dot4 ( modelPosition , _va_[4 /* rpMVPmatrixZ */] ) ;
 79: 	gl_Position . w = dot4 ( modelPosition , _va_[5 /* rpMVPmatrixW */] ) ;
 80: 	vofi_TexCoord0 = in_TexCoord . xy ;
 81: 	vec4 toEye = _va_[0 /* rpLocalViewOrigin */] - modelPosition ;
 82: 	vofi_TexCoord1 . x = dot3 ( toEye , _va_[6 /* rpModelMatrixX */] ) ;
 83: 	vofi_TexCoord1 . y = dot3 ( toEye , _va_[7 /* rpModelMatrixY */] ) ;
 84: 	vofi_TexCoord1 . z = dot3 ( toEye , _va_[8 /* rpModelMatrixZ */] ) ;
 85: 	vofi_TexCoord2 . x = dot3 ( tangent , _va_[6 /* rpModelMatrixX */] ) ;
 86: 	vofi_TexCoord3 . x = dot3 ( tangent , _va_[7 /* rpModelMatrixY */] ) ;
 87: 	vofi_TexCoord4 . x = dot3 ( tangent , _va_[8 /* rpModelMatrixZ */] ) ;
 88: 	vofi_TexCoord2 . y = dot3 ( binormal , _va_[6 /* rpModelMatrixX */] ) ;
 89: 	vofi_TexCoord3 . y = dot3 ( binormal , _va_[7 /* rpModelMatrixY */] ) ;
 90: 	vofi_TexCoord4 . y = dot3 ( binormal , _va_[8 /* rpModelMatrixZ */] ) ;
 91: 	vofi_TexCoord2 . z = dot3 ( normal , _va_[6 /* rpModelMatrixX */] ) ;
 92: 	vofi_TexCoord3 . z = dot3 ( normal , _va_[7 /* rpModelMatrixY */] ) ;
 93: 	vofi_TexCoord4 . z = dot3 ( normal , _va_[8 /* rpModelMatrixZ */] ) ;
 94: 	vofi_Color = _va_[1 /* rpColor */] ;
 95: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/bumpyenvironment_skinned.ps.hlsl
-----------------
  1: // filename renderprogs/bumpyenvironment_skinned.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 17: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 18: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 19: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 20: float Linear1 (float c ) {
 21: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 22: }
 23: vec3 Linear3 (vec3 c ) {
 24: 	return vec3 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) ) ;
 25: }
 26: vec3 sRGBToLinearRGB (vec3 c ) {
 27: 	c = clamp ( c , 0.0 , 1.0 ) ;
 28: 	return Linear3 ( c ) ;
 29: }
 30: uniform samplerCube samp0;
 31: uniform sampler2D samp1;
 32: 
 33: in vec2 vofi_TexCoord0;
 34: in vec3 vofi_TexCoord1;
 35: in vec3 vofi_TexCoord2;
 36: in vec3 vofi_TexCoord3;
 37: in vec3 vofi_TexCoord4;
 38: in vec4 vofi_Color;
 39: 
 40: out vec4 fo_FragColor;
 41: 
 42: void main() {
 43: 	vec4 bump = texture ( samp1 , vofi_TexCoord0 ) * 2.0 - 1.0 ;
 44: 	vec3 localNormal ;
 45: 	localNormal = vec3 ( bump. wy , 0.0 ) ;
 46: 	localNormal. z = sqrt ( 1.0 - dot3 ( localNormal , localNormal ) ) ;
 47: 	vec3 globalNormal ;
 48: 	globalNormal. x = dot3 ( localNormal , vofi_TexCoord2 ) ;
 49: 	globalNormal. y = dot3 ( localNormal , vofi_TexCoord3 ) ;
 50: 	globalNormal. z = dot3 ( localNormal , vofi_TexCoord4 ) ;
 51: 	vec3 globalEye = normalize ( vofi_TexCoord1 ) ;
 52: 	vec3 reflectionVector = globalNormal * dot3 ( globalEye , globalNormal ) ;
 53: 	reflectionVector = ( reflectionVector * 2.0 ) - globalEye ;
 54: 	vec4 envMap = texture ( samp0 , reflectionVector ) ;
 55: 	fo_FragColor = vec4 ( sRGBToLinearRGB ( envMap. xyz ) , 1.0 ) * vofi_Color ;
 56: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 42 with vertexShader bumpyenvironment_skinned and fragmentShader bumpyenvironment_skinned
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/depth.vs.hlsl
-----------------
  1: // filename renderprogs/depth.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: 
 14: 
 15: void main() {
 16: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 17: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 18: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 19: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 20: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/depth.ps.hlsl
-----------------
  1: // filename renderprogs/depth.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: out vec4 fo_FragColor;
 18: 
 19: void main() {
 20: 	fo_FragColor = vec4 ( 0.0 , 0.0 , 0.0 , 1.0 ) ;
 21: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 43 with vertexShader depth and fragmentShader depth
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/depth_skinned.vs.hlsl
-----------------
  1: // filename renderprogs/depth_skinned.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 12: 
 13: in vec4 in_Position;
 14: in vec2 in_TexCoord;
 15: in vec4 in_Normal;
 16: in vec4 in_Tangent;
 17: in vec4 in_Color;
 18: in vec4 in_Color2;
 19: 
 20: 
 21: void main() {
 22: 	float w0 = in_Color2 . x ;
 23: 	float w1 = in_Color2 . y ;
 24: 	float w2 = in_Color2 . z ;
 25: 	float w3 = in_Color2 . w ;
 26: 	vec4 matX , matY , matZ ;
 27: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 28: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 29: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 30: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 31: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 32: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 33: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 34: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 35: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 36: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 37: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 38: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 39: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 40: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 41: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 42: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 43: 	vec4 modelPosition ;
 44: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 45: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 46: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 47: 	modelPosition. w = 1.0 ;
 48: 	gl_Position . x = dot4 ( modelPosition , _va_[0 /* rpMVPmatrixX */] ) ;
 49: 	gl_Position . y = dot4 ( modelPosition , _va_[1 /* rpMVPmatrixY */] ) ;
 50: 	gl_Position . z = dot4 ( modelPosition , _va_[2 /* rpMVPmatrixZ */] ) ;
 51: 	gl_Position . w = dot4 ( modelPosition , _va_[3 /* rpMVPmatrixW */] ) ;
 52: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/depth_skinned.ps.hlsl
-----------------
  1: // filename renderprogs/depth_skinned.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: out vec4 fo_FragColor;
 18: 
 19: void main() {
 20: 	fo_FragColor = vec4 ( 0.0 , 0.0 , 0.0 , 1.0 ) ;
 21: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 44 with vertexShader depth_skinned and fragmentShader depth_skinned
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/shadow.vs.hlsl
-----------------
  1: // filename renderprogs/shadow.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[5];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: 
 14: 
 15: void main() {
 16: 	vec4 vPos = in_Position - _va_[0 /* rpLocalLightOrigin */] ;
 17: 	vPos = ( vPos. wwww * _va_[0 /* rpLocalLightOrigin */] ) + vPos ;
 18: 	gl_Position . x = dot4 ( vPos , _va_[1 /* rpMVPmatrixX */] ) ;
 19: 	gl_Position . y = dot4 ( vPos , _va_[2 /* rpMVPmatrixY */] ) ;
 20: 	gl_Position . z = dot4 ( vPos , _va_[3 /* rpMVPmatrixZ */] ) ;
 21: 	gl_Position . w = dot4 ( vPos , _va_[4 /* rpMVPmatrixW */] ) ;
 22: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/shadow.ps.hlsl
-----------------
  1: // filename renderprogs/shadow.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: out vec4 fo_FragColor;
 20: 
 21: void main() {
 22: 	fo_FragColor = _fa_[0 /* rpColor */] ;
 23: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 45 with vertexShader shadow and fragmentShader shadow
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/shadow_skinned.vs.hlsl
-----------------
  1: // filename renderprogs/shadow_skinned.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[5];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 12: 
 13: in vec4 in_Position;
 14: in vec4 in_Color;
 15: in vec4 in_Color2;
 16: 
 17: 
 18: void main() {
 19: 	float w0 = in_Color2 . x ;
 20: 	float w1 = in_Color2 . y ;
 21: 	float w2 = in_Color2 . z ;
 22: 	float w3 = in_Color2 . w ;
 23: 	vec4 matX , matY , matZ ;
 24: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 25: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 26: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 27: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 28: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 29: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 30: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 31: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 32: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 33: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 34: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 35: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 36: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 37: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 38: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 39: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 40: 	vec4 vertexPosition = in_Position ;
 41: 	vertexPosition. w = 1.0 ;
 42: 	vec4 modelPosition ;
 43: 	modelPosition. x = dot4 ( matX , vertexPosition ) ;
 44: 	modelPosition. y = dot4 ( matY , vertexPosition ) ;
 45: 	modelPosition. z = dot4 ( matZ , vertexPosition ) ;
 46: 	modelPosition. w = in_Position . w ;
 47: 	vec4 vPos = modelPosition - _va_[0 /* rpLocalLightOrigin */] ;
 48: 	vPos = ( vPos. wwww * _va_[0 /* rpLocalLightOrigin */] ) + vPos ;
 49: 	gl_Position . x = dot4 ( vPos , _va_[1 /* rpMVPmatrixX */] ) ;
 50: 	gl_Position . y = dot4 ( vPos , _va_[2 /* rpMVPmatrixY */] ) ;
 51: 	gl_Position . z = dot4 ( vPos , _va_[3 /* rpMVPmatrixZ */] ) ;
 52: 	gl_Position . w = dot4 ( vPos , _va_[4 /* rpMVPmatrixW */] ) ;
 53: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/shadow_skinned.ps.hlsl
-----------------
  1: // filename renderprogs/shadow_skinned.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: out vec4 fo_FragColor;
 20: 
 21: void main() {
 22: 	fo_FragColor = _fa_[0 /* rpColor */] ;
 23: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 46 with vertexShader shadow_skinned and fragmentShader shadow_skinned
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/shadowDebug.vs.hlsl
-----------------
  1: // filename renderprogs/shadowDebug.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[5];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: 
 14: 
 15: void main() {
 16: 	vec4 vPos = in_Position - _va_[0 /* rpLocalLightOrigin */] ;
 17: 	vPos = ( vPos. wwww * _va_[0 /* rpLocalLightOrigin */] ) + vPos ;
 18: 	gl_Position . x = dot4 ( vPos , _va_[1 /* rpMVPmatrixX */] ) ;
 19: 	gl_Position . y = dot4 ( vPos , _va_[2 /* rpMVPmatrixY */] ) ;
 20: 	gl_Position . z = dot4 ( vPos , _va_[3 /* rpMVPmatrixZ */] ) ;
 21: 	gl_Position . w = dot4 ( vPos , _va_[4 /* rpMVPmatrixW */] ) ;
 22: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/shadowDebug.ps.hlsl
-----------------
  1: // filename renderprogs/shadowDebug.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: out vec4 fo_FragColor;
 20: 
 21: void main() {
 22: 	fo_FragColor = _fa_[0 /* rpColor */] ;
 23: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 47 with vertexShader shadowDebug and fragmentShader shadowDebug
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/shadowDebug_skinned.vs.hlsl
-----------------
  1: // filename renderprogs/shadowDebug_skinned.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[5];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 12: 
 13: in vec4 in_Position;
 14: in vec4 in_Color;
 15: in vec4 in_Color2;
 16: 
 17: 
 18: void main() {
 19: 	float w0 = in_Color2 . x ;
 20: 	float w1 = in_Color2 . y ;
 21: 	float w2 = in_Color2 . z ;
 22: 	float w3 = in_Color2 . w ;
 23: 	vec4 matX , matY , matZ ;
 24: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 25: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 26: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 27: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 28: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 29: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 30: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 31: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 32: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 33: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 34: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 35: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 36: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 37: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 38: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 39: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 40: 	vec4 vertexPosition = in_Position ;
 41: 	vertexPosition. w = 1.0 ;
 42: 	vec4 modelPosition ;
 43: 	modelPosition. x = dot4 ( matX , vertexPosition ) ;
 44: 	modelPosition. y = dot4 ( matY , vertexPosition ) ;
 45: 	modelPosition. z = dot4 ( matZ , vertexPosition ) ;
 46: 	modelPosition. w = in_Position . w ;
 47: 	vec4 vPos = modelPosition - _va_[0 /* rpLocalLightOrigin */] ;
 48: 	vPos = ( vPos. wwww * _va_[0 /* rpLocalLightOrigin */] ) + vPos ;
 49: 	gl_Position . x = dot4 ( vPos , _va_[1 /* rpMVPmatrixX */] ) ;
 50: 	gl_Position . y = dot4 ( vPos , _va_[2 /* rpMVPmatrixY */] ) ;
 51: 	gl_Position . z = dot4 ( vPos , _va_[3 /* rpMVPmatrixZ */] ) ;
 52: 	gl_Position . w = dot4 ( vPos , _va_[4 /* rpMVPmatrixW */] ) ;
 53: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/shadowDebug_skinned.ps.hlsl
-----------------
  1: // filename renderprogs/shadowDebug_skinned.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: out vec4 fo_FragColor;
 20: 
 21: void main() {
 22: 	fo_FragColor = _fa_[0 /* rpColor */] ;
 23: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 48 with vertexShader shadowDebug_skinned and fragmentShader shadowDebug_skinned
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/blendlight.vs.hlsl
-----------------
  1: // filename renderprogs/blendlight.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[8];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: in vec2 in_TexCoord;
 14: in vec4 in_Normal;
 15: in vec4 in_Tangent;
 16: in vec4 BINORMAL;
 17: in vec4 in_Color;
 18: 
 19: out vec4 vofi_TexCoord0;
 20: out vec2 vofi_TexCoord1;
 21: 
 22: void main() {
 23: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 24: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 25: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 26: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 27: 	vofi_TexCoord0 . x = dot4 ( in_Position , _va_[4 /* rpTexGen0S */] ) ;
 28: 	vofi_TexCoord0 . y = dot4 ( in_Position , _va_[5 /* rpTexGen0T */] ) ;
 29: 	vofi_TexCoord0 . z = 0.0 ;
 30: 	vofi_TexCoord0 . w = dot4 ( in_Position , _va_[6 /* rpTexGen0Q */] ) ;
 31: 	vofi_TexCoord1 . x = dot4 ( in_Position , _va_[7 /* rpTexGen1S */] ) ;
 32: 	vofi_TexCoord1 . y = 0.5 ;
 33: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/blendlight.ps.hlsl
-----------------
  1: // filename renderprogs/blendlight.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: float Linear1 (float c ) {
 20: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 21: }
 22: vec4 idtex2Dproj (sampler2D samp , vec4 texCoords ) {
 23: 	return textureProj ( samp , texCoords. xyw ) ;
 24: }
 25: uniform sampler2D samp0;
 26: uniform sampler2D samp1;
 27: 
 28: in vec4 vofi_TexCoord0;
 29: in vec2 vofi_TexCoord1;
 30: 
 31: out vec4 fo_FragColor;
 32: 
 33: void main() {
 34: 	vec4 c = idtex2Dproj ( samp0 , vofi_TexCoord0 ) * texture ( samp1 , vofi_TexCoord1 ) * _fa_[0 /* rpColor */] ;
 35: 	c = clamp ( c , 0.0 , 1.0 ) ;
 36: 	c = vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 37: 	fo_FragColor = c ;
 38: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 49 with vertexShader blendlight and fragmentShader blendlight
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/fog.vs.hlsl
-----------------
  1: // filename renderprogs/fog.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[8];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: in vec2 in_TexCoord;
 14: in vec4 in_Normal;
 15: in vec4 in_Tangent;
 16: in vec4 in_Color;
 17: 
 18: out vec2 vofi_TexCoord0;
 19: out vec2 vofi_TexCoord1;
 20: 
 21: void main() {
 22: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 23: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 24: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 25: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 26: 	vofi_TexCoord0 . x = dot4 ( in_Position , _va_[4 /* rpTexGen0S */] ) ;
 27: 	vofi_TexCoord0 . y = dot4 ( in_Position , _va_[5 /* rpTexGen0T */] ) ;
 28: 	vofi_TexCoord1 . x = dot4 ( in_Position , _va_[6 /* rpTexGen1S */] ) ;
 29: 	vofi_TexCoord1 . y = dot4 ( in_Position , _va_[7 /* rpTexGen1T */] ) ;
 30: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/fog.ps.hlsl
-----------------
  1: // filename renderprogs/fog.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: float Linear1 (float c ) {
 20: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 21: }
 22: uniform sampler2D samp0;
 23: uniform sampler2D samp1;
 24: 
 25: in vec2 vofi_TexCoord0;
 26: in vec2 vofi_TexCoord1;
 27: 
 28: out vec4 fo_FragColor;
 29: 
 30: void main() {
 31: 	vec4 c = texture ( samp0 , vofi_TexCoord0 ) * texture ( samp1 , vofi_TexCoord1 ) * _fa_[0 /* rpColor */] ;
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	c = vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 34: 	fo_FragColor = c ;
 35: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 50 with vertexShader fog and fragmentShader fog
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/fog_skinned.vs.hlsl
-----------------
  1: // filename renderprogs/fog_skinned.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[8];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: uniform matrices_ubo {vec4 matrices [ 408 ] ; } ;
 12: 
 13: in vec4 in_Position;
 14: in vec2 in_TexCoord;
 15: in vec4 in_Normal;
 16: in vec4 in_Tangent;
 17: in vec4 in_Color;
 18: in vec4 in_Color2;
 19: 
 20: out vec2 vofi_TexCoord0;
 21: out vec2 vofi_TexCoord1;
 22: 
 23: void main() {
 24: 	float w0 = in_Color2 . x ;
 25: 	float w1 = in_Color2 . y ;
 26: 	float w2 = in_Color2 . z ;
 27: 	float w3 = in_Color2 . w ;
 28: 	vec4 matX , matY , matZ ;
 29: 	int joint = int ( in_Color . x * 255.1 * 3.0 ) ;
 30: 	matX = matrices [ int ( joint + 0 ) ] * w0 ;
 31: 	matY = matrices [ int ( joint + 1 ) ] * w0 ;
 32: 	matZ = matrices [ int ( joint + 2 ) ] * w0 ;
 33: 	joint = int ( in_Color . y * 255.1 * 3.0 ) ;
 34: 	matX += matrices [ int ( joint + 0 ) ] * w1 ;
 35: 	matY += matrices [ int ( joint + 1 ) ] * w1 ;
 36: 	matZ += matrices [ int ( joint + 2 ) ] * w1 ;
 37: 	joint = int ( in_Color . z * 255.1 * 3.0 ) ;
 38: 	matX += matrices [ int ( joint + 0 ) ] * w2 ;
 39: 	matY += matrices [ int ( joint + 1 ) ] * w2 ;
 40: 	matZ += matrices [ int ( joint + 2 ) ] * w2 ;
 41: 	joint = int ( in_Color . w * 255.1 * 3.0 ) ;
 42: 	matX += matrices [ int ( joint + 0 ) ] * w3 ;
 43: 	matY += matrices [ int ( joint + 1 ) ] * w3 ;
 44: 	matZ += matrices [ int ( joint + 2 ) ] * w3 ;
 45: 	vec4 modelPosition ;
 46: 	modelPosition. x = dot4 ( matX , in_Position ) ;
 47: 	modelPosition. y = dot4 ( matY , in_Position ) ;
 48: 	modelPosition. z = dot4 ( matZ , in_Position ) ;
 49: 	modelPosition. w = 1.0 ;
 50: 	gl_Position . x = dot4 ( modelPosition , _va_[0 /* rpMVPmatrixX */] ) ;
 51: 	gl_Position . y = dot4 ( modelPosition , _va_[1 /* rpMVPmatrixY */] ) ;
 52: 	gl_Position . z = dot4 ( modelPosition , _va_[2 /* rpMVPmatrixZ */] ) ;
 53: 	gl_Position . w = dot4 ( modelPosition , _va_[3 /* rpMVPmatrixW */] ) ;
 54: 	vofi_TexCoord0 . x = dot4 ( modelPosition , _va_[4 /* rpTexGen0S */] ) ;
 55: 	vofi_TexCoord0 . y = dot4 ( modelPosition , _va_[5 /* rpTexGen0T */] ) ;
 56: 	vofi_TexCoord1 . x = dot4 ( modelPosition , _va_[6 /* rpTexGen1S */] ) ;
 57: 	vofi_TexCoord1 . y = dot4 ( modelPosition , _va_[7 /* rpTexGen1T */] ) ;
 58: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/fog_skinned.ps.hlsl
-----------------
  1: // filename renderprogs/fog_skinned.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: float Linear1 (float c ) {
 20: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 21: }
 22: uniform sampler2D samp0;
 23: uniform sampler2D samp1;
 24: 
 25: in vec2 vofi_TexCoord0;
 26: in vec2 vofi_TexCoord1;
 27: 
 28: out vec4 fo_FragColor;
 29: 
 30: void main() {
 31: 	vec4 c = texture ( samp0 , vofi_TexCoord0 ) * texture ( samp1 , vofi_TexCoord1 ) * _fa_[0 /* rpColor */] ;
 32: 	c = clamp ( c , 0.0 , 1.0 ) ;
 33: 	c = vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 34: 	fo_FragColor = c ;
 35: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 51 with vertexShader fog_skinned and fragmentShader fog_skinned
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/skybox.vs.hlsl
-----------------
  1: // filename renderprogs/skybox.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[7];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: vec4 swizzleColor (vec4 c ) {
 12: 	return c ;
 13: }
 14: 
 15: in vec4 in_Position;
 16: in vec2 in_TexCoord;
 17: in vec4 in_Normal;
 18: in vec4 in_Tangent;
 19: in vec4 in_Color;
 20: 
 21: out vec3 vofi_TexCoord0;
 22: out vec4 vofi_Color;
 23: 
 24: void main() {
 25: 	gl_Position . x = dot4 ( in_Position , _va_[3 /* rpMVPmatrixX */] ) ;
 26: 	gl_Position . y = dot4 ( in_Position , _va_[4 /* rpMVPmatrixY */] ) ;
 27: 	gl_Position . z = dot4 ( in_Position , _va_[5 /* rpMVPmatrixZ */] ) ;
 28: 	gl_Position . w = dot4 ( in_Position , _va_[6 /* rpMVPmatrixW */] ) ;
 29: 	vofi_TexCoord0 = in_Position . xyz - _va_[0 /* rpLocalViewOrigin */] . xyz ;
 30: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[1 /* rpVertexColorModulate */] ) + _va_[2 /* rpVertexColorAdd */] ;
 31: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/skybox.ps.hlsl
-----------------
  1: // filename renderprogs/skybox.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: float Linear1 (float c ) {
 17: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 18: }
 19: vec4 sRGBAToLinearRGBA (vec4 c ) {
 20: 	c = clamp ( c , 0.0 , 1.0 ) ;
 21: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 22: }
 23: uniform samplerCube samp0;
 24: 
 25: in vec3 vofi_TexCoord0;
 26: in vec4 vofi_Color;
 27: 
 28: out vec4 fo_FragColor;
 29: 
 30: void main() {
 31: 	fo_FragColor = sRGBAToLinearRGBA ( texture ( samp0 , vofi_TexCoord0 ) ) * vofi_Color ;
 32: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 52 with vertexShader skybox and fragmentShader skybox
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/wobblesky.vs.hlsl
-----------------
  1: // filename renderprogs/wobblesky.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[10];
  8: 
  9: float dot3 (vec3 a , vec3 b ) {return dot ( a , b ) ; }
 10: float dot3 (vec3 a , vec4 b ) {return dot ( a , b. xyz ) ; }
 11: float dot3 (vec4 a , vec3 b ) {return dot ( a. xyz , b ) ; }
 12: float dot3 (vec4 a , vec4 b ) {return dot ( a. xyz , b. xyz ) ; }
 13: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 14: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 15: vec4 swizzleColor (vec4 c ) {
 16: 	return c ;
 17: }
 18: 
 19: in vec4 in_Position;
 20: in vec2 in_TexCoord;
 21: in vec4 in_Normal;
 22: in vec4 in_Tangent;
 23: in vec4 in_Color;
 24: 
 25: out vec3 vofi_TexCoord0;
 26: out vec4 vofi_Color;
 27: 
 28: void main() {
 29: 	gl_Position . x = dot4 ( in_Position , _va_[3 /* rpMVPmatrixX */] ) ;
 30: 	gl_Position . y = dot4 ( in_Position , _va_[4 /* rpMVPmatrixY */] ) ;
 31: 	gl_Position . z = dot4 ( in_Position , _va_[5 /* rpMVPmatrixZ */] ) ;
 32: 	gl_Position . w = dot4 ( in_Position , _va_[6 /* rpMVPmatrixW */] ) ;
 33: 	vec3 t0 = in_Position . xyz - _va_[0 /* rpLocalViewOrigin */] . xyz ;
 34: 	vofi_TexCoord0 . x = dot3 ( t0 , _va_[7 /* rpWobbleSkyX */] ) ;
 35: 	vofi_TexCoord0 . y = dot3 ( t0 , _va_[8 /* rpWobbleSkyY */] ) ;
 36: 	vofi_TexCoord0 . z = dot3 ( t0 , _va_[9 /* rpWobbleSkyZ */] ) ;
 37: 	vofi_Color = ( swizzleColor ( in_Color ) * _va_[1 /* rpVertexColorModulate */] ) + _va_[2 /* rpVertexColorAdd */] ;
 38: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/wobblesky.ps.hlsl
-----------------
  1: // filename renderprogs/wobblesky.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: float Linear1 (float c ) {
 17: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 18: }
 19: vec4 sRGBAToLinearRGBA (vec4 c ) {
 20: 	c = clamp ( c , 0.0 , 1.0 ) ;
 21: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 22: }
 23: uniform samplerCube samp0;
 24: 
 25: in vec3 vofi_TexCoord0;
 26: in vec4 vofi_Color;
 27: 
 28: out vec4 fo_FragColor;
 29: 
 30: void main() {
 31: 	fo_FragColor = sRGBAToLinearRGBA ( texture ( samp0 , vofi_TexCoord0 ) ) * vofi_Color ;
 32: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 53 with vertexShader wobblesky and fragmentShader wobblesky
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/postprocess.vs.hlsl
-----------------
  1: // filename renderprogs/postprocess.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: in vec4 in_Normal;
 11: in vec4 in_Tangent;
 12: in vec4 in_Color;
 13: 
 14: out vec2 vofi_TexCoord0;
 15: 
 16: void main() {
 17: 	gl_Position = in_Position ;
 18: 	vofi_TexCoord0 = in_TexCoord ;
 19: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/postprocess.ps.hlsl
-----------------
  1: // filename renderprogs/postprocess.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: float dot2 (vec2 a , vec2 b ) {return dot ( a , b ) ; }
 20: float RemapNoiseTriErp (const float v ) {
 21: 	float r2 = 0.5 * v ;
 22: 	float f1 = sqrt ( r2 ) ;
 23: 	float f2 = 1.0 - sqrt ( r2 - 0.25 ) ;
 24: 	return ( v < 0.5 ) ? f1 : f2 ;
 25: }
 26: const float c_goldenRatioConjugate = 0.61803398875;
 27: uniform sampler2D samp0;
 28: uniform sampler2D samp1;
 29: 
 30: in vec2 vofi_TexCoord0;
 31: 
 32: out vec4 fo_FragColor;
 33: 
 34: vec2 BarrelDistortion (vec2 xy , float amount ) {
 35: 	vec2 cc = xy - 0.5 ;
 36: 	float dist = dot2 ( cc , cc ) ;
 37: 	return xy + cc * dist * amount ;
 38: }
 39: float Linterp (float t ) {
 40: 	return saturate ( 1.0 - abs ( 2.0 * t - 1.0 ) ) ;
 41: }
 42: float Remap (float t , float a , float b ) {
 43: 	return saturate ( ( t - a ) / ( b - a ) ) ;
 44: }
 45: vec3 SpectrumOffset (float t ) {
 46: 	float lo = step ( t , 0.5 ) ;
 47: 	float hi = 1.0 - lo ;
 48: 	float w = Linterp ( Remap ( t , 1.0 / 6.0 , 5.0 / 6.0 ) ) ;
 49: 	vec3 ret = vec3 ( lo , 1.0 , hi ) * vec3 ( 1.0 - w , w , 1.0 - w ) ;
 50: 	return pow ( ret , vec3 ( 1.0 / 2.2 ) ) ;
 51: }
 52: void ChromaticAberrationPass (inout vec4 color ) {
 53: 	float amount = 0.075 ;
 54: 	vec3 sum = vec3 ( 0.0 ) ;
 55: 	vec3 sumColor = vec3 ( 0.0 ) ;
 56: 	float samples = 12.0 ;
 57: 	for ( float i = 0.0 ; i < samples ; i = i + 1.0 )
 58: 	{
 59: 		float t = ( i / ( samples - 1.0 ) ) ;
 60: 		vec3 so = SpectrumOffset ( t ) ;
 61: 		sum += so. xyz ;
 62: 		sumColor += so * texture ( samp0 , BarrelDistortion ( vofi_TexCoord0 , ( 0.5 * amount * t ) ) ). rgb ;
 63: 	}
 64: 	vec3 outColor = ( sumColor / sum ) ;
 65: 	color. rgb = mix ( color. rgb , outColor , 1.0 ) ;
 66: }
 67: vec3 BlueNoise3 (vec2 n , float x ) {
 68: 	vec2 uv = n. xy * _fa_[0 /* rpJitterTexOffset */] . xy ;
 69: 	vec3 noise = texture ( samp1 , uv ). rgb ;
 70: 	noise = fract ( noise + c_goldenRatioConjugate * _fa_[0 /* rpJitterTexOffset */] . w * x ) ;
 71: 	return noise ;
 72: }
 73: vec3 Step3T (vec2 uv ) {
 74: 	vec3 noise = BlueNoise3 ( uv , 1.0 ) ;
 75: 	noise. x = RemapNoiseTriErp ( noise. x ) ;
 76: 	noise. y = RemapNoiseTriErp ( noise. y ) ;
 77: 	noise. z = RemapNoiseTriErp ( noise. z ) ;
 78: 	noise = noise * 2.0 - 1.0 ;
 79: 	return noise ;
 80: }
 81: void DitheringPass (inout vec4 fragColor ) {
 82: 	vec2 uv = gl_FragCoord . xy * 1.0 ;
 83: 	vec2 uv2 = vofi_TexCoord0 ;
 84: 	vec3 color = fragColor. rgb ;
 85: 	{
 86: 		{
 87: 			color = floor ( 0.5 + color * ( 8.0 + 1.0 - 1.0 ) + ( - 1.0 * 0.5 ) + Step3T ( uv ) * ( 1.0 ) ) * ( 1.0 / ( 8.0 - 1.0 ) ) ;
 88: 		}
 89: 	}
 90: 	fragColor. rgb = color ;
 91: }
 92: void main() {
 93: 	vec2 tCoords = vofi_TexCoord0 ;
 94: 	vec4 color = texture ( samp0 , tCoords ) ;
 95: 	ChromaticAberrationPass ( color ) ;
 96: 	DitheringPass ( color ) ;
 97: 	fo_FragColor = color ;
 98: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 54 with vertexShader postprocess and fragmentShader postprocess
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/screen.vs.hlsl
-----------------
  1: // filename renderprogs/screen.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: in vec4 in_Normal;
 11: in vec4 in_Tangent;
 12: in vec4 in_Color;
 13: 
 14: out vec2 vofi_TexCoord0;
 15: 
 16: void main() {
 17: 	gl_Position = in_Position ;
 18: 	vofi_TexCoord0 = in_TexCoord ;
 19: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/screen.ps.hlsl
-----------------
  1: // filename renderprogs/screen.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: uniform sampler2D samp0;
 17: 
 18: in vec2 vofi_TexCoord0;
 19: 
 20: out vec4 fo_FragColor;
 21: 
 22: void main() {
 23: 	vec2 tCoords = vofi_TexCoord0 ;
 24: 	vec4 color = texture ( samp0 , tCoords ) ;
 25: 	fo_FragColor = color ;
 26: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 55 with vertexShader screen and fragmentShader screen
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/tonemap.vs.hlsl
-----------------
  1: // filename renderprogs/tonemap.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: in vec4 in_Normal;
 11: in vec4 in_Tangent;
 12: in vec4 in_Color;
 13: 
 14: out vec2 vofi_TexCoord0;
 15: 
 16: void main() {
 17: 	gl_Position = in_Position ;
 18: 	vofi_TexCoord0 = in_TexCoord ;
 19: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/tonemap.ps.hlsl
-----------------
  1: // filename renderprogs/tonemap.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 20: uniform sampler2D samp0;
 21: 
 22: in vec2 vofi_TexCoord0;
 23: 
 24: out vec4 fo_FragColor;
 25: 
 26: vec3 ACESFilm (vec3 x ) {
 27: 	float a = 2.51 ;
 28: 	float b = 0.03 ;
 29: 	float c = 2.43 ;
 30: 	float d = 0.59 ;
 31: 	float e = 0.14 ;
 32: 	return saturate ( ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e ) ) ;
 33: }
 34: void main() {
 35: 	vec2 tCoords = vofi_TexCoord0 ;
 36: 	vec4 color = texture ( samp0 , tCoords ) ;
 37: 	float Y = dot ( LUMINANCE_SRGB , color ) ;
 38: 	float hdrGamma = 2.2 ;
 39: 	float gamma = hdrGamma ;
 40: 	float hdrKey = _fa_[0 /* rpScreenCorrectionFactor */] . x ;
 41: 	float hdrAverageLuminance = _fa_[0 /* rpScreenCorrectionFactor */] . y ;
 42: 	float hdrMaxLuminance = _fa_[0 /* rpScreenCorrectionFactor */] . z ;
 43: 	float Yr = ( hdrKey * Y ) / hdrAverageLuminance ;
 44: 	float Ymax = hdrMaxLuminance ;
 45: 	float avgLuminance = max ( hdrAverageLuminance , 0.001 ) ;
 46: 	float linearExposure = ( hdrKey / avgLuminance ) ;
 47: 	float exposure = log2 ( max ( linearExposure , 0.0001 ) ) ;
 48: 	vec3 exposedColor = exp2 ( exposure ) * color. rgb ;
 49: 	color. rgb = ACESFilm ( exposedColor ) ;
 50: 	gamma = 1.0 / hdrGamma ;
 51: 	color. r = pow ( color. r , gamma ) ;
 52: 	color. g = pow ( color. g , gamma ) ;
 53: 	color. b = pow ( color. b , gamma ) ;
 54: 	fo_FragColor = color ;
 55: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 56 with vertexShader tonemap and fragmentShader tonemap
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/tonemap.vs.hlsl
-----------------
  1: // filename renderprogs/tonemap.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: in vec4 in_Normal;
 11: in vec4 in_Tangent;
 12: in vec4 in_Color;
 13: 
 14: out vec2 vofi_TexCoord0;
 15: 
 16: void main() {
 17: 	gl_Position = in_Position ;
 18: 	vofi_TexCoord0 = in_TexCoord ;
 19: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/tonemap.ps.hlsl
-----------------
  1: // filename renderprogs/tonemap.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[2];
 18: 
 19: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 20: uniform sampler2D samp0;
 21: 
 22: in vec2 vofi_TexCoord0;
 23: 
 24: out vec4 fo_FragColor;
 25: 
 26: vec3 ACESFilm (vec3 x ) {
 27: 	float a = 2.51 ;
 28: 	float b = 0.03 ;
 29: 	float c = 2.43 ;
 30: 	float d = 0.59 ;
 31: 	float e = 0.14 ;
 32: 	return saturate ( ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e ) ) ;
 33: }
 34: void main() {
 35: 	vec2 tCoords = vofi_TexCoord0 ;
 36: 	vec4 color = texture ( samp0 , tCoords ) ;
 37: 	float Y = dot ( LUMINANCE_SRGB , color ) ;
 38: 	float hdrGamma = 2.2 ;
 39: 	float gamma = hdrGamma ;
 40: 	if ( Y < 0.1 )
 41: 	{
 42: 		fo_FragColor = vec4 ( 0.0 , 0.0 , 0.0 , 1.0 ) ;
 43: 		return ;
 44: 	}
 45: 	float hdrKey = _fa_[0 /* rpScreenCorrectionFactor */] . x ;
 46: 	float hdrAverageLuminance = _fa_[0 /* rpScreenCorrectionFactor */] . y ;
 47: 	float hdrMaxLuminance = _fa_[0 /* rpScreenCorrectionFactor */] . z ;
 48: 	float Yr = ( hdrKey * Y ) / hdrAverageLuminance ;
 49: 	float Ymax = hdrMaxLuminance ;
 50: 	float avgLuminance = max ( hdrAverageLuminance , 0.001 ) ;
 51: 	float linearExposure = ( hdrKey / avgLuminance ) ;
 52: 	float exposure = log2 ( max ( linearExposure , 0.0001 ) ) ;
 53: 	vec3 exposedColor = exp2 ( exposure ) * color. rgb ;
 54: 	color. rgb = ACESFilm ( exposedColor ) ;
 55: 	float hdrContrastThreshold = _fa_[1 /* rpOverbright */] . x ;
 56: 	float hdrContrastOffset = _fa_[1 /* rpOverbright */] . y ;
 57: 	float T = max ( Yr - hdrContrastThreshold , 0.0 ) ;
 58: 	float B = T > 0.0 ? T / ( hdrContrastOffset + T ) : T ;
 59: 	color. rgb *= clamp ( B , 0.0 , 1.0 ) ;
 60: 	gamma = 1.0 / hdrGamma ;
 61: 	color. r = pow ( color. r , gamma ) ;
 62: 	color. g = pow ( color. g , gamma ) ;
 63: 	color. b = pow ( color. b , gamma ) ;
 64: 	fo_FragColor = color ;
 65: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 57 with vertexShader tonemap and fragmentShader tonemap
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/hdr_glare_chromatic.vs.hlsl
-----------------
  1: // filename renderprogs/hdr_glare_chromatic.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: in vec4 in_Normal;
 11: in vec4 in_Tangent;
 12: in vec4 in_Color;
 13: 
 14: out vec2 vofi_TexCoord0;
 15: 
 16: void main() {
 17: 	gl_Position = in_Position ;
 18: 	vofi_TexCoord0 = in_TexCoord ;
 19: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/hdr_glare_chromatic.ps.hlsl
-----------------
  1: // filename renderprogs/hdr_glare_chromatic.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: uniform sampler2D samp0;
 20: 
 21: in vec2 vofi_TexCoord0;
 22: 
 23: out vec4 fo_FragColor;
 24: 
 25: void main() {
 26: 	vec2 st = vofi_TexCoord0 ;
 27: 	vec4 color = texture ( samp0 , st ) ;
 28: 	float gaussFact [ 9 ] = float [ 9 ] ( 0.13298076 , 0.12579441 , 0.10648267 , 0.08065691 , 0.05467002 , 0.03315905 , 0.01799699 , 0.00874063 , 0.00379866 ) ;
 29: 	vec3 chromaticOffsets [ 9 ] = vec3 [ ] (
 30: 	vec3 ( 0.5 , 0.5 , 0.5 ) ,
 31: 	vec3 ( 0.8 , 0.3 , 0.3 ) ,
 32: 	vec3 ( 0.5 , 0.2 , 0.8 ) ,
 33: 	vec3 ( 0.2 , 0.2 , 1.0 ) ,
 34: 	vec3 ( 0.2 , 0.3 , 0.9 ) ,
 35: 	vec3 ( 0.2 , 0.9 , 0.2 ) ,
 36: 	vec3 ( 0.3 , 0.5 , 0.3 ) ,
 37: 	vec3 ( 0.3 , 0.5 , 0.3 ) ,
 38: 	vec3 ( 0.3 , 0.5 , 0.3 )
 39: 	) ;
 40: 	vec3 sumColor = vec3 ( 0.0 ) ;
 41: 	vec3 sumSpectrum = vec3 ( 0.0 ) ;
 42: 	int tap = 4 ;
 43: 	int samples = 9 ;
 44: 	float scale = 13.0 ;
 45: 	float weightScale = 2.3 ;
 46: 	for ( int i = 0 ; i < samples ; i ++ )
 47: 	{
 48: 		vec3 so = chromaticOffsets [ i ] ;
 49: 		vec4 color = texture ( samp0 , st + vec2 ( float ( i ) , 0 ) * _fa_[0 /* rpWindowCoord */] . xy * scale ) ;
 50: 		float weight = gaussFact [ i ] ;
 51: 		sumColor += color. rgb * ( so. rgb * weight * weightScale ) ;
 52: 	}
 53: 	for ( int i = 1 ; i < samples ; i ++ )
 54: 	{
 55: 		vec3 so = chromaticOffsets [ i ] ;
 56: 		vec4 color = texture ( samp0 , st + vec2 ( float ( - i ) , 0 ) * _fa_[0 /* rpWindowCoord */] . xy * scale ) ;
 57: 		float weight = gaussFact [ i ] ;
 58: 		sumColor += color. rgb * ( so. rgb * weight * weightScale ) ;
 59: 	}
 60: 	fo_FragColor = vec4 ( sumColor , 1.0 ) ;
 61: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 58 with vertexShader hdr_glare_chromatic and fragmentShader hdr_glare_chromatic
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/tonemap.vs.hlsl
-----------------
  1: // filename renderprogs/tonemap.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: in vec4 in_Normal;
 11: in vec4 in_Tangent;
 12: in vec4 in_Color;
 13: 
 14: out vec2 vofi_TexCoord0;
 15: 
 16: void main() {
 17: 	gl_Position = in_Position ;
 18: 	vofi_TexCoord0 = in_TexCoord ;
 19: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/tonemap.ps.hlsl
-----------------
  1: // filename renderprogs/tonemap.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: const vec4 LUMINANCE_SRGB = vec4( 0.2125, 0.7154, 0.0721, 0.0 );
 20: uniform sampler2D samp0;
 21: 
 22: in vec2 vofi_TexCoord0;
 23: 
 24: out vec4 fo_FragColor;
 25: 
 26: vec3 ACESFilm (vec3 x ) {
 27: 	float a = 2.51 ;
 28: 	float b = 0.03 ;
 29: 	float c = 2.43 ;
 30: 	float d = 0.59 ;
 31: 	float e = 0.14 ;
 32: 	return saturate ( ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e ) ) ;
 33: }
 34: void main() {
 35: 	vec2 tCoords = vofi_TexCoord0 ;
 36: 	vec4 color = texture ( samp0 , tCoords ) ;
 37: 	float Y = dot ( LUMINANCE_SRGB , color ) ;
 38: 	float hdrGamma = 2.2 ;
 39: 	float gamma = hdrGamma ;
 40: 	float hdrKey = _fa_[0 /* rpScreenCorrectionFactor */] . x ;
 41: 	float hdrAverageLuminance = _fa_[0 /* rpScreenCorrectionFactor */] . y ;
 42: 	float hdrMaxLuminance = _fa_[0 /* rpScreenCorrectionFactor */] . z ;
 43: 	float Yr = ( hdrKey * Y ) / hdrAverageLuminance ;
 44: 	float Ymax = hdrMaxLuminance ;
 45: 	float avgLuminance = max ( hdrAverageLuminance , 0.001 ) ;
 46: 	float linearExposure = ( hdrKey / avgLuminance ) ;
 47: 	float exposure = log2 ( max ( linearExposure , 0.0001 ) ) ;
 48: 	vec3 exposedColor = exp2 ( exposure ) * color. rgb ;
 49: 	color. rgb = ACESFilm ( exposedColor ) ;
 50: 	gamma = 1.0 / hdrGamma ;
 51: 	color. r = pow ( color. r , gamma ) ;
 52: 	color. g = pow ( color. g , gamma ) ;
 53: 	color. b = pow ( color. b , gamma ) ;
 54: 	vec3 debugColors [ 16 ] = vec3 [ ] (
 55: 	vec3 ( 0.0 , 0.0 , 0.0 ) ,
 56: 	vec3 ( 0.0 , 0.0 , 0.1647 ) ,
 57: 	vec3 ( 0.0 , 0.0 , 0.3647 ) ,
 58: 	vec3 ( 0.0 , 0.0 , 0.6647 ) ,
 59: 	vec3 ( 0.0 , 0.0 , 0.9647 ) ,
 60: 	vec3 ( 0.0 , 0.9255 , 0.9255 ) ,
 61: 	vec3 ( 0.0 , 0.5647 , 0.0 ) ,
 62: 	vec3 ( 0.0 , 0.7843 , 0.0 ) ,
 63: 	vec3 ( 1.0 , 1.0 , 0.0 ) ,
 64: 	vec3 ( 0.90588 , 0.75294 , 0.0 ) ,
 65: 	vec3 ( 1.0 , 0.5647 , 0.0 ) ,
 66: 	vec3 ( 1.0 , 0.0 , 0.0 ) ,
 67: 	vec3 ( 0.8392 , 0.0 , 0.0 ) ,
 68: 	vec3 ( 1.0 , 0.0 , 1.0 ) ,
 69: 	vec3 ( 0.6 , 0.3333 , 0.7882 ) ,
 70: 	vec3 ( 1.0 , 1.0 , 1.0 )
 71: 	) ;
 72: 	float v = log2 ( Y / 0.18 ) ;
 73: 	v = clamp ( v + 5.0 , 0.0 , 15.0 ) ;
 74: 	int index = int ( floor ( v ) ) ;
 75: 	color. rgb = mix ( debugColors [ index ] , debugColors [ min ( 15 , index + 1 ) ] , fract ( v ) ) ;
 76: 	fo_FragColor = color ;
 77: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 59 with vertexShader tonemap and fragmentShader tonemap
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/SMAA_edge_detection.vs.hlsl
-----------------
  1: // filename renderprogs/SMAA_edge_detection.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[1];
  8: 
  9: void SMAAEdgeDetectionVS (vec2 texcoord ,
 10: out vec4 offset [ 3 ] ) {
 11: 	offset [ 0 ] = ( _va_[0 /* rpScreenCorrectionFactor */] . xyxy * vec4 ( - 1.0 , 0.0 , 0.0 , - 1.0 ) + texcoord. xyxy ) ;
 12: 	offset [ 1 ] = ( _va_[0 /* rpScreenCorrectionFactor */] . xyxy * vec4 ( 1.0 , 0.0 , 0.0 , 1.0 ) + texcoord. xyxy ) ;
 13: 	offset [ 2 ] = ( _va_[0 /* rpScreenCorrectionFactor */] . xyxy * vec4 ( - 2.0 , 0.0 , 0.0 , - 2.0 ) + texcoord. xyxy ) ;
 14: }
 15: 
 16: in vec4 in_Position;
 17: in vec2 in_TexCoord;
 18: in vec4 in_Normal;
 19: in vec4 in_Tangent;
 20: in vec4 in_Color;
 21: 
 22: out vec2 vofi_TexCoord0;
 23: out vec4 vofi_TexCoord1;
 24: out vec4 vofi_TexCoord2;
 25: out vec4 vofi_TexCoord3;
 26: 
 27: void main() {
 28: 	gl_Position = in_Position ;
 29: 	vec2 texcoord = in_TexCoord ;
 30: 	vofi_TexCoord0 = texcoord ;
 31: 	vec4 offset [ 3 ] ;
 32: 	SMAAEdgeDetectionVS ( texcoord , offset ) ;
 33: 	vofi_TexCoord1 = offset [ 0 ] ;
 34: 	vofi_TexCoord2 = offset [ 1 ] ;
 35: 	vofi_TexCoord3 = offset [ 2 ] ;
 36: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/SMAA_edge_detection.ps.hlsl
-----------------
  1: // filename renderprogs/SMAA_edge_detection.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: vec2 SMAALumaEdgeDetectionPS (vec2 texcoord ,
 17: vec4 offset [ 3 ] ,
 18: sampler2D colorTex
 19: ) {
 20: 	vec2 threshold = vec2 ( 0.1 , 0.1 ) ;
 21: 	vec3 weights = vec3 ( 0.2126 , 0.7152 , 0.0722 ) ;
 22: 	float L = dot ( texture ( colorTex , texcoord ). rgb , weights ) ;
 23: 	float Lleft = dot ( texture ( colorTex , offset [ 0 ]. xy ). rgb , weights ) ;
 24: 	float Ltop = dot ( texture ( colorTex , offset [ 0 ]. zw ). rgb , weights ) ;
 25: 	vec4 delta ;
 26: 	delta. xy = abs ( L - vec2 ( Lleft , Ltop ) ) ;
 27: 	vec2 edges = step ( threshold , delta. xy ) ;
 28: 	if ( dot ( edges , vec2 ( 1.0 , 1.0 ) ) == 0.0 )
 29: 	{
 30: 		discard ;
 31: 	}
 32: 	float Lright = dot ( texture ( colorTex , offset [ 1 ]. xy ). rgb , weights ) ;
 33: 	float Lbottom = dot ( texture ( colorTex , offset [ 1 ]. zw ). rgb , weights ) ;
 34: 	delta. zw = abs ( L - vec2 ( Lright , Lbottom ) ) ;
 35: 	vec2 maxDelta = max ( delta. xy , delta. zw ) ;
 36: 	float Lleftleft = dot ( texture ( colorTex , offset [ 2 ]. xy ). rgb , weights ) ;
 37: 	float Ltoptop = dot ( texture ( colorTex , offset [ 2 ]. zw ). rgb , weights ) ;
 38: 	delta. zw = abs ( vec2 ( Lleft , Ltop ) - vec2 ( Lleftleft , Ltoptop ) ) ;
 39: 	maxDelta = max ( maxDelta. xy , delta. zw ) ;
 40: 	float finalDelta = max ( maxDelta. x , maxDelta. y ) ;
 41: 	edges. xy *= step ( finalDelta , 2.0 * delta. xy ) ;
 42: 	return edges ;
 43: }
 44: uniform sampler2D samp0;
 45: 
 46: in vec2 vofi_TexCoord0;
 47: in vec4 vofi_TexCoord1;
 48: in vec4 vofi_TexCoord2;
 49: in vec4 vofi_TexCoord3;
 50: 
 51: out vec4 fo_FragColor;
 52: 
 53: void main() {
 54: 	vec2 tCoords = vofi_TexCoord0 ;
 55: 	vec4 offset [ 3 ] ;
 56: 	offset [ 0 ] = vofi_TexCoord1 ;
 57: 	offset [ 1 ] = vofi_TexCoord2 ;
 58: 	offset [ 2 ] = vofi_TexCoord3 ;
 59: 	vec4 color = vec4 ( 0.0 ) ;
 60: 	color. rg = SMAALumaEdgeDetectionPS ( tCoords ,
 61: 	offset ,
 62: 	samp0
 63: 	) ;
 64: 	fo_FragColor = color ;
 65: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 60 with vertexShader SMAA_edge_detection and fragmentShader SMAA_edge_detection
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/SMAA_blending_weight_calc.vs.hlsl
-----------------
  1: // filename renderprogs/SMAA_blending_weight_calc.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[1];
  8: 
  9: void SMAABlendingWeightCalculationVS (vec2 texcoord ,
 10: out vec2 pixcoord ,
 11: out vec4 offset [ 3 ] ) {
 12: 	pixcoord = texcoord * _va_[0 /* rpScreenCorrectionFactor */] . zw ;
 13: 	offset [ 0 ] = ( _va_[0 /* rpScreenCorrectionFactor */] . xyxy * vec4 ( - 0.25 , - 0.125 , 1.25 , - 0.125 ) + texcoord. xyxy ) ;
 14: 	offset [ 1 ] = ( _va_[0 /* rpScreenCorrectionFactor */] . xyxy * vec4 ( - 0.125 , - 0.25 , - 0.125 , 1.25 ) + texcoord. xyxy ) ;
 15: 	offset [ 2 ] = ( _va_[0 /* rpScreenCorrectionFactor */] . xxyy *
 16: 	vec4 ( - 2.0 , 2.0 , - 2.0 , 2.0 ) * float ( 16 ) +
 17: 	vec4 ( offset [ 0 ]. xz , offset [ 1 ]. yw ) ) ;
 18: }
 19: 
 20: in vec4 in_Position;
 21: in vec2 in_TexCoord;
 22: in vec4 in_Normal;
 23: in vec4 in_Tangent;
 24: in vec4 in_Color;
 25: 
 26: out vec2 vofi_TexCoord0;
 27: out vec4 vofi_TexCoord1;
 28: out vec4 vofi_TexCoord2;
 29: out vec4 vofi_TexCoord3;
 30: out vec4 vofi_TexCoord4;
 31: 
 32: void main() {
 33: 	gl_Position = in_Position ;
 34: 	vec2 texcoord = in_TexCoord ;
 35: 	vofi_TexCoord0 = texcoord ;
 36: 	vec4 offset [ 3 ] ;
 37: 	vec2 pixcoord ;
 38: 	SMAABlendingWeightCalculationVS ( texcoord , pixcoord , offset ) ;
 39: 	vofi_TexCoord1 = offset [ 0 ] ;
 40: 	vofi_TexCoord2 = offset [ 1 ] ;
 41: 	vofi_TexCoord3 = offset [ 2 ] ;
 42: 	vofi_TexCoord4 . st = pixcoord ;
 43: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/SMAA_blending_weight_calc.ps.hlsl
-----------------
  1: // filename renderprogs/SMAA_blending_weight_calc.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: void SMAAMovc (bvec2 cond , inout vec2 variable , vec2 value ) {if ( cond. x )
 20: 	{
 21: 		variable. x = value. x ;
 22: 	} if ( cond. y )
 23: 	{
 24: 		variable. y = value. y ;
 25: 	}
 26: }
 27: void SMAAMovc (bvec4 cond , inout vec4 variable , vec4 value ) {
 28: 	SMAAMovc ( cond. xy , variable. xy , value. xy ) ;
 29: 	SMAAMovc ( cond. zw , variable. zw , value. zw ) ;
 30: }
 31: vec2 SMAADecodeDiagBilinearAccess (vec2 e ) {
 32: 	e. r = e. r * abs ( 5.0 * e. r - 5.0 * 0.75 ) ;
 33: 	return round ( e ) ;
 34: }
 35: vec4 SMAADecodeDiagBilinearAccess (vec4 e ) {
 36: 	e. rb = e. rb * abs ( 5.0 * e. rb - 5.0 * 0.75 ) ;
 37: 	return round ( e ) ;
 38: }
 39: vec2 SMAASearchDiag1 (sampler2D edgesTex , vec2 texcoord , vec2 dir , out vec2 e ) {
 40: 	dir. y = dir. y ;
 41: 	vec4 coord = vec4 ( texcoord , - 1.0 , 1.0 ) ;
 42: 	vec3 t = vec3 ( _fa_[0 /* rpScreenCorrectionFactor */] . xy , 1.0 ) ;
 43: 	while ( coord. z < float ( 8 - 1 ) &&
 44: 	coord. w > 0.9 )
 45: 	{
 46: 		coord. xyz = ( t * vec3 ( dir , 1.0 ) + coord. xyz ) ;
 47: 		e = textureLod ( edgesTex , coord. xy , 0.0 ). rg ;
 48: 		coord. w = dot ( e , vec2 ( 0.5 , 0.5 ) ) ;
 49: 	}
 50: 	return coord. zw ;
 51: }
 52: vec2 SMAASearchDiag2 (sampler2D edgesTex , vec2 texcoord , vec2 dir , out vec2 e ) {
 53: 	dir. y = dir. y ;
 54: 	vec4 coord = vec4 ( texcoord , - 1.0 , 1.0 ) ;
 55: 	coord. x += 0.25 * _fa_[0 /* rpScreenCorrectionFactor */] . x ;
 56: 	vec3 t = vec3 ( _fa_[0 /* rpScreenCorrectionFactor */] . xy , 1.0 ) ;
 57: 	while ( coord. z < float ( 8 - 1 ) &&
 58: 	coord. w > 0.9 )
 59: 	{
 60: 		coord. xyz = ( t * vec3 ( dir , 1.0 ) + coord. xyz ) ;
 61: 		e = textureLod ( edgesTex , coord. xy , 0.0 ). rg ;
 62: 		e = SMAADecodeDiagBilinearAccess ( e ) ;
 63: 		coord. w = dot ( e , vec2 ( 0.5 , 0.5 ) ) ;
 64: 	}
 65: 	return coord. zw ;
 66: }
 67: vec2 SMAAAreaDiag (sampler2D areaTex , vec2 dist , vec2 e , float offset ) {
 68: 	vec2 texcoord = ( vec2 ( 20 , 20 ) * e + dist ) ;
 69: 	texcoord = ( ( 1.0 / vec2 ( 160.0 , 560.0 ) ) * texcoord + 0.5 * ( 1.0 / vec2 ( 160.0 , 560.0 ) ) ) ;
 70: 	texcoord. x += 0.5 ;
 71: 	texcoord. y += ( 1.0 / 7.0 ) * offset ;
 72: 	texcoord. y = texcoord. y ;
 73: 	return textureLod ( areaTex , texcoord , 0.0 ). rg ;
 74: }
 75: vec2 SMAACalculateDiagWeights (sampler2D edgesTex , sampler2D areaTex , vec2 texcoord , vec2 e , vec4 subsampleIndices ) {
 76: 	vec2 weights = vec2 ( 0.0 , 0.0 ) ;
 77: 	vec4 d ;
 78: 	vec2 end ;
 79: 	if ( e. r > 0.0 )
 80: 	{
 81: 		d. xz = SMAASearchDiag1 ( edgesTex , texcoord , vec2 ( - 1.0 , 1.0 ) , end ) ;
 82: 		d. x += float ( end. y > 0.9 ) ;
 83: 	}
 84: 	else
 85: 	{
 86: 		d. xz = vec2 ( 0.0 , 0.0 ) ;
 87: 	}
 88: 	d. yw = SMAASearchDiag1 ( edgesTex , texcoord , vec2 ( 1.0 , - 1.0 ) , end ) ;
 89: 	if ( d. x + d. y > 2.0 )
 90: 	{
 91: 		vec4 coords = ( vec4 ( - d. x + 0.25 , d. x , d. y , - d. y - 0.25 ) * _fa_[0 /* rpScreenCorrectionFactor */] . xyxy + texcoord. xyxy ) ;
 92: 		vec4 c ;
 93: 		c. xy = textureLodOffset ( edgesTex , coords. xy , 0.0 , ivec2 ( - 1 , 0 ) ). rg ;
 94: 		c. zw = textureLodOffset ( edgesTex , coords. zw , 0.0 , ivec2 ( 1 , 0 ) ). rg ;
 95: 		c. yxwz = SMAADecodeDiagBilinearAccess ( c. xyzw ) ;
 96: 		vec2 cc = ( vec2 ( 2.0 , 2.0 ) * c. xz + c. yw ) ;
 97: 		SMAAMovc ( bvec2 ( step ( 0.9 , d. zw ) ) , cc , vec2 ( 0.0 , 0.0 ) ) ;
 98: 		weights += SMAAAreaDiag ( areaTex , d. xy , cc , subsampleIndices. z ) ;
 99: 	}
100: 	d. xz = SMAASearchDiag2 ( edgesTex , texcoord , vec2 ( - 1.0 , - 1.0 ) , end ) ;
101: 	if ( textureLodOffset ( edgesTex , texcoord , 0.0 , ivec2 ( 1 , 0 ) ). r > 0.0 )
102: 	{
103: 		d. yw = SMAASearchDiag2 ( edgesTex , texcoord , vec2 ( 1.0 , 1.0 ) , end ) ;
104: 		d. y += float ( end. y > 0.9 ) ;
105: 	}
106: 	else
107: 	{
108: 		d. yw = vec2 ( 0.0 , 0.0 ) ;
109: 	}
110: 	if ( d. x + d. y > 2.0 )
111: 	{
112: 		vec4 coords = ( vec4 ( - d. x , - d. x , d. y , d. y ) * _fa_[0 /* rpScreenCorrectionFactor */] . xyxy + texcoord. xyxy ) ;
113: 		vec4 c ;
114: 		c. x = textureLodOffset ( edgesTex , coords. xy , 0.0 , ivec2 ( - 1 , 0 ) ). g ;
115: 		c. y = textureLodOffset ( edgesTex , coords. xy , 0.0 , ivec2 ( 0 , - 1 ) ). r ;
116: 		c. zw = textureLodOffset ( edgesTex , coords. zw , 0.0 , ivec2 ( 1 , 0 ) ). gr ;
117: 		vec2 cc = ( vec2 ( 2.0 , 2.0 ) * c. xz + c. yw ) ;
118: 		SMAAMovc ( bvec2 ( step ( 0.9 , d. zw ) ) , cc , vec2 ( 0.0 , 0.0 ) ) ;
119: 		weights += SMAAAreaDiag ( areaTex , d. xy , cc , subsampleIndices. w ). gr ;
120: 	}
121: 	return weights ;
122: }
123: float SMAASearchLength (sampler2D searchTex , vec2 e , float offset ) {
124: 	vec2 scale = vec2 ( 66.0 , 33.0 ) * vec2 ( 0.5 , - 1.0 ) ;
125: 	vec2 bias = vec2 ( 66.0 , 33.0 ) * vec2 ( offset , 1.0 ) ;
126: 	scale += vec2 ( - 1.0 , 1.0 ) ;
127: 	bias += vec2 ( 0.5 , - 0.5 ) ;
128: 	scale *= 1.0 / vec2 ( 64.0 , 16.0 ) ;
129: 	bias *= 1.0 / vec2 ( 64.0 , 16.0 ) ;
130: 	vec2 coord = ( scale * e + bias ) ;
131: 	coord. y = coord. y ;
132: 	return textureLod ( searchTex , coord , 0.0 ). r ;
133: }
134: float SMAASearchXLeft (sampler2D edgesTex , sampler2D searchTex , vec2 texcoord , float end ) {
135: 	vec2 e = vec2 ( 0.0 , 1.0 ) ;
136: 	while ( texcoord. x > end &&
137: 	e. g > 0.8281 &&
138: 	e. r == 0.0 )
139: 	{
140: 		e = textureLod ( edgesTex , texcoord , 0.0 ). rg ;
141: 		texcoord = ( - vec2 ( 2.0 , 0.0 ) * _fa_[0 /* rpScreenCorrectionFactor */] . xy + texcoord ) ;
142: 	}
143: 	float offset = ( - ( 255.0 / 127.0 ) * SMAASearchLength ( searchTex , e , 0.0 ) + 3.25 ) ;
144: 	return ( _fa_[0 /* rpScreenCorrectionFactor */] . x * offset + texcoord. x ) ;
145: }
146: float SMAASearchXRight (sampler2D edgesTex , sampler2D searchTex , vec2 texcoord , float end ) {
147: 	vec2 e = vec2 ( 0.0 , 1.0 ) ;
148: 	while ( texcoord. x < end &&
149: 	e. g > 0.8281 &&
150: 	e. r == 0.0 )
151: 	{
152: 		e = textureLod ( edgesTex , texcoord , 0.0 ). rg ;
153: 		texcoord = ( vec2 ( 2.0 , 0.0 ) * _fa_[0 /* rpScreenCorrectionFactor */] . xy + texcoord ) ;
154: 	}
155: 	float offset = ( - ( 255.0 / 127.0 ) * SMAASearchLength ( searchTex , e , 0.5 ) + 3.25 ) ;
156: 	return ( - _fa_[0 /* rpScreenCorrectionFactor */] . x * offset + texcoord. x ) ;
157: }
158: float SMAASearchYUp (sampler2D edgesTex , sampler2D searchTex , vec2 texcoord , float end ) {
159: 	vec2 e = vec2 ( 1.0 , 0.0 ) ;
160: 	while ( texcoord. y > end &&
161: 	e. r > 0.8281 &&
162: 	e. g == 0.0 )
163: 	{
164: 		e = textureLod ( edgesTex , texcoord , 0.0 ). rg ;
165: 		texcoord = ( - vec2 ( 0.0 , 2.0 ) * _fa_[0 /* rpScreenCorrectionFactor */] . xy + texcoord ) ;
166: 	}
167: 	float offset = ( - ( 255.0 / 127.0 ) * SMAASearchLength ( searchTex , e. gr , 0.0 ) + 3.25 ) ;
168: 	return ( _fa_[0 /* rpScreenCorrectionFactor */] . y * offset + texcoord. y ) ;
169: }
170: float SMAASearchYDown (sampler2D edgesTex , sampler2D searchTex , vec2 texcoord , float end ) {
171: 	vec2 e = vec2 ( 1.0 , 0.0 ) ;
172: 	while ( texcoord. y < end &&
173: 	e. r > 0.8281 &&
174: 	e. g == 0.0 )
175: 	{
176: 		e = textureLod ( edgesTex , texcoord , 0.0 ). rg ;
177: 		texcoord = ( vec2 ( 0.0 , 2.0 ) * _fa_[0 /* rpScreenCorrectionFactor */] . xy + texcoord ) ;
178: 	}
179: 	float offset = ( - ( 255.0 / 127.0 ) * SMAASearchLength ( searchTex , e. gr , 0.5 ) + 3.25 ) ;
180: 	return ( - _fa_[0 /* rpScreenCorrectionFactor */] . y * offset + texcoord. y ) ;
181: }
182: vec2 SMAAArea (sampler2D areaTex , vec2 dist , float e1 , float e2 , float offset ) {
183: 	vec2 texcoord = ( vec2 ( 16 , 16 ) * round ( 4.0 * vec2 ( e1 , e2 ) ) + dist ) ;
184: 	texcoord = ( ( 1.0 / vec2 ( 160.0 , 560.0 ) ) * texcoord + 0.5 * ( 1.0 / vec2 ( 160.0 , 560.0 ) ) ) ;
185: 	texcoord. y = ( ( 1.0 / 7.0 ) * offset + texcoord. y ) ;
186: 	texcoord. y = texcoord. y ;
187: 	return textureLod ( areaTex , texcoord , 0.0 ). rg ;
188: }
189: void SMAADetectHorizontalCornerPattern (sampler2D edgesTex , inout vec2 weights , vec4 texcoord , vec2 d ) {
190: 	vec2 leftRight = step ( d. xy , d. yx ) ;
191: 	vec2 rounding = ( 1.0 - ( float ( 25 ) / 100.0 ) ) * leftRight ;
192: 	rounding /= leftRight. x + leftRight. y ;
193: 	vec2 factor = vec2 ( 1.0 , 1.0 ) ;
194: 	factor. x -= rounding. x * textureLodOffset ( edgesTex , texcoord. xy , 0.0 , ivec2 ( 0 , 1 ) ). r ;
195: 	factor. x -= rounding. y * textureLodOffset ( edgesTex , texcoord. zw , 0.0 , ivec2 ( 1 , 1 ) ). r ;
196: 	factor. y -= rounding. x * textureLodOffset ( edgesTex , texcoord. xy , 0.0 , ivec2 ( 0 , - 2 ) ). r ;
197: 	factor. y -= rounding. y * textureLodOffset ( edgesTex , texcoord. zw , 0.0 , ivec2 ( 1 , - 2 ) ). r ;
198: 	weights *= clamp ( factor , 0.0 , 10.0 ) ;
199: }
200: void SMAADetectVerticalCornerPattern (sampler2D edgesTex , inout vec2 weights , vec4 texcoord , vec2 d ) {
201: 	vec2 leftRight = step ( d. xy , d. yx ) ;
202: 	vec2 rounding = ( 1.0 - ( float ( 25 ) / 100.0 ) ) * leftRight ;
203: 	rounding /= leftRight. x + leftRight. y ;
204: 	vec2 factor = vec2 ( 1.0 , 1.0 ) ;
205: 	factor. x -= rounding. x * textureLodOffset ( edgesTex , texcoord. xy , 0.0 , ivec2 ( 1 , 0 ) ). g ;
206: 	factor. x -= rounding. y * textureLodOffset ( edgesTex , texcoord. zw , 0.0 , ivec2 ( 1 , 1 ) ). g ;
207: 	factor. y -= rounding. x * textureLodOffset ( edgesTex , texcoord. xy , 0.0 , ivec2 ( - 2 , 0 ) ). g ;
208: 	factor. y -= rounding. y * textureLodOffset ( edgesTex , texcoord. zw , 0.0 , ivec2 ( - 2 , 1 ) ). g ;
209: 	weights *= clamp ( factor , 0.0 , 10.0 ) ;
210: }
211: vec4 SMAABlendingWeightCalculationPS (vec2 texcoord ,
212: vec2 pixcoord ,
213: vec4 offset [ 3 ] ,
214: sampler2D edgesTex ,
215: sampler2D areaTex ,
216: sampler2D searchTex ,
217: vec4 subsampleIndices ) {
218: 	vec4 weights = vec4 ( 0.0 , 0.0 , 0.0 , 0.0 ) ;
219: 	vec2 e = texture ( edgesTex , texcoord ). rg ;
220: 	if ( e. g > 0.0 )
221: 	{
222: 		weights. rg = SMAACalculateDiagWeights ( edgesTex , areaTex , texcoord , e , subsampleIndices ) ;
223: 		if ( weights. r == - weights. g )
224: 		{
225: 			vec2 d ;
226: 			vec3 coords ;
227: 			coords. x = SMAASearchXLeft ( edgesTex , searchTex , offset [ 0 ]. xy , offset [ 2 ]. x ) ;
228: 			coords. y = offset [ 1 ]. y ;
229: 			d. x = coords. x ;
230: 			float e1 = textureLod ( edgesTex , coords. xy , 0.0 ). r ;
231: 			coords. z = SMAASearchXRight ( edgesTex , searchTex , offset [ 0 ]. zw , offset [ 2 ]. y ) ;
232: 			d. y = coords. z ;
233: 			d = abs ( round ( ( _fa_[0 /* rpScreenCorrectionFactor */] . zz * d + - pixcoord. xx ) ) ) ;
234: 			vec2 sqrt_d = sqrt ( d ) ;
235: 			float e2 = textureLodOffset ( edgesTex , coords. zy , 0.0 , ivec2 ( 1 , 0 ) ). r ;
236: 			weights. rg = SMAAArea ( areaTex , sqrt_d , e1 , e2 , subsampleIndices. y ) ;
237: 			coords. y = texcoord. y ;
238: 			SMAADetectHorizontalCornerPattern ( edgesTex , weights. rg , coords. xyzy , d ) ;
239: 		}
240: 		else
241: 		{
242: 			e. r = 0.0 ;
243: 		}
244: 	}
245: 	if ( e. r > 0.0 )
246: 	{
247: 		vec2 d ;
248: 		vec3 coords ;
249: 		coords. y = SMAASearchYUp ( edgesTex , searchTex , offset [ 1 ]. xy , offset [ 2 ]. z ) ;
250: 		coords. x = offset [ 0 ]. x ;
251: 		d. x = coords. y ;
252: 		float e1 = textureLod ( edgesTex , coords. xy , 0.0 ). g ;
253: 		coords. z = SMAASearchYDown ( edgesTex , searchTex , offset [ 1 ]. zw , offset [ 2 ]. w ) ;
254: 		d. y = coords. z ;
255: 		d = abs ( round ( ( _fa_[0 /* rpScreenCorrectionFactor */] . ww * d + - pixcoord. yy ) ) ) ;
256: 		vec2 sqrt_d = sqrt ( d ) ;
257: 		float e2 = textureLodOffset ( edgesTex , coords. xz , 0.0 , ivec2 ( 0 , 1 ) ). g ;
258: 		weights. ba = SMAAArea ( areaTex , sqrt_d , e1 , e2 , subsampleIndices. x ) ;
259: 		coords. x = texcoord. x ;
260: 		SMAADetectVerticalCornerPattern ( edgesTex , weights. ba , coords. xyxz , d ) ;
261: 	}
262: 	return weights ;
263: }
264: uniform sampler2D samp0;
265: uniform sampler2D samp1;
266: uniform sampler2D samp2;
267: 
268: in vec2 vofi_TexCoord0;
269: in vec4 vofi_TexCoord1;
270: in vec4 vofi_TexCoord2;
271: in vec4 vofi_TexCoord3;
272: in vec4 vofi_TexCoord4;
273: 
274: out vec4 fo_FragColor;
275: 
276: void main() {
277: 	vec2 texcoord = vofi_TexCoord0 ;
278: 	vec4 offset [ 3 ] ;
279: 	offset [ 0 ] = vofi_TexCoord1 ;
280: 	offset [ 1 ] = vofi_TexCoord2 ;
281: 	offset [ 2 ] = vofi_TexCoord3 ;
282: 	vec2 pixcoord = vofi_TexCoord4 . st ;
283: 	vec4 subsampleIndices = vec4 ( 0.0 , 0.0 , 0.0 , 0.0 ) ;
284: 	vec4 color = SMAABlendingWeightCalculationPS ( texcoord ,
285: 	pixcoord ,
286: 	offset ,
287: 	samp0 ,
288: 	samp1 ,
289: 	samp2 ,
290: 	subsampleIndices ) ;
291: 	fo_FragColor = color ;
292: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 61 with vertexShader SMAA_blending_weight_calc and fragmentShader SMAA_blending_weight_calc
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/SMAA_final.vs.hlsl
-----------------
  1: // filename renderprogs/SMAA_final.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[1];
  8: 
  9: void SMAANeighborhoodBlendingVS (vec2 texcoord ,
 10: out vec4 offset ) {
 11: 	offset = ( _va_[0 /* rpScreenCorrectionFactor */] . xyxy * vec4 ( 1.0 , 0.0 , 0.0 , 1.0 ) + texcoord. xyxy ) ;
 12: }
 13: 
 14: in vec4 in_Position;
 15: in vec2 in_TexCoord;
 16: in vec4 in_Normal;
 17: in vec4 in_Tangent;
 18: in vec4 in_Color;
 19: 
 20: out vec2 vofi_TexCoord0;
 21: out vec4 vofi_TexCoord1;
 22: 
 23: void main() {
 24: 	gl_Position = in_Position ;
 25: 	vofi_TexCoord0 = in_TexCoord ;
 26: 	vec4 offset ;
 27: 	SMAANeighborhoodBlendingVS ( in_TexCoord , offset ) ;
 28: 	vofi_TexCoord1 = offset ;
 29: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/SMAA_final.ps.hlsl
-----------------
  1: // filename renderprogs/SMAA_final.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: void SMAAMovc (bvec2 cond , inout vec2 variable , vec2 value ) {if ( cond. x )
 20: 	{
 21: 		variable. x = value. x ;
 22: 	} if ( cond. y )
 23: 	{
 24: 		variable. y = value. y ;
 25: 	}
 26: }
 27: void SMAAMovc (bvec4 cond , inout vec4 variable , vec4 value ) {
 28: 	SMAAMovc ( cond. xy , variable. xy , value. xy ) ;
 29: 	SMAAMovc ( cond. zw , variable. zw , value. zw ) ;
 30: }
 31: vec4 SMAANeighborhoodBlendingPS (vec2 texcoord ,
 32: vec4 offset ,
 33: sampler2D colorTex ,
 34: sampler2D blendTex
 35: ) {
 36: 	vec4 a ;
 37: 	a. x = texture ( blendTex , offset. xy ). a ;
 38: 	a. y = texture ( blendTex , offset. zw ). g ;
 39: 	a. wz = texture ( blendTex , texcoord ). xz ;
 40: 	if ( dot ( a , vec4 ( 1.0 , 1.0 , 1.0 , 1.0 ) ) < 1e-5 )
 41: 	{
 42: 		vec4 color = textureLod ( colorTex , texcoord , 0.0 ) ;
 43: 		return color ;
 44: 	}
 45: 	else
 46: 	{
 47: 		bool h = max ( a. x , a. z ) > max ( a. y , a. w ) ;
 48: 		vec4 blendingOffset = vec4 ( 0.0 , a. y , 0.0 , a. w ) ;
 49: 		vec2 blendingWeight = a. yw ;
 50: 		SMAAMovc ( bvec4 ( h , h , h , h ) , blendingOffset , vec4 ( a. x , 0.0 , a. z , 0.0 ) ) ;
 51: 		SMAAMovc ( bvec2 ( h , h ) , blendingWeight , a. xz ) ;
 52: 		blendingWeight /= dot ( blendingWeight , vec2 ( 1.0 , 1.0 ) ) ;
 53: 		vec4 blendingCoord = ( blendingOffset * vec4 ( _fa_[0 /* rpScreenCorrectionFactor */] . xy , - _fa_[0 /* rpScreenCorrectionFactor */] . xy ) + texcoord. xyxy ) ;
 54: 		vec4 color = blendingWeight. x * textureLod ( colorTex , blendingCoord. xy , 0.0 ) ;
 55: 		color += blendingWeight. y * textureLod ( colorTex , blendingCoord. zw , 0.0 ) ;
 56: 		return color ;
 57: 	}
 58: }
 59: uniform sampler2D samp0;
 60: uniform sampler2D samp1;
 61: 
 62: in vec2 vofi_TexCoord0;
 63: in vec4 vofi_TexCoord1;
 64: 
 65: out vec4 fo_FragColor;
 66: 
 67: void main() {
 68: 	vec2 texcoord = vofi_TexCoord0 ;
 69: 	vec4 offset = vofi_TexCoord1 ;
 70: 	vec4 color = SMAANeighborhoodBlendingPS ( texcoord ,
 71: 	offset ,
 72: 	samp0 ,
 73: 	samp1
 74: 	) ;
 75: 	fo_FragColor = color ;
 76: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 62 with vertexShader SMAA_final and fragmentShader SMAA_final
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/AmbientOcclusion_AO.vs.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_AO.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: 
 11: out vec2 vofi_TexCoord0;
 12: 
 13: void main() {
 14: 	gl_Position = in_Position ;
 15: 	vofi_TexCoord0 = in_TexCoord ;
 16: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/AmbientOcclusion_AO.ps.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_AO.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[7];
 18: 
 19: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 20: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 21: const float DOOM_TO_METERS = 0.0254;
 22: const float METERS_TO_DOOM = ( 1.0 / DOOM_TO_METERS );
 23: const float radius = 1.0 * METERS_TO_DOOM;
 24: const float radius2 = radius * radius;
 25: const float invRadius2 = 1.0 / radius2;
 26: const float bias = 0.01 * METERS_TO_DOOM;
 27: const float intensity = 0.6;
 28: const float projScale = 500.0;
 29: uniform sampler2D samp0;
 30: uniform sampler2D samp1;
 31: uniform sampler2D samp2;
 32: 
 33: in vec2 vofi_TexCoord0;
 34: 
 35: out vec4 fo_FragColor;
 36: 
 37: float BlueNoise (vec2 n , float x ) {
 38: 	float noise = texture ( samp2 , n. xy * _fa_[6 /* rpJitterTexOffset */] . xy ). r ;
 39: 	noise = fract ( noise ) ;
 40: 	return noise ;
 41: }
 42: vec3 reconstructCSPosition (vec2 S , float z ) {
 43: 	vec4 P ;
 44: 	P. z = z * 2.0 - 1.0 ;
 45: 	P. xy = ( S * _fa_[1 /* rpWindowCoord */] . xy ) * 2.0 - 1.0 ;
 46: 	P. w = 1.0 ;
 47: 	vec4 csP ;
 48: 	csP. x = dot4 ( P , _fa_[2 /* rpModelMatrixX */] ) ;
 49: 	csP. y = dot4 ( P , _fa_[3 /* rpModelMatrixY */] ) ;
 50: 	csP. z = dot4 ( P , _fa_[4 /* rpModelMatrixZ */] ) ;
 51: 	csP. w = dot4 ( P , _fa_[5 /* rpModelMatrixW */] ) ;
 52: 	csP. xyz /= csP. w ;
 53: 	return csP. xyz ;
 54: }
 55: vec3 sampleNormal (sampler2D normalBuffer , ivec2 ssC , int mipLevel ) {
 56: 	return texelFetch ( normalBuffer , ssC , mipLevel ). xyz * 2.0 - 1.0 ;
 57: }
 58: vec2 tapLocation (int sampleNumber , float spinAngle , out float ssR ) {
 59: 	float alpha = ( float ( sampleNumber ) + 0.5 ) * ( 1.0 / float ( 11 ) ) ;
 60: 	float angle = alpha * ( float ( 7 ) * 6.28 ) + spinAngle ;
 61: 	ssR = alpha ;
 62: 	return vec2 ( cos ( angle ) , sin ( angle ) ) ;
 63: }
 64: vec3 getPosition (ivec2 ssP , sampler2D cszBuffer ) {
 65: 	vec3 P ;
 66: 	P. z = texelFetch ( cszBuffer , ssP , 0 ). r ;
 67: 	P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , P. z ) ;
 68: 	return P ;
 69: }
 70: void computeMipInfo (float ssR , ivec2 ssP , sampler2D cszBuffer , out int mipLevel , out ivec2 mipP ) {
 71: 	mipLevel = clamp ( int ( floor ( log2 ( ssR ) ) ) - ( 3 ) , 0 , ( 5 ) ) ;
 72: 	mipP = clamp ( ssP >> mipLevel , ivec2 ( 0 ) , textureSize ( cszBuffer , mipLevel ) - ivec2 ( 1 ) ) ;
 73: }
 74: vec3 getOffsetPosition (ivec2 issC , vec2 unitOffset , float ssR , sampler2D cszBuffer , float invCszBufferScale ) {
 75: 	ivec2 ssP = ivec2 ( ssR * unitOffset ) + issC ;
 76: 	vec3 P ;
 77: 	int mipLevel ;
 78: 	ivec2 mipP ;
 79: 	computeMipInfo ( ssR , ssP , cszBuffer , mipLevel , mipP ) ;
 80: 	P. z = texelFetch ( cszBuffer , mipP , mipLevel ). r ;
 81: 	P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , P. z ) ;
 82: 	return P ;
 83: }
 84: float fallOffFunction (float vv , float vn , float epsilon ) {
 85: 	float f = max ( 1.0 - vv * invRadius2 , 0.0 ) ;
 86: 	return f * max ( ( vn - bias ) * inversesqrt ( epsilon + vv ) , 0.0 ) ;
 87: }
 88: float aoValueFromPositionsAndNormal (vec3 C , vec3 n_C , vec3 Q ) {
 89: 	vec3 v = Q - C ;
 90: 	float vv = dot ( v , v ) ;
 91: 	float vn = dot ( v , n_C ) ;
 92: 	const float epsilon = 0.001 ;
 93: 	return fallOffFunction ( vv , vn , epsilon ) * mix ( 1.0 , max ( 0.0 , 1.5 * n_C. z ) , 0.35 ) ;
 94: }
 95: float sampleAO (ivec2 issC , in vec3 C , in vec3 n_C , in float ssDiskRadius , in int tapIndex , in float randomPatternRotationAngle , in sampler2D cszBuffer , in float invCszBufferScale ) {
 96: 	float ssR ;
 97: 	vec2 unitOffset = tapLocation ( tapIndex , randomPatternRotationAngle , ssR ) ;
 98: 	ssR = max ( 0.75 , ssR * ssDiskRadius ) ;
 99: 	vec3 Q = getOffsetPosition ( issC , unitOffset , ssR , cszBuffer , invCszBufferScale ) ;
100: 	return aoValueFromPositionsAndNormal ( C , n_C , Q ) ;
101: }
102: const float MIN_RADIUS = 3.0;
103: void main() {
104: 	fo_FragColor = vec4 ( 1.0 , 0.0 , 0.0 , 1.0 ) ;
105: 	vec2 ssC = vofi_TexCoord0 * _fa_[0 /* rpScreenCorrectionFactor */] . xy ;
106: 	ivec2 ssP = ivec2 ( ssC. x * _fa_[1 /* rpWindowCoord */] . z , ssC. y * _fa_[1 /* rpWindowCoord */] . w ) ;
107: 	vec3 C = getPosition ( ssP , samp1 ) ;
108: 	fo_FragColor . r = 0.0 ;
109: 	vec3 n_C = sampleNormal ( samp0 , ssP , 0 ) ;
110: 	if ( length ( n_C ) < 0.01 )
111: 	{
112: 		fo_FragColor . r = 1.0 ;
113: 		return ;
114: 	}
115: 	n_C = normalize ( n_C ) ;
116: 	float randomPatternRotationAngle = BlueNoise ( ssP. xy , 10.0 ) * 10.0 ;
117: 	float ssDiskRadius = - projScale * radius / C. z ;
118: 	if ( ssDiskRadius <= MIN_RADIUS )
119: 	{
120: 		fo_FragColor . r = 1.0 ;
121: 		return ;
122: 	}
123: 	float sum = 0.0 ;
124: 	for ( int i = 0 ; i < 11 ; ++ i )
125: 	{
126: 		sum += sampleAO ( ssP , C , n_C , ssDiskRadius , i , randomPatternRotationAngle , samp1 , 1.0 ) ;
127: 	}
128: 	float A = pow ( max ( 0.0 , 1.0 - sqrt ( sum * ( 3.0 / float ( 11 ) ) ) ) , intensity ) ;
129: 	fo_FragColor . r = mix ( 1.0 , A , saturate ( ssDiskRadius - MIN_RADIUS ) ) ;
130: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 63 with vertexShader AmbientOcclusion_AO and fragmentShader AmbientOcclusion_AO
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/AmbientOcclusion_AO.vs.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_AO.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: 
 11: out vec2 vofi_TexCoord0;
 12: 
 13: void main() {
 14: 	gl_Position = in_Position ;
 15: 	vofi_TexCoord0 = in_TexCoord ;
 16: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/AmbientOcclusion_AO.ps.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_AO.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[7];
 18: 
 19: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 20: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 21: const float DOOM_TO_METERS = 0.0254;
 22: const float METERS_TO_DOOM = ( 1.0 / DOOM_TO_METERS );
 23: const float radius = 1.0 * METERS_TO_DOOM;
 24: const float radius2 = radius * radius;
 25: const float invRadius2 = 1.0 / radius2;
 26: const float bias = 0.01 * METERS_TO_DOOM;
 27: const float intensity = 0.6;
 28: const float projScale = 500.0;
 29: uniform sampler2D samp0;
 30: uniform sampler2D samp1;
 31: uniform sampler2D samp2;
 32: 
 33: in vec2 vofi_TexCoord0;
 34: 
 35: out vec4 fo_FragColor;
 36: 
 37: float BlueNoise (vec2 n , float x ) {
 38: 	float noise = texture ( samp2 , n. xy * _fa_[6 /* rpJitterTexOffset */] . xy ). r ;
 39: 	noise = fract ( noise ) ;
 40: 	return noise ;
 41: }
 42: vec3 reconstructCSPosition (vec2 S , float z ) {
 43: 	vec4 P ;
 44: 	P. z = z * 2.0 - 1.0 ;
 45: 	P. xy = ( S * _fa_[1 /* rpWindowCoord */] . xy ) * 2.0 - 1.0 ;
 46: 	P. w = 1.0 ;
 47: 	vec4 csP ;
 48: 	csP. x = dot4 ( P , _fa_[2 /* rpModelMatrixX */] ) ;
 49: 	csP. y = dot4 ( P , _fa_[3 /* rpModelMatrixY */] ) ;
 50: 	csP. z = dot4 ( P , _fa_[4 /* rpModelMatrixZ */] ) ;
 51: 	csP. w = dot4 ( P , _fa_[5 /* rpModelMatrixW */] ) ;
 52: 	csP. xyz /= csP. w ;
 53: 	return csP. xyz ;
 54: }
 55: vec3 sampleNormal (sampler2D normalBuffer , ivec2 ssC , int mipLevel ) {
 56: 	return texelFetch ( normalBuffer , ssC , mipLevel ). xyz * 2.0 - 1.0 ;
 57: }
 58: vec2 tapLocation (int sampleNumber , float spinAngle , out float ssR ) {
 59: 	float alpha = ( float ( sampleNumber ) + 0.5 ) * ( 1.0 / float ( 11 ) ) ;
 60: 	float angle = alpha * ( float ( 7 ) * 6.28 ) + spinAngle ;
 61: 	ssR = alpha ;
 62: 	return vec2 ( cos ( angle ) , sin ( angle ) ) ;
 63: }
 64: vec3 getPosition (ivec2 ssP , sampler2D cszBuffer ) {
 65: 	vec3 P ;
 66: 	P. z = texelFetch ( cszBuffer , ssP , 0 ). r ;
 67: 	P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , P. z ) ;
 68: 	return P ;
 69: }
 70: void computeMipInfo (float ssR , ivec2 ssP , sampler2D cszBuffer , out int mipLevel , out ivec2 mipP ) {
 71: 	mipLevel = clamp ( int ( floor ( log2 ( ssR ) ) ) - ( 3 ) , 0 , ( 5 ) ) ;
 72: 	mipP = clamp ( ssP >> mipLevel , ivec2 ( 0 ) , textureSize ( cszBuffer , mipLevel ) - ivec2 ( 1 ) ) ;
 73: }
 74: vec3 getOffsetPosition (ivec2 issC , vec2 unitOffset , float ssR , sampler2D cszBuffer , float invCszBufferScale ) {
 75: 	ivec2 ssP = ivec2 ( ssR * unitOffset ) + issC ;
 76: 	vec3 P ;
 77: 	int mipLevel ;
 78: 	ivec2 mipP ;
 79: 	computeMipInfo ( ssR , ssP , cszBuffer , mipLevel , mipP ) ;
 80: 	P. z = texelFetch ( cszBuffer , mipP , mipLevel ). r ;
 81: 	P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , P. z ) ;
 82: 	return P ;
 83: }
 84: float fallOffFunction (float vv , float vn , float epsilon ) {
 85: 	float f = max ( 1.0 - vv * invRadius2 , 0.0 ) ;
 86: 	return f * max ( ( vn - bias ) * inversesqrt ( epsilon + vv ) , 0.0 ) ;
 87: }
 88: float aoValueFromPositionsAndNormal (vec3 C , vec3 n_C , vec3 Q ) {
 89: 	vec3 v = Q - C ;
 90: 	float vv = dot ( v , v ) ;
 91: 	float vn = dot ( v , n_C ) ;
 92: 	const float epsilon = 0.001 ;
 93: 	return fallOffFunction ( vv , vn , epsilon ) * mix ( 1.0 , max ( 0.0 , 1.5 * n_C. z ) , 0.35 ) ;
 94: }
 95: float sampleAO (ivec2 issC , in vec3 C , in vec3 n_C , in float ssDiskRadius , in int tapIndex , in float randomPatternRotationAngle , in sampler2D cszBuffer , in float invCszBufferScale ) {
 96: 	float ssR ;
 97: 	vec2 unitOffset = tapLocation ( tapIndex , randomPatternRotationAngle , ssR ) ;
 98: 	ssR = max ( 0.75 , ssR * ssDiskRadius ) ;
 99: 	vec3 Q = getOffsetPosition ( issC , unitOffset , ssR , cszBuffer , invCszBufferScale ) ;
100: 	return aoValueFromPositionsAndNormal ( C , n_C , Q ) ;
101: }
102: const float MIN_RADIUS = 3.0;
103: void main() {
104: 	fo_FragColor = vec4 ( 1.0 , 0.0 , 0.0 , 1.0 ) ;
105: 	vec2 ssC = vofi_TexCoord0 * _fa_[0 /* rpScreenCorrectionFactor */] . xy ;
106: 	ivec2 ssP = ivec2 ( ssC. x * _fa_[1 /* rpWindowCoord */] . z , ssC. y * _fa_[1 /* rpWindowCoord */] . w ) ;
107: 	vec3 C = getPosition ( ssP , samp1 ) ;
108: 	fo_FragColor . r = 0.0 ;
109: 	vec3 n_C = sampleNormal ( samp0 , ssP , 0 ) ;
110: 	if ( length ( n_C ) < 0.01 )
111: 	{
112: 		fo_FragColor . r = 1.0 ;
113: 		return ;
114: 	}
115: 	n_C = normalize ( n_C ) ;
116: 	float randomPatternRotationAngle = BlueNoise ( ssP. xy , 10.0 ) * 10.0 ;
117: 	float ssDiskRadius = - projScale * radius / C. z ;
118: 	if ( ssDiskRadius <= MIN_RADIUS )
119: 	{
120: 		fo_FragColor . r = 1.0 ;
121: 		return ;
122: 	}
123: 	float sum = 0.0 ;
124: 	for ( int i = 0 ; i < 11 ; ++ i )
125: 	{
126: 		sum += sampleAO ( ssP , C , n_C , ssDiskRadius , i , randomPatternRotationAngle , samp1 , 1.0 ) ;
127: 	}
128: 	float A = pow ( max ( 0.0 , 1.0 - sqrt ( sum * ( 3.0 / float ( 11 ) ) ) ) , intensity ) ;
129: 	fo_FragColor . r = mix ( 1.0 , A , saturate ( ssDiskRadius - MIN_RADIUS ) ) ;
130: 	fo_FragColor = vec4 ( fo_FragColor . r , fo_FragColor . r , fo_FragColor . r , 1.0 ) ;
131: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 64 with vertexShader AmbientOcclusion_AO and fragmentShader AmbientOcclusion_AO
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/AmbientOcclusion_blur.vs.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_blur.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: 
 11: out vec2 vofi_TexCoord0;
 12: 
 13: void main() {
 14: 	gl_Position = in_Position ;
 15: 	vofi_TexCoord0 = in_TexCoord ;
 16: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/AmbientOcclusion_blur.ps.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_blur.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[6];
 18: 
 19: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 20: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 21: uniform sampler2D samp0;
 22: uniform sampler2D samp1;
 23: uniform sampler2D samp2;
 24: 
 25: in vec2 vofi_TexCoord0;
 26: 
 27: out vec4 fo_FragColor;
 28: 
 29: vec3 sampleNormal (sampler2D normalBuffer , ivec2 ssC , int mipLevel ) {
 30: 	return normalize ( texelFetch ( normalBuffer , ssC , mipLevel ). xyz * 2.0 - 1.0 ) ;
 31: }
 32: const float FAR_PLANE_Z = -16000.0;
 33: float CSZToKey (float z ) {
 34: 	return clamp ( z * ( 1.0 / FAR_PLANE_Z ) , 0.0 , 1.0 ) ;
 35: }
 36: vec3 reconstructCSPosition (vec2 S , float z ) {
 37: 	vec4 P ;
 38: 	P. z = z * 2.0 - 1.0 ;
 39: 	P. xy = ( S * _fa_[0 /* rpWindowCoord */] . xy ) * 2.0 - 1.0 ;
 40: 	P. w = 1.0 ;
 41: 	vec4 csP ;
 42: 	csP. x = dot4 ( P , _fa_[1 /* rpModelMatrixX */] ) ;
 43: 	csP. y = dot4 ( P , _fa_[2 /* rpModelMatrixY */] ) ;
 44: 	csP. z = dot4 ( P , _fa_[3 /* rpModelMatrixZ */] ) ;
 45: 	csP. w = dot4 ( P , _fa_[4 /* rpModelMatrixW */] ) ;
 46: 	csP. xyz /= csP. w ;
 47: 	return csP. xyz ;
 48: }
 49: float getKey (ivec2 ssP ) {
 50: 	float key = texelFetch ( samp1 , ssP , 0 ). r ;
 51: 	vec3 P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , key ) ;
 52: 	key = P. z ;
 53: 	key = clamp ( key * ( 1.0 / FAR_PLANE_Z ) , 0.0 , 1.0 ) ;
 54: 	return key ;
 55: }
 56: vec3 getPosition (ivec2 ssP , sampler2D samp1 ) {
 57: 	vec3 P ;
 58: 	P. z = texelFetch ( samp1 , ssP , 0 ). r ;
 59: 	P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , P. z ) ;
 60: 	return P ;
 61: }
 62: float calculateBilateralWeight (float key , float tapKey , ivec2 tapLoc , vec3 n_C , vec3 C ) {
 63: 	float depthWeight = max ( 0.0 , 1.0 - ( ( 1.0 ) * 2000.0 ) * abs ( tapKey - key ) ) ;
 64: 	float k_normal = 1.0 ;
 65: 	float k_plane = 1.0 ;
 66: 	float normalWeight = 1.0 ;
 67: 	float planeWeight = 1.0 ;
 68: 	vec3 tapN_C = sampleNormal ( samp0 , tapLoc , 0 ) ;
 69: 	depthWeight = 1.0 ;
 70: 	float normalError = 1.0 - dot ( tapN_C , n_C ) * k_normal ;
 71: 	normalWeight = max ( ( 1.0 - ( 1.0 ) * normalError ) , 0.00 ) ;
 72: 	float lowDistanceThreshold2 = 0.001 ;
 73: 	vec3 tapC = getPosition ( tapLoc , samp1 ) ;
 74: 	vec3 dq = C - tapC ;
 75: 	float distance2 = dot ( dq , dq ) ;
 76: 	float planeError = max ( abs ( dot ( dq , tapN_C ) ) , abs ( dot ( dq , n_C ) ) ) ;
 77: 	planeWeight = ( distance2 < lowDistanceThreshold2 ) ? 1.0 :
 78: 	pow ( max ( 0.0 , 1.0 - ( 1.0 ) * 2.0 * k_plane * planeError / sqrt ( distance2 ) ) , 2.0 ) ;
 79: 	return depthWeight * normalWeight * planeWeight ;
 80: }
 81: void main() {
 82: 	float kernel [ ( 4 ) + 1 ] ;
 83: 	kernel [ 0 ] = 0.153170 ;
 84: 	kernel [ 1 ] = 0.144893 ;
 85: 	kernel [ 2 ] = 0.122649 ;
 86: 	kernel [ 3 ] = 0.092902 ;
 87: 	kernel [ 4 ] = 0.062970 ;
 88: 	ivec2 ssC = ivec2 ( gl_FragCoord. xy ) ;
 89: 	vec4 temp = texelFetch ( samp2 , ssC , 0 ) ;
 90: 	vec3 C = getPosition ( ssC , samp1 ) ;
 91: 	float key = CSZToKey ( C. z ) ;
 92: 	float sum = temp. r ;
 93: 	if ( key == 1.0 )
 94: 	{
 95: 		fo_FragColor . r = sum ;
 96: 		return ;
 97: 	}
 98: 	float BASE = kernel [ 0 ] ;
 99: 	float totalWeight = BASE ;
100: 	sum *= totalWeight ;
101: 	vec3 n_C ;
102: 	n_C = sampleNormal ( samp0 , ssC , 0 ) ;
103: 	for ( int r = - ( 4 ) ; r <= ( 4 ) ; ++ r )
104: 	{
105: 		if ( r != 0 )
106: 		{
107: 			ivec2 tapLoc = ssC + ivec2 ( _fa_[5 /* rpJitterTexScale */] . xy ) * ( r * ( 2 ) ) ;
108: 			temp = texelFetch ( samp2 , tapLoc , 0 ) ;
109: 			float tapKey = getKey ( tapLoc ) ;
110: 			float value = temp. r ;
111: 			float weight = 0.3 + kernel [ abs ( r ) ] ;
112: 			float bilateralWeight = calculateBilateralWeight ( key , tapKey , tapLoc , n_C , C ) ;
113: 			weight *= bilateralWeight ;
114: 			sum += value * weight ;
115: 			totalWeight += weight ;
116: 		}
117: 	}
118: 	float epsilon = 0.0001 ;
119: 	fo_FragColor . r = sum / ( totalWeight + epsilon ) ;
120: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 65 with vertexShader AmbientOcclusion_blur and fragmentShader AmbientOcclusion_blur
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/AmbientOcclusion_blur.vs.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_blur.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: 
 11: out vec2 vofi_TexCoord0;
 12: 
 13: void main() {
 14: 	gl_Position = in_Position ;
 15: 	vofi_TexCoord0 = in_TexCoord ;
 16: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/AmbientOcclusion_blur.ps.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_blur.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[6];
 18: 
 19: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 20: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 21: uniform sampler2D samp0;
 22: uniform sampler2D samp1;
 23: uniform sampler2D samp2;
 24: 
 25: in vec2 vofi_TexCoord0;
 26: 
 27: out vec4 fo_FragColor;
 28: 
 29: vec3 sampleNormal (sampler2D normalBuffer , ivec2 ssC , int mipLevel ) {
 30: 	return normalize ( texelFetch ( normalBuffer , ssC , mipLevel ). xyz * 2.0 - 1.0 ) ;
 31: }
 32: const float FAR_PLANE_Z = -16000.0;
 33: float CSZToKey (float z ) {
 34: 	return clamp ( z * ( 1.0 / FAR_PLANE_Z ) , 0.0 , 1.0 ) ;
 35: }
 36: vec3 reconstructCSPosition (vec2 S , float z ) {
 37: 	vec4 P ;
 38: 	P. z = z * 2.0 - 1.0 ;
 39: 	P. xy = ( S * _fa_[0 /* rpWindowCoord */] . xy ) * 2.0 - 1.0 ;
 40: 	P. w = 1.0 ;
 41: 	vec4 csP ;
 42: 	csP. x = dot4 ( P , _fa_[1 /* rpModelMatrixX */] ) ;
 43: 	csP. y = dot4 ( P , _fa_[2 /* rpModelMatrixY */] ) ;
 44: 	csP. z = dot4 ( P , _fa_[3 /* rpModelMatrixZ */] ) ;
 45: 	csP. w = dot4 ( P , _fa_[4 /* rpModelMatrixW */] ) ;
 46: 	csP. xyz /= csP. w ;
 47: 	return csP. xyz ;
 48: }
 49: float getKey (ivec2 ssP ) {
 50: 	float key = texelFetch ( samp1 , ssP , 0 ). r ;
 51: 	vec3 P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , key ) ;
 52: 	key = P. z ;
 53: 	key = clamp ( key * ( 1.0 / FAR_PLANE_Z ) , 0.0 , 1.0 ) ;
 54: 	return key ;
 55: }
 56: vec3 getPosition (ivec2 ssP , sampler2D samp1 ) {
 57: 	vec3 P ;
 58: 	P. z = texelFetch ( samp1 , ssP , 0 ). r ;
 59: 	P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , P. z ) ;
 60: 	return P ;
 61: }
 62: float calculateBilateralWeight (float key , float tapKey , ivec2 tapLoc , vec3 n_C , vec3 C ) {
 63: 	float depthWeight = max ( 0.0 , 1.0 - ( ( 1.0 ) * 2000.0 ) * abs ( tapKey - key ) ) ;
 64: 	float k_normal = 1.0 ;
 65: 	float k_plane = 1.0 ;
 66: 	float normalWeight = 1.0 ;
 67: 	float planeWeight = 1.0 ;
 68: 	vec3 tapN_C = sampleNormal ( samp0 , tapLoc , 0 ) ;
 69: 	depthWeight = 1.0 ;
 70: 	float normalError = 1.0 - dot ( tapN_C , n_C ) * k_normal ;
 71: 	normalWeight = max ( ( 1.0 - ( 1.0 ) * normalError ) , 0.00 ) ;
 72: 	float lowDistanceThreshold2 = 0.001 ;
 73: 	vec3 tapC = getPosition ( tapLoc , samp1 ) ;
 74: 	vec3 dq = C - tapC ;
 75: 	float distance2 = dot ( dq , dq ) ;
 76: 	float planeError = max ( abs ( dot ( dq , tapN_C ) ) , abs ( dot ( dq , n_C ) ) ) ;
 77: 	planeWeight = ( distance2 < lowDistanceThreshold2 ) ? 1.0 :
 78: 	pow ( max ( 0.0 , 1.0 - ( 1.0 ) * 2.0 * k_plane * planeError / sqrt ( distance2 ) ) , 2.0 ) ;
 79: 	return depthWeight * normalWeight * planeWeight ;
 80: }
 81: void main() {
 82: 	float kernel [ ( 4 ) + 1 ] ;
 83: 	kernel [ 0 ] = 0.153170 ;
 84: 	kernel [ 1 ] = 0.144893 ;
 85: 	kernel [ 2 ] = 0.122649 ;
 86: 	kernel [ 3 ] = 0.092902 ;
 87: 	kernel [ 4 ] = 0.062970 ;
 88: 	ivec2 ssC = ivec2 ( gl_FragCoord. xy ) ;
 89: 	vec4 temp = texelFetch ( samp2 , ssC , 0 ) ;
 90: 	vec3 C = getPosition ( ssC , samp1 ) ;
 91: 	float key = CSZToKey ( C. z ) ;
 92: 	float sum = temp. r ;
 93: 	if ( key == 1.0 )
 94: 	{
 95: 		fo_FragColor . r = sum ;
 96: 		fo_FragColor = vec4 ( fo_FragColor . r , fo_FragColor . r , fo_FragColor . r , 1.0 ) ;
 97: 		return ;
 98: 	}
 99: 	float BASE = kernel [ 0 ] ;
100: 	float totalWeight = BASE ;
101: 	sum *= totalWeight ;
102: 	vec3 n_C ;
103: 	n_C = sampleNormal ( samp0 , ssC , 0 ) ;
104: 	for ( int r = - ( 4 ) ; r <= ( 4 ) ; ++ r )
105: 	{
106: 		if ( r != 0 )
107: 		{
108: 			ivec2 tapLoc = ssC + ivec2 ( _fa_[5 /* rpJitterTexScale */] . xy ) * ( r * ( 2 ) ) ;
109: 			temp = texelFetch ( samp2 , tapLoc , 0 ) ;
110: 			float tapKey = getKey ( tapLoc ) ;
111: 			float value = temp. r ;
112: 			float weight = 0.3 + kernel [ abs ( r ) ] ;
113: 			float bilateralWeight = calculateBilateralWeight ( key , tapKey , tapLoc , n_C , C ) ;
114: 			weight *= bilateralWeight ;
115: 			sum += value * weight ;
116: 			totalWeight += weight ;
117: 		}
118: 	}
119: 	float epsilon = 0.0001 ;
120: 	fo_FragColor . r = sum / ( totalWeight + epsilon ) ;
121: 	fo_FragColor = vec4 ( fo_FragColor . r , fo_FragColor . r , fo_FragColor . r , 1.0 ) ;
122: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 66 with vertexShader AmbientOcclusion_blur and fragmentShader AmbientOcclusion_blur
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/AmbientOcclusion_minify.vs.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_minify.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: 
 11: out vec2 vofi_TexCoord0;
 12: 
 13: void main() {
 14: 	gl_Position = in_Position ;
 15: 	vofi_TexCoord0 = in_TexCoord ;
 16: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/AmbientOcclusion_minify.ps.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_minify.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[2];
 18: 
 19: uniform sampler2D samp0;
 20: 
 21: in vec2 vofi_TexCoord0;
 22: 
 23: out vec4 fo_FragColor;
 24: 
 25: void main() {
 26: 	ivec2 ssP = ivec2 ( vofi_TexCoord0 * _fa_[0 /* rpScreenCorrectionFactor */] . zw ) ;
 27: 	int previousMIPNumber = int ( _fa_[1 /* rpJitterTexScale */] . x ) ;
 28: 	fo_FragColor . r = texelFetch ( samp0 , clamp ( ssP * 2 + ivec2 ( ssP. y & 1 , ssP. x & 1 ) , ivec2 ( 0 ) , textureSize ( samp0 , previousMIPNumber ) - ivec2 ( 1 ) ) , previousMIPNumber ). r ;
 29: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 67 with vertexShader AmbientOcclusion_minify and fragmentShader AmbientOcclusion_minify
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/AmbientOcclusion_minify.vs.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_minify.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: 
 11: out vec2 vofi_TexCoord0;
 12: 
 13: void main() {
 14: 	gl_Position = in_Position ;
 15: 	vofi_TexCoord0 = in_TexCoord ;
 16: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/AmbientOcclusion_minify.ps.hlsl
-----------------
  1: // filename renderprogs/AmbientOcclusion_minify.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: uniform sampler2D samp0;
 17: 
 18: in vec2 vofi_TexCoord0;
 19: 
 20: out vec4 fo_FragColor;
 21: 
 22: void main() {
 23: 	vec2 ssC = vofi_TexCoord0 ;
 24: 	float depth = texture ( samp0 , ssC ). r ;
 25: 	fo_FragColor . r = depth ;
 26: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 68 with vertexShader AmbientOcclusion_minify and fragmentShader AmbientOcclusion_minify
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/DeepGBufferRadiosity_radiosity.vs.hlsl
-----------------
  1: // filename renderprogs/DeepGBufferRadiosity_radiosity.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: 
 11: out vec2 vofi_TexCoord0;
 12: 
 13: void main() {
 14: 	gl_Position = in_Position ;
 15: 	vofi_TexCoord0 = in_TexCoord ;
 16: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/DeepGBufferRadiosity_radiosity.ps.hlsl
-----------------
  1: // filename renderprogs/DeepGBufferRadiosity_radiosity.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[5];
 18: 
 19: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 20: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 21: const float DOOM_TO_METERS = 0.0254;
 22: const float METERS_TO_DOOM = ( 1.0 / DOOM_TO_METERS );
 23: const float radius = 1.0 * METERS_TO_DOOM;
 24: const float radius2 = radius * radius;
 25: const float projScale = 500.0;
 26: uniform sampler2D samp0;
 27: uniform sampler2D samp1;
 28: uniform sampler2D samp2;
 29: 
 30: in vec2 vofi_TexCoord0;
 31: 
 32: out vec4 fo_FragColor;
 33: 
 34: vec3 reconstructCSPosition (vec2 S , float z ) {
 35: 	vec4 P ;
 36: 	P. z = z * 2.0 - 1.0 ;
 37: 	P. xy = ( S * _fa_[0 /* rpScreenCorrectionFactor */] . xy ) * 2.0 - 1.0 ;
 38: 	P. w = 1.0 ;
 39: 	vec4 csP ;
 40: 	csP. x = dot4 ( P , _fa_[1 /* rpModelMatrixX */] ) ;
 41: 	csP. y = dot4 ( P , _fa_[2 /* rpModelMatrixY */] ) ;
 42: 	csP. z = dot4 ( P , _fa_[3 /* rpModelMatrixZ */] ) ;
 43: 	csP. w = dot4 ( P , _fa_[4 /* rpModelMatrixW */] ) ;
 44: 	csP. xyz /= csP. w ;
 45: 	return csP. xyz ;
 46: }
 47: vec3 sampleNormal (sampler2D normalBuffer , ivec2 ssC , int mipLevel ) {
 48: 	return texelFetch ( normalBuffer , ssC , mipLevel ). xyz * 2.0 - 1.0 ;
 49: }
 50: vec2 tapLocation (int sampleNumber , float spinAngle , float radialJitter , out float ssR ) {
 51: 	float alpha = ( float ( sampleNumber ) + radialJitter ) * ( 1.0 / float ( 11 ) ) ;
 52: 	float angle = alpha * ( float ( 7 ) * 6.28 ) + spinAngle ;
 53: 	ssR = alpha ;
 54: 	return vec2 ( cos ( angle ) , sin ( angle ) ) ;
 55: }
 56: vec3 getPosition (ivec2 ssP , sampler2D cszBuffer ) {
 57: 	vec3 P ;
 58: 	P. z = texelFetch ( cszBuffer , ssP , 0 ). r ;
 59: 	P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , P. z ) ;
 60: 	return P ;
 61: }
 62: void computeMipInfo (float ssR , ivec2 ssP , sampler2D cszBuffer , inout int mipLevel , inout ivec2 mipP ) {
 63: 	mipLevel = clamp ( int ( floor ( log2 ( ssR ) ) ) - ( 3 ) , 0 , ( 5 ) ) ;
 64: 	mipP = clamp ( ssP >> mipLevel , ivec2 ( 0 ) , textureSize ( cszBuffer , mipLevel ) - ivec2 ( 1 ) ) ;
 65: }
 66: void getOffsetPositionNormalAndLambertian (ivec2 ssP ,
 67: float ssR ,
 68: sampler2D cszBuffer ,
 69: sampler2D bounceBuffer ,
 70: sampler2D normalBuffer ,
 71: inout vec3 Q ,
 72: inout vec3 lambertian_tap ,
 73: inout vec3 n_tap ) {
 74: 	int mipLevel ;
 75: 	ivec2 texel ;
 76: 	computeMipInfo ( ssR , ssP , cszBuffer , mipLevel , texel ) ;
 77: 	float z = texelFetch ( cszBuffer , texel , mipLevel ). r ;
 78: 	vec3 n = sampleNormal ( normalBuffer , ssP , 0 ) ;
 79: 	lambertian_tap = texelFetch ( bounceBuffer , ssP , 0 ). rgb ;
 80: 	n_tap = n ;
 81: 	Q = reconstructCSPosition ( ( vec2 ( ssP ) + vec2 ( 0.5 ) ) , z ) ;
 82: }
 83: void iiValueFromPositionsAndNormalsAndLambertian (ivec2 ssP , vec3 X , vec3 n_X , vec3 Y , vec3 n_Y , vec3 radiosity_Y , inout vec3 E , inout float weight_Y , inout float visibilityWeight_Y ) {
 84: 	vec3 YminusX = Y - X ;
 85: 	vec3 w_i = normalize ( YminusX ) ;
 86: 	weight_Y = ( ( dot ( w_i , n_X ) > 0.0 )
 87: 	&& ( dot ( - w_i , n_Y ) > 0.01 )
 88: 	) ? 1.0 : 0.0 ;
 89: 	if ( ( dot ( YminusX , YminusX ) < radius2 ) &&
 90: 	( weight_Y > 0.0 ) )
 91: 	{
 92: 		E = radiosity_Y * dot ( w_i , n_X ) ;
 93: 	}
 94: 	else
 95: 	{
 96: 		E = vec3 ( 0 ) ;
 97: 	}
 98: }
 99: void sampleIndirectLight (in ivec2 ssC ,
100: in vec3 C ,
101: in vec3 n_C ,
102: in vec3 C_peeled ,
103: in vec3 n_C_peeled ,
104: in float ssDiskRadius ,
105: in int tapIndex ,
106: in float randomPatternRotationAngle ,
107: in float radialJitter ,
108: in sampler2D cszBuffer ,
109: in sampler2D nBuffer ,
110: in sampler2D bounceBuffer ,
111: inout vec3 irradianceSum ,
112: inout float numSamplesUsed ,
113: inout vec3 iiPeeled ,
114: inout float weightSumPeeled ) {
115: 	float visibilityWeightPeeled0 , visibilityWeightPeeled1 ;
116: 	float ssR ;
117: 	vec2 unitOffset = tapLocation ( tapIndex , randomPatternRotationAngle , radialJitter , ssR ) ;
118: 	ssR *= ssDiskRadius ;
119: 	ivec2 ssP = ivec2 ( ssR * unitOffset ) + ssC ;
120: 	vec3 E ;
121: 	float visibilityWeight ;
122: 	float weight_Y ;
123: 	vec3 Q , lambertian_tap , n_tap ;
124: 	getOffsetPositionNormalAndLambertian ( ssP , ssR , cszBuffer , bounceBuffer , nBuffer , Q , lambertian_tap , n_tap ) ;
125: 	iiValueFromPositionsAndNormalsAndLambertian ( ssP , C , n_C , Q , n_tap , lambertian_tap , E , weight_Y , visibilityWeight ) ;
126: 	numSamplesUsed += weight_Y ;
127: 	irradianceSum += E ;
128: }
129: void main() {
130: 	fo_FragColor = vec4 ( 0.0 , 0.0 , 0.0 , 1.0 ) ;
131: 	ivec2 ssC = ivec2 ( gl_FragCoord. xy ) ;
132: 	vec3 C = getPosition ( ssC , samp1 ) ;
133: 	vec3 C_peeled = vec3 ( 0 ) ;
134: 	vec3 n_C_peeled = vec3 ( 0 ) ;
135: 	vec3 n_C = sampleNormal ( samp0 , ssC , 0 ) ;
136: 	float ssDiskRadius = - projScale * radius / C. z ;
137: 	float randomPatternRotationAngle = float ( 3 * ssC. x ^ ssC. y + ssC. x * ssC. y ) * 10.0 ;
138: 	float radialJitter = fract ( sin ( gl_FragCoord. x * 1e2 +
139: 	gl_FragCoord. y ) * 1e5 + sin ( gl_FragCoord. y * 1e3 ) * 1e3 ) * 0.8 + 0.1 ;
140: 	float numSamplesUsed = 0.0 ;
141: 	vec3 irradianceSum = vec3 ( 0 ) ;
142: 	vec3 ii_peeled = vec3 ( 0 ) ;
143: 	float peeledSum = 0.0 ;
144: 	for ( int i = 0 ; i < 11 ; ++ i )
145: 	{
146: 		sampleIndirectLight ( ssC , C , n_C , C_peeled , n_C_peeled , ssDiskRadius , i , randomPatternRotationAngle , radialJitter , samp1 , samp0 , samp2 , irradianceSum , numSamplesUsed , ii_peeled , peeledSum ) ;
147: 	}
148: 	float solidAngleHemisphere = 2.0 * 3.14159265358979323846 ;
149: 	vec3 E_X = irradianceSum * solidAngleHemisphere / ( numSamplesUsed + 0.00001 ) ;
150: 	fo_FragColor . rgb = E_X ;
151: 	fo_FragColor . a = 1.0 - numSamplesUsed / float ( 11 ) ;
152: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 69 with vertexShader DeepGBufferRadiosity_radiosity and fragmentShader DeepGBufferRadiosity_radiosity
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/DeepGBufferRadiosity_blur.vs.hlsl
-----------------
  1: // filename renderprogs/DeepGBufferRadiosity_blur.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: 
 11: out vec2 vofi_TexCoord0;
 12: 
 13: void main() {
 14: 	gl_Position = in_Position ;
 15: 	vofi_TexCoord0 = in_TexCoord ;
 16: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/DeepGBufferRadiosity_blur.ps.hlsl
-----------------
  1: // filename renderprogs/DeepGBufferRadiosity_blur.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[6];
 18: 
 19: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 20: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 21: uniform sampler2D samp0;
 22: uniform sampler2D samp1;
 23: uniform sampler2D samp2;
 24: 
 25: in vec2 vofi_TexCoord0;
 26: 
 27: out vec4 fo_FragColor;
 28: 
 29: vec3 sampleNormal (sampler2D normalBuffer , ivec2 ssC , int mipLevel ) {
 30: 	return normalize ( texelFetch ( normalBuffer , ssC , mipLevel ). xyz * 2.0 - 1.0 ) ;
 31: }
 32: const float FAR_PLANE_Z = -16000.0;
 33: float CSZToKey (float z ) {
 34: 	return clamp ( z * ( 1.0 / FAR_PLANE_Z ) , 0.0 , 1.0 ) ;
 35: }
 36: vec3 reconstructCSPosition (vec2 S , float z ) {
 37: 	vec4 P ;
 38: 	P. z = z * 2.0 - 1.0 ;
 39: 	P. xy = ( S * _fa_[0 /* rpScreenCorrectionFactor */] . xy ) * 2.0 - 1.0 ;
 40: 	P. w = 1.0 ;
 41: 	vec4 csP ;
 42: 	csP. x = dot4 ( P , _fa_[1 /* rpModelMatrixX */] ) ;
 43: 	csP. y = dot4 ( P , _fa_[2 /* rpModelMatrixY */] ) ;
 44: 	csP. z = dot4 ( P , _fa_[3 /* rpModelMatrixZ */] ) ;
 45: 	csP. w = dot4 ( P , _fa_[4 /* rpModelMatrixW */] ) ;
 46: 	csP. xyz /= csP. w ;
 47: 	return csP. xyz ;
 48: }
 49: float getKey (ivec2 ssP ) {
 50: 	float key = texelFetch ( samp1 , ssP , 0 ). r ;
 51: 	vec3 P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , key ) ;
 52: 	key = P. z ;
 53: 	key = clamp ( key * ( 1.0 / FAR_PLANE_Z ) , 0.0 , 1.0 ) ;
 54: 	return key ;
 55: }
 56: vec3 getPosition (ivec2 ssP , sampler2D samp1 ) {
 57: 	vec3 P ;
 58: 	P. z = texelFetch ( samp1 , ssP , 0 ). r ;
 59: 	P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , P. z ) ;
 60: 	return P ;
 61: }
 62: float calculateBilateralWeight (float key , float tapKey , ivec2 tapLoc , vec3 n_C , vec3 C ) {
 63: 	float depthWeight = max ( 0.0 , 1.0 - ( ( 1.0 ) * 2000.0 ) * abs ( tapKey - key ) ) ;
 64: 	float k_normal = 1.0 ;
 65: 	float k_plane = 1.0 ;
 66: 	float normalWeight = 1.0 ;
 67: 	float planeWeight = 1.0 ;
 68: 	vec3 tapN_C = sampleNormal ( samp0 , tapLoc , 0 ) ;
 69: 	depthWeight = 1.0 ;
 70: 	float normalError = ( 1.0 - dot ( tapN_C , n_C ) ) * k_normal ;
 71: 	normalWeight = max ( 1.0 - ( 1.0 ) * normalError , 0.00 ) ;
 72: 	float lowDistanceThreshold2 = 0.001 ;
 73: 	vec3 tapC = getPosition ( tapLoc , samp1 ) ;
 74: 	vec3 dq = C - tapC ;
 75: 	float distance2 = dot ( dq , dq ) ;
 76: 	float planeError = max ( abs ( dot ( dq , tapN_C ) ) , abs ( dot ( dq , n_C ) ) ) ;
 77: 	planeWeight = ( distance2 < lowDistanceThreshold2 ) ? 1.0 :
 78: 	pow ( max ( 0.0 , 1.0 - ( 1.0 ) * 2.0 * k_plane * planeError / sqrt ( distance2 ) ) , 2.0 ) ;
 79: 	return depthWeight * normalWeight * planeWeight ;
 80: }
 81: void main() {
 82: 	float kernel [ ( 4 ) + 1 ] ;
 83: 	kernel [ 0 ] = 0.153170 ;
 84: 	kernel [ 1 ] = 0.144893 ;
 85: 	kernel [ 2 ] = 0.122649 ;
 86: 	kernel [ 3 ] = 0.092902 ;
 87: 	kernel [ 4 ] = 0.062970 ;
 88: 	ivec2 ssC = ivec2 ( gl_FragCoord. xy ) ;
 89: 	vec4 temp = texelFetch ( samp2 , ssC , 0 ) ;
 90: 	vec3 C = getPosition ( ssC , samp1 ) ;
 91: 	float key = CSZToKey ( C. z ) ;
 92: 	vec4 sum = temp. rgba ;
 93: 	if ( key == 1.0 )
 94: 	{
 95: 		fo_FragColor . rgba = sum ;
 96: 		return ;
 97: 	}
 98: 	float BASE = kernel [ 0 ] ;
 99: 	float totalWeight = BASE ;
100: 	sum *= totalWeight ;
101: 	vec3 n_C ;
102: 	n_C = sampleNormal ( samp0 , ssC , 0 ) ;
103: 	for ( int r = - ( 4 ) ; r <= ( 4 ) ; ++ r )
104: 	{
105: 		if ( r != 0 )
106: 		{
107: 			ivec2 tapLoc = ssC + ivec2 ( _fa_[5 /* rpJitterTexScale */] . xy ) * ( r * ( 2 ) ) ;
108: 			temp = texelFetch ( samp2 , tapLoc , 0 ) ;
109: 			float tapKey = getKey ( tapLoc ) ;
110: 			vec4 value = temp. rgba ;
111: 			float weight = 0.3 + kernel [ abs ( r ) ] ;
112: 			float bilateralWeight = calculateBilateralWeight ( key , tapKey , tapLoc , n_C , C ) ;
113: 			weight *= bilateralWeight ;
114: 			sum += value * weight ;
115: 			totalWeight += weight ;
116: 		}
117: 	}
118: 	float epsilon = 0.0001 ;
119: 	fo_FragColor . rgba = sum / ( totalWeight + epsilon ) ;
120: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 70 with vertexShader DeepGBufferRadiosity_blur and fragmentShader DeepGBufferRadiosity_blur
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/DeepGBufferRadiosity_blur.vs.hlsl
-----------------
  1: // filename renderprogs/DeepGBufferRadiosity_blur.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: 
 11: out vec2 vofi_TexCoord0;
 12: 
 13: void main() {
 14: 	gl_Position = in_Position ;
 15: 	vofi_TexCoord0 = in_TexCoord ;
 16: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/DeepGBufferRadiosity_blur.ps.hlsl
-----------------
  1: // filename renderprogs/DeepGBufferRadiosity_blur.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[6];
 18: 
 19: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 20: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 21: uniform sampler2D samp0;
 22: uniform sampler2D samp1;
 23: uniform sampler2D samp2;
 24: 
 25: in vec2 vofi_TexCoord0;
 26: 
 27: out vec4 fo_FragColor;
 28: 
 29: vec3 sampleNormal (sampler2D normalBuffer , ivec2 ssC , int mipLevel ) {
 30: 	return normalize ( texelFetch ( normalBuffer , ssC , mipLevel ). xyz * 2.0 - 1.0 ) ;
 31: }
 32: const float FAR_PLANE_Z = -16000.0;
 33: float CSZToKey (float z ) {
 34: 	return clamp ( z * ( 1.0 / FAR_PLANE_Z ) , 0.0 , 1.0 ) ;
 35: }
 36: vec3 reconstructCSPosition (vec2 S , float z ) {
 37: 	vec4 P ;
 38: 	P. z = z * 2.0 - 1.0 ;
 39: 	P. xy = ( S * _fa_[0 /* rpScreenCorrectionFactor */] . xy ) * 2.0 - 1.0 ;
 40: 	P. w = 1.0 ;
 41: 	vec4 csP ;
 42: 	csP. x = dot4 ( P , _fa_[1 /* rpModelMatrixX */] ) ;
 43: 	csP. y = dot4 ( P , _fa_[2 /* rpModelMatrixY */] ) ;
 44: 	csP. z = dot4 ( P , _fa_[3 /* rpModelMatrixZ */] ) ;
 45: 	csP. w = dot4 ( P , _fa_[4 /* rpModelMatrixW */] ) ;
 46: 	csP. xyz /= csP. w ;
 47: 	return csP. xyz ;
 48: }
 49: float getKey (ivec2 ssP ) {
 50: 	float key = texelFetch ( samp1 , ssP , 0 ). r ;
 51: 	vec3 P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , key ) ;
 52: 	key = P. z ;
 53: 	key = clamp ( key * ( 1.0 / FAR_PLANE_Z ) , 0.0 , 1.0 ) ;
 54: 	return key ;
 55: }
 56: vec3 getPosition (ivec2 ssP , sampler2D samp1 ) {
 57: 	vec3 P ;
 58: 	P. z = texelFetch ( samp1 , ssP , 0 ). r ;
 59: 	P = reconstructCSPosition ( vec2 ( ssP ) + vec2 ( 0.5 ) , P. z ) ;
 60: 	return P ;
 61: }
 62: float calculateBilateralWeight (float key , float tapKey , ivec2 tapLoc , vec3 n_C , vec3 C ) {
 63: 	float depthWeight = max ( 0.0 , 1.0 - ( ( 1.0 ) * 2000.0 ) * abs ( tapKey - key ) ) ;
 64: 	float k_normal = 1.0 ;
 65: 	float k_plane = 1.0 ;
 66: 	float normalWeight = 1.0 ;
 67: 	float planeWeight = 1.0 ;
 68: 	vec3 tapN_C = sampleNormal ( samp0 , tapLoc , 0 ) ;
 69: 	depthWeight = 1.0 ;
 70: 	float normalError = ( 1.0 - dot ( tapN_C , n_C ) ) * k_normal ;
 71: 	normalWeight = max ( 1.0 - ( 1.0 ) * normalError , 0.00 ) ;
 72: 	float lowDistanceThreshold2 = 0.001 ;
 73: 	vec3 tapC = getPosition ( tapLoc , samp1 ) ;
 74: 	vec3 dq = C - tapC ;
 75: 	float distance2 = dot ( dq , dq ) ;
 76: 	float planeError = max ( abs ( dot ( dq , tapN_C ) ) , abs ( dot ( dq , n_C ) ) ) ;
 77: 	planeWeight = ( distance2 < lowDistanceThreshold2 ) ? 1.0 :
 78: 	pow ( max ( 0.0 , 1.0 - ( 1.0 ) * 2.0 * k_plane * planeError / sqrt ( distance2 ) ) , 2.0 ) ;
 79: 	return depthWeight * normalWeight * planeWeight ;
 80: }
 81: void main() {
 82: 	float kernel [ ( 4 ) + 1 ] ;
 83: 	kernel [ 0 ] = 0.153170 ;
 84: 	kernel [ 1 ] = 0.144893 ;
 85: 	kernel [ 2 ] = 0.122649 ;
 86: 	kernel [ 3 ] = 0.092902 ;
 87: 	kernel [ 4 ] = 0.062970 ;
 88: 	ivec2 ssC = ivec2 ( gl_FragCoord. xy ) ;
 89: 	vec4 temp = texelFetch ( samp2 , ssC , 0 ) ;
 90: 	vec3 C = getPosition ( ssC , samp1 ) ;
 91: 	float key = CSZToKey ( C. z ) ;
 92: 	vec4 sum = temp. rgba ;
 93: 	if ( key == 1.0 )
 94: 	{
 95: 		fo_FragColor . rgba = sum ;
 96: 		return ;
 97: 	}
 98: 	float BASE = kernel [ 0 ] ;
 99: 	float totalWeight = BASE ;
100: 	sum *= totalWeight ;
101: 	vec3 n_C ;
102: 	n_C = sampleNormal ( samp0 , ssC , 0 ) ;
103: 	for ( int r = - ( 4 ) ; r <= ( 4 ) ; ++ r )
104: 	{
105: 		if ( r != 0 )
106: 		{
107: 			ivec2 tapLoc = ssC + ivec2 ( _fa_[5 /* rpJitterTexScale */] . xy ) * ( r * ( 2 ) ) ;
108: 			temp = texelFetch ( samp2 , tapLoc , 0 ) ;
109: 			float tapKey = getKey ( tapLoc ) ;
110: 			vec4 value = temp. rgba ;
111: 			float weight = 0.3 + kernel [ abs ( r ) ] ;
112: 			float bilateralWeight = calculateBilateralWeight ( key , tapKey , tapLoc , n_C , C ) ;
113: 			weight *= bilateralWeight ;
114: 			sum += value * weight ;
115: 			totalWeight += weight ;
116: 		}
117: 	}
118: 	float epsilon = 0.0001 ;
119: 	fo_FragColor . rgba = sum / ( totalWeight + epsilon ) ;
120: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 71 with vertexShader DeepGBufferRadiosity_blur and fragmentShader DeepGBufferRadiosity_blur
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/stereoDeGhost.vs.hlsl
-----------------
  1: // filename renderprogs/stereoDeGhost.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: in vec2 in_TexCoord;
 14: in vec4 in_Normal;
 15: in vec4 in_Tangent;
 16: in vec4 in_Color;
 17: 
 18: 
 19: void main() {
 20: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 21: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 22: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 23: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 24: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/stereoDeGhost.ps.hlsl
-----------------
  1: // filename renderprogs/stereoDeGhost.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: out vec4 fo_FragColor;
 20: 
 21: void main() {
 22: 	fo_FragColor = _fa_[0 /* rpColor */] ;
 23: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 72 with vertexShader stereoDeGhost and fragmentShader stereoDeGhost
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/stereoWarp.vs.hlsl
-----------------
  1: // filename renderprogs/stereoWarp.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: in vec4 in_TexCoord;
 14: 
 15: out vec4 vofi_TexCoord0;
 16: 
 17: void main() {
 18: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 19: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 20: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 21: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 22: 	vofi_TexCoord0 = in_TexCoord ;
 23: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/stereoWarp.ps.hlsl
-----------------
  1: // filename renderprogs/stereoWarp.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: uniform sampler2D samp0;
 17: 
 18: in vec4 vofi_TexCoord0;
 19: 
 20: out vec4 fo_FragColor;
 21: 
 22: void main() {
 23: 	float screenWarp_range = 1.45 ;
 24: 	vec2 warpCenter = vec2 ( 0.5 , 0.5 ) ;
 25: 	vec2 centeredTexcoord = vofi_TexCoord0 . xy - warpCenter ;
 26: 	float radialLength = length ( centeredTexcoord ) ;
 27: 	vec2 radialDir = normalize ( centeredTexcoord ) ;
 28: 	float range = screenWarp_range ;
 29: 	float scaledRadialLength = radialLength * range ;
 30: 	float tanScaled = tan ( scaledRadialLength ) ;
 31: 	float rescaleValue = tan ( 0.5 * range ) ;
 32: 	float rescaled = tanScaled / rescaleValue ;
 33: 	vec2 warped = warpCenter + vec2 ( 0.5 , 0.5 ) * radialDir * rescaled ;
 34: 	fo_FragColor = texture ( samp0 , warped ) ;
 35: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 73 with vertexShader stereoWarp and fragmentShader stereoWarp
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/bink.vs.hlsl
-----------------
  1: // filename renderprogs/bink.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: in vec2 in_TexCoord;
 14: in vec4 in_Normal;
 15: in vec4 in_Tangent;
 16: in vec4 in_Color;
 17: 
 18: out vec2 vofi_TexCoord0;
 19: 
 20: void main() {
 21: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 22: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 23: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 24: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 25: 	vofi_TexCoord0 = in_TexCoord ;
 26: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/bink.ps.hlsl
-----------------
  1: // filename renderprogs/bink.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: float Linear1 (float c ) {
 20: 	return ( c <= 0.04045 ) ? c / 12.92 : pow ( ( c + 0.055 ) / 1.055 , 2.4 ) ;
 21: }
 22: vec4 sRGBAToLinearRGBA (vec4 c ) {
 23: 	c = clamp ( c , 0.0 , 1.0 ) ;
 24: 	return vec4 ( Linear1 ( c. r ) , Linear1 ( c. g ) , Linear1 ( c. b ) , Linear1 ( c. a ) ) ;
 25: }
 26: uniform sampler2D samp0;
 27: uniform sampler2D samp1;
 28: uniform sampler2D samp2;
 29: 
 30: in vec2 vofi_TexCoord0;
 31: 
 32: out vec4 fo_FragColor;
 33: 
 34: void main() {
 35: 	vec3 crc = vec3 ( 1.595794678 , - 0.813476563 , 0 ) ;
 36: 	vec3 crb = vec3 ( 0 , - 0.391448975 , 2.017822266 ) ;
 37: 	vec3 adj = vec3 ( - 0.87065506 , 0.529705048 , - 1.081668854 ) ;
 38: 	vec3 YScalar = vec3 ( 1.164123535 , 1.164123535 , 1.164123535 ) ;
 39: 	float Y = texture ( samp0 , vofi_TexCoord0 . xy ). x ;
 40: 	float Cr = texture ( samp1 , vofi_TexCoord0 . xy ). x ;
 41: 	float Cb = texture ( samp2 , vofi_TexCoord0 . xy ). x ;
 42: 	vec3 p = ( YScalar * Y ) ;
 43: 	p += ( crc * Cr ) + ( crb * Cb ) + adj ;
 44: 	vec4 color ;
 45: 	color. xyz = p ;
 46: 	color. w = 1.0 ;
 47: 	color *= _fa_[0 /* rpColor */] ;
 48: 	fo_FragColor = sRGBAToLinearRGBA ( color ) ;
 49: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 74 with vertexShader bink and fragmentShader bink
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/bink_gui.vs.hlsl
-----------------
  1: // filename renderprogs/bink_gui.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: vec4 swizzleColor (vec4 c ) {
 12: 	return c ;
 13: }
 14: 
 15: in vec4 in_Position;
 16: in vec2 in_TexCoord;
 17: in vec4 in_Normal;
 18: in vec4 in_Tangent;
 19: in vec4 in_Color;
 20: in vec4 in_Color2;
 21: 
 22: out vec2 vofi_TexCoord0;
 23: out vec4 vofi_TexCoord1;
 24: out vec4 vofi_Color;
 25: 
 26: void main() {
 27: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 28: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 29: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 30: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 31: 	vofi_TexCoord0 . xy = in_TexCoord . xy ;
 32: 	vofi_TexCoord1 = ( ( in_Color2 ) * 2.0 ) - 1.0 ;
 33: 	vofi_Color = swizzleColor ( in_Color ) ;
 34: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/bink_gui.ps.hlsl
-----------------
  1: // filename renderprogs/bink_gui.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: uniform sampler2D samp0;
 17: uniform sampler2D samp1;
 18: uniform sampler2D samp2;
 19: 
 20: in vec2 vofi_TexCoord0;
 21: in vec4 vofi_TexCoord1;
 22: in vec4 vofi_Color;
 23: 
 24: out vec4 fo_FragColor;
 25: 
 26: void main() {
 27: 	vec3 crc = vec3 ( 1.595794678 , - 0.813476563 , 0 ) ;
 28: 	vec3 crb = vec3 ( 0 , - 0.391448975 , 2.017822266 ) ;
 29: 	vec3 adj = vec3 ( - 0.87065506 , 0.529705048 , - 1.081668854 ) ;
 30: 	vec3 YScalar = vec3 ( 1.164123535 , 1.164123535 , 1.164123535 ) ;
 31: 	float Y = texture ( samp0 , vofi_TexCoord0 . xy ). x ;
 32: 	float Cr = texture ( samp1 , vofi_TexCoord0 . xy ). x ;
 33: 	float Cb = texture ( samp2 , vofi_TexCoord0 . xy ). x ;
 34: 	vec3 p = ( YScalar * Y ) ;
 35: 	p += ( crc * Cr ) + ( crb * Cb ) + adj ;
 36: 	vec4 binkImage ;
 37: 	binkImage. xyz = p ;
 38: 	binkImage. w = 1.0 ;
 39: 	vec4 color = ( binkImage * vofi_Color ) + vofi_TexCoord1 ;
 40: 	fo_FragColor . xyz = color. xyz * color. w ;
 41: 	fo_FragColor . w = color. w ;
 42: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 75 with vertexShader bink_gui and fragmentShader bink_gui
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/stereoInterlace.vs.hlsl
-----------------
  1: // filename renderprogs/stereoInterlace.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[4];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: in vec2 in_TexCoord;
 14: 
 15: out vec2 vofi_TexCoord0;
 16: 
 17: void main() {
 18: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 19: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 20: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 21: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ;
 22: 	vofi_TexCoord0 = in_TexCoord ;
 23: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/stereoInterlace.ps.hlsl
-----------------
  1: // filename renderprogs/stereoInterlace.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: uniform sampler2D samp0;
 17: uniform sampler2D samp1;
 18: 
 19: in vec2 vofi_TexCoord0;
 20: 
 21: out vec4 fo_FragColor;
 22: 
 23: void main() {
 24: 	if ( fract ( gl_FragCoord . y * 0.5 ) < 0.5 )
 25: 	{
 26: 		fo_FragColor = texture ( samp0 , vec2 ( vofi_TexCoord0 ) ) ;
 27: 	}
 28: 	else
 29: 	{
 30: 		fo_FragColor = texture ( samp1 , vec2 ( vofi_TexCoord0 ) ) ;
 31: 	}
 32: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 76 with vertexShader stereoInterlace and fragmentShader stereoInterlace
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/motionBlur.vs.hlsl
-----------------
  1: // filename renderprogs/motionBlur.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: 
  8: in vec4 in_Position;
  9: in vec2 in_TexCoord;
 10: 
 11: out vec2 vofi_TexCoord0;
 12: 
 13: void main() {
 14: 	gl_Position = in_Position ;
 15: 	vofi_TexCoord0 = in_TexCoord ;
 16: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/motionBlur.ps.hlsl
-----------------
  1: // filename renderprogs/motionBlur.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[6];
 18: 
 19: uniform sampler2D samp0;
 20: uniform sampler2D samp1;
 21: 
 22: in vec2 vofi_TexCoord0;
 23: 
 24: out vec4 fo_FragColor;
 25: 
 26: void main() {
 27: 	if ( texture ( samp0 , vofi_TexCoord0 ). w == 0.0 )
 28: 	{
 29: 		discard ;
 30: 	}
 31: 	float windowZ = texture ( samp1 , vofi_TexCoord0 ). x ;
 32: 	vec3 ndc = vec3 ( vofi_TexCoord0 * 2.0 - 1.0 , windowZ * 2.0 - 1.0 ) ;
 33: 	float clipW = - _fa_[4 /* rpProjectionMatrixZ */] . w / ( - _fa_[4 /* rpProjectionMatrixZ */] . z - ndc. z ) ;
 34: 	vec4 clip = vec4 ( ndc * clipW , clipW ) ;
 35: 	vec4 reClip ;
 36: 	reClip. x = dot ( _fa_[0 /* rpMVPmatrixX */] , clip ) ;
 37: 	reClip. y = dot ( _fa_[1 /* rpMVPmatrixY */] , clip ) ;
 38: 	reClip. z = dot ( _fa_[2 /* rpMVPmatrixZ */] , clip ) ;
 39: 	reClip. w = dot ( _fa_[3 /* rpMVPmatrixW */] , clip ) ;
 40: 	vec2 prevTexCoord ;
 41: 	prevTexCoord. x = ( reClip. x / reClip. w ) * 0.5 + 0.5 ;
 42: 	prevTexCoord. y = ( reClip. y / reClip. w ) * 0.5 + 0.5 ;
 43: 	vec2 texCoord = prevTexCoord ;
 44: 	vec2 delta = ( vofi_TexCoord0 - prevTexCoord ) ;
 45: 	vec3 sum = vec3 ( 0.0 ) ;
 46: 	float goodSamples = 0.0 ;
 47: 	float samples = _fa_[5 /* rpOverbright */] . x ;
 48: 	for ( float i = 0.0 ; i < samples ; i = i + 1.0 )
 49: 	{
 50: 		vec2 pos = vofi_TexCoord0 + delta * ( ( i / ( samples - 1.0 ) ) - 0.5 ) ;
 51: 		vec4 color = texture ( samp0 , pos ) ;
 52: 		sum += color. xyz * color. w ;
 53: 		goodSamples += color. w ;
 54: 	}
 55: 	float invScale = 1.0 / goodSamples ;
 56: 	fo_FragColor = vec4 ( sum * invScale , 1.0 ) ;
 57: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 77 with vertexShader motionBlur and fragmentShader motionBlur
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

While compiling vertex program renderprogs/debug_shadowmap.vs.hlsl
-----------------
  1: // filename renderprogs/debug_shadowmap.vs.hlsl
  2: #version 450
  3: #pragma shader_stage( vertex )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: 
  7: uniform vec4 _va_[9];
  8: 
  9: float dot4 (vec4 a , vec4 b ) {return dot ( a , b ) ; }
 10: float dot4 (vec2 a , vec4 b ) {return dot ( vec4 ( a , 0 , 1 ) , b ) ; }
 11: 
 12: in vec4 in_Position;
 13: in vec2 in_TexCoord;
 14: in vec4 in_Normal;
 15: in vec4 in_Tangent;
 16: in vec4 in_Color;
 17: 
 18: out vec2 vofi_TexCoord0;
 19: 
 20: void main() {
 21: 	gl_Position . x = dot4 ( in_Position , _va_[0 /* rpMVPmatrixX */] ) ;
 22: 	gl_Position . y = dot4 ( in_Position , _va_[1 /* rpMVPmatrixY */] ) ;
 23: 	gl_Position . z = dot4 ( in_Position , _va_[2 /* rpMVPmatrixZ */] ) ;
 24: 	gl_Position . w = dot4 ( in_Position , _va_[3 /* rpMVPmatrixW */] ) ; if ( _va_[8 /* rpTexGen0Enabled */] . x > 0.0 )
 25: 	{
 26: 		vofi_TexCoord0 . x = dot4 ( in_Position , _va_[6 /* rpTexGen0S */] ) ;
 27: 		vofi_TexCoord0 . y = dot4 ( in_Position , _va_[7 /* rpTexGen0T */] ) ;
 28: 	}
 29: 	else
 30: 	{
 31: 		vofi_TexCoord0 . x = dot4 ( in_TexCoord . xy , _va_[4 /* rpTextureMatrixS */] ) ;
 32: 		vofi_TexCoord0 . y = dot4 ( in_TexCoord . xy , _va_[5 /* rpTextureMatrixT */] ) ;
 33: 	}
 34: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While compiling fragment program renderprogs/debug_shadowmap.ps.hlsl
-----------------
  1: // filename renderprogs/debug_shadowmap.ps.hlsl
  2: #version 450
  3: #pragma shader_stage( fragment )
  4: #extension GL_ARB_separate_shader_objects : enable
  5: 
  6: void clip( float v ) { if ( v < 0.0 ) { discard; } }
  7: void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }
  8: void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }
  9: void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }
 10: 
 11: float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }
 12: vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }
 13: vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }
 14: vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }
 15: 
 16: 
 17: uniform vec4 _fa_[1];
 18: 
 19: uniform sampler2DArray samp0;
 20: 
 21: in vec2 vofi_TexCoord0;
 22: 
 23: out vec4 fo_FragColor;
 24: 
 25: void main() {
 26: 	vec3 tc ;
 27: 	tc. xy = vofi_TexCoord0 . xy ;
 28: 	tc. z = _fa_[0 /* rpScreenCorrectionFactor */] . x ;
 29: 	fo_FragColor = texture ( samp0 , tc ) ;
 30: }
-----------------
ERROR: 0:2: '' :  version '450' is not supported
ERROR: 0:3: '' :  #version required and missing.

While linking GLSL program 78 with vertexShader debug_shadowmap and fragmentShader debug_shadowmap
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Tangent'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color2'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Position'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Color'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_TexCoord'.
WARNING: Do not have an attached vertex shader to match BindAttributeLocation request for 'in_Normal'.

----- Initializing Sound System ------
Setup OpenAL device and context... Done.
OpenAL vendor: OpenAL Community
OpenAL renderer: OpenAL Soft
OpenAL version: 1.1 ALSOFT 1.21.0
OpenAL extensions: AL_EXT_ALAW AL_EXT_BFORMAT AL_EXT_DOUBLE AL_EXT_EXPONENT_DISTANCE AL_EXT_FLOAT32 AL_EXT_IMA4 AL_EXT_LINEAR_DISTANCE AL_EXT_MCFORMATS AL_EXT_MULAW AL_EXT_MULAW_BFORMAT AL_EXT_MULAW_MCFORMATS AL_EXT_OFFSET AL_EXT_source_distance_model AL_EXT_SOURCE_RADIUS AL_EXT_STEREO_ANGLES AL_LOKI_quadriphonic AL_SOFT_bformat_ex AL_SOFTX_bformat_hoa AL_SOFT_block_alignment AL_SOFTX_callback_buffer AL_SOFTX_convolution_reverb AL_SOFT_deferred_updates AL_SOFT_direct_channels AL_SOFT_direct_channels_remix AL_SOFT_effect_target AL_SOFT_events AL_SOFTX_filter_gain_ex AL_SOFT_gain_clamp_ex AL_SOFT_loop_points AL_SOFTX_map_buffer AL_SOFT_MSADPCM AL_SOFT_source_latency AL_SOFT_source_length AL_SOFT_source_resampler AL_SOFT_source_spatialize
sound system initialized.
--------------------------------------
------- Initializing renderSystem --------
Binarize File: '_default' - reason 'generated image'
Binarize File: '_white' - reason 'generated image'
Binarize File: '_black' - reason 'generated image'
Binarize File: '_cyan' - reason 'generated image'
Binarize File: '_flat' - reason 'generated image'
Binarize File: '_alphaNotch' - reason 'generated image'
Binarize File: '_fog' - reason 'generated image'
Binarize File: '_fogEnter' - reason 'generated image'
Binarize File: '_noFalloff' - reason 'generated image'
Binarize File: '_quadratic' - reason 'generated image'
Binarize File: '_jitter1' - reason 'generated image'
Binarize File: '_jitter4' - reason 'generated image'
Binarize File: '_jitter16' - reason 'generated image'
Binarize File: '_random256' - reason 'generated image'
Binarize File: '_blueNoise256' - reason 'generated image'
Binarize File: '_heatmap5' - reason 'generated image'
Binarize File: '_heatmap7' - reason 'generated image'
Binarize File: '_grain1' - reason 'generated image'
Binarize File: '_smaaInput' - reason 'generated image'
Binarize File: '_smaaArea' - reason 'generated image'
Binarize File: '_smaaSearch' - reason 'generated image'
Binarize File: '_imguiFont' - reason 'generated image'
Binarize File: '_chromeSpec' - reason 'generated image'
Binarize File: '_plasticSpec' - reason 'generated image'
Binarize File: '_brdfLut' - reason 'generated image'
Binarize File: '_scratch' - reason 'generated image'
Binarize File: '_scratch2' - reason 'generated image'
Binarize File: '_accum' - reason 'generated image'
Binarize File: '_currentRender' - reason 'generated image'
WARNING: Couldn't load image: env/UAC2_amb : env/UAC2_amb#__0800
WARNING: Couldn't load image: env/UAC2_spec : env/UAC2_spec#__0800
Updating texture filter parameters.
renderSystem initialized.
--------------------------------------
Skipping Intro Videos!
Reading strings/english.lang as UTF-8
9104 strings read
--------- Initializing Game ----------
gamename: baseDOOM-1
gamedate: Dec  2 2020
Initializing event system
...540 event definitions
Initializing class hierarchy
...159 classes, 1010880 bytes for event callbacks
Initializing scripts
CPU frequency: 1.23516e-320 MHz
Compiled '/Users/seludeft/gits/RBDOOM-3-BFG/base/script/doom_main.script': inf ms
---------- Compile stats ----------

Memory usage:
     Strings: 120, 15840 bytes
  Statements: 95386, 3815440 bytes
   Functions: 3070, 496728 bytes
   Variables: 239712 bytes
    Mem used: 6284512 bytes
 Static data: 6266520 bytes
   Allocated: 8567312 bytes
 Thread size: 14064 bytes

...6 aas types
game initialized.
--------------------------------------
DEBUG :: idSessionLocalWin::Initialize()

DEBUG :: idCinematicLocal::InitFromFile :: BEGIN
DEBUG :: USE_BINKDEC
Loaded BinkDec file: 'video/intro/introloop.bik', looping=1512x512, 30.000000 FPS, 10800.000000 sec

DEBUG :: idCinematicLocal::InitFromFile :: BEGIN
DEBUG :: USE_BINKDEC
Loaded BinkDec file: 'video/mars1.bik', looping=0512x512, 30.000000 FPS, 28950.000000 sec

DEBUG :: idCinematicLocal::InitFromFile :: BEGIN
DEBUG :: USE_BINKDEC
Loaded BinkDec file: 'video/mars_rotation.bik', looping=11567x406, 30.000000 FPS, 90000.000000 sec
----- idRenderModelManagerLocal::EndLevelLoad -----
    0 models purged from previous level,     3 models kept.
---------------------------------------------------
----- idImageManager::EndLevelLoad -----
   30 images loaded in   0.0 seconds
----------------------------------------
----- idSoundSystemLocal::EndLevelLoad -----
    7 sounds loaded in   0.0 seconds
----------------------------------------
------------- Warnings ---------------
during DOOM 3: BFG Edition initialization...
WARNING: Unable to open resource file maps/_startup.resources
WARNING: Couldn't load image: env/UAC2_amb : env/UAC2_amb#__0800
WARNING: Couldn't load image: env/UAC2_spec : env/UAC2_spec#__0800
3 warnings
Preloading images...
00362 images preloaded ( or were already loaded ) in   0.3 seconds
----------------------------------------
00259 sounds preloaded in   0.1 seconds
----------------------------------------
WARNING: Couldn't load image: _doomclassic : _doomclassic#__0200
--- Common Initialization Complete ---
QA Timing IIS: 006249ms
DEBUG 